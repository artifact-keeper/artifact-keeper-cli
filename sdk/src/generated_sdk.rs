// This file is generated by `cargo xtask generate`. Do not edit.
#![allow(clippy::all, unused, dead_code, unreachable_code)]

#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{ClientHooks, OperationInfo, RequestBuilderExt, encode_path};
#[doc = r" Types used as operation parameters and responses."]
#[allow(clippy::all)]
pub mod types {
    #[doc = r" Error types."]
    pub mod error {
        #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    #[doc = "`AcknowledgeRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"reason\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"reason\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AcknowledgeRequest {
        pub reason: ::std::string::String,
    }
    impl AcknowledgeRequest {
        pub fn builder() -> builder::AcknowledgeRequest {
            Default::default()
        }
    }
    #[doc = "`AddBuildArtifactsRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildArtifactInputPayload\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddBuildArtifactsRequest {
        pub artifacts: ::std::vec::Vec<BuildArtifactInputPayload>,
    }
    impl AddBuildArtifactsRequest {
        pub fn builder() -> builder::AddBuildArtifactsRequest {
            Default::default()
        }
    }
    #[doc = "`AddBuildArtifactsResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildArtifactResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddBuildArtifactsResponse {
        pub artifacts: ::std::vec::Vec<BuildArtifactResponse>,
    }
    impl AddBuildArtifactsResponse {
        pub fn builder() -> builder::AddBuildArtifactsResponse {
            Default::default()
        }
    }
    #[doc = "`AddLabelRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddLabelRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for AddLabelRequest {
        fn default() -> Self {
            Self {
                value: Default::default(),
            }
        }
    }
    impl AddLabelRequest {
        pub fn builder() -> builder::AddLabelRequest {
            Default::default()
        }
    }
    #[doc = "`AddPeerLabelRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddPeerLabelRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for AddPeerLabelRequest {
        fn default() -> Self {
            Self {
                value: Default::default(),
            }
        }
    }
    impl AddPeerLabelRequest {
        pub fn builder() -> builder::AddPeerLabelRequest {
            Default::default()
        }
    }
    #[doc = "`AddVirtualMemberRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"member_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"member_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddVirtualMemberRequest {
        pub member_key: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub priority: ::std::option::Option<i32>,
    }
    impl AddVirtualMemberRequest {
        pub fn builder() -> builder::AddVirtualMemberRequest {
            Default::default()
        }
    }
    #[doc = "`AdminUserResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"auth_provider\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"email\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_active\","]
    #[doc = "    \"is_admin\","]
    #[doc = "    \"must_change_password\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"auth_provider\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_active\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"is_admin\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"last_login_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"must_change_password\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AdminUserResponse {
        pub auth_provider: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<::std::string::String>,
        pub email: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub is_active: bool,
        pub is_admin: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_login_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub must_change_password: bool,
        pub username: ::std::string::String,
    }
    impl AdminUserResponse {
        pub fn builder() -> builder::AdminUserResponse {
            Default::default()
        }
    }
    #[doc = "`AdvancedSearchResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"facets\","]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"facets\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/FacetsResponse\""]
    #[doc = "    },"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/SearchResultItem\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/PaginationInfo\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AdvancedSearchResponse {
        pub facets: FacetsResponse,
        pub items: ::std::vec::Vec<SearchResultItem>,
        pub pagination: PaginationInfo,
    }
    impl AdvancedSearchResponse {
        pub fn builder() -> builder::AdvancedSearchResponse {
            Default::default()
        }
    }
    #[doc = "Alert state for a service."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Alert state for a service.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"consecutive_failures\","]
    #[doc = "    \"current_status\","]
    #[doc = "    \"service_name\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"consecutive_failures\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"current_status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"last_alert_sent_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"service_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"suppressed_until\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AlertState {
        pub consecutive_failures: i32,
        pub current_status: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_alert_sent_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub service_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressed_until: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl AlertState {
        pub fn builder() -> builder::AlertState {
            Default::default()
        }
    }
    #[doc = "`AnnouncePeerRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"api_key\","]
    #[doc = "    \"endpoint_url\","]
    #[doc = "    \"name\","]
    #[doc = "    \"peer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"api_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"endpoint_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AnnouncePeerRequest {
        pub api_key: ::std::string::String,
        pub endpoint_url: ::std::string::String,
        pub name: ::std::string::String,
        pub peer_id: ::uuid::Uuid,
    }
    impl AnnouncePeerRequest {
        pub fn builder() -> builder::AnnouncePeerRequest {
            Default::default()
        }
    }
    #[doc = "`ApiTokenCreatedResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"token\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApiTokenCreatedResponse {
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub token: ::std::string::String,
    }
    impl ApiTokenCreatedResponse {
        pub fn builder() -> builder::ApiTokenCreatedResponse {
            Default::default()
        }
    }
    #[doc = "`ApiTokenListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ApiTokenResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApiTokenListResponse {
        pub items: ::std::vec::Vec<ApiTokenResponse>,
    }
    impl ApiTokenListResponse {
        pub fn builder() -> builder::ApiTokenListResponse {
            Default::default()
        }
    }
    #[doc = "`ApiTokenResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"scopes\","]
    #[doc = "    \"token_prefix\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"expires_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"last_used_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"scopes\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"token_prefix\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApiTokenResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_used_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub name: ::std::string::String,
        pub scopes: ::std::vec::Vec<::std::string::String>,
        pub token_prefix: ::std::string::String,
    }
    impl ApiTokenResponse {
        pub fn builder() -> builder::ApiTokenResponse {
            Default::default()
        }
    }
    #[doc = "`ApprovalHistoryQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"source_repository\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApprovalHistoryQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_repository: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ApprovalHistoryQuery {
        fn default() -> Self {
            Self {
                page: Default::default(),
                per_page: Default::default(),
                source_repository: Default::default(),
                status: Default::default(),
            }
        }
    }
    impl ApprovalHistoryQuery {
        pub fn builder() -> builder::ApprovalHistoryQuery {
            Default::default()
        }
    }
    #[doc = "`ApprovalListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ApprovalResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApprovalListResponse {
        pub items: ::std::vec::Vec<ApprovalResponse>,
        pub pagination: Pagination,
    }
    impl ApprovalListResponse {
        pub fn builder() -> builder::ApprovalListResponse {
            Default::default()
        }
    }
    #[doc = "`ApprovalRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"source_repository\","]
    #[doc = "    \"target_repository\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"description\": \"Artifact ID to promote\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"description\": \"Free-text justification\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"skip_policy_check\": {"]
    #[doc = "      \"description\": \"Skip policy evaluation\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"source_repository\": {"]
    #[doc = "      \"description\": \"Source staging repository key\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_repository\": {"]
    #[doc = "      \"description\": \"Target release repository key\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApprovalRequest {
        #[doc = "Artifact ID to promote"]
        pub artifact_id: ::uuid::Uuid,
        #[doc = "Free-text justification"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        #[doc = "Skip policy evaluation"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_policy_check: ::std::option::Option<bool>,
        #[doc = "Source staging repository key"]
        pub source_repository: ::std::string::String,
        #[doc = "Target release repository key"]
        pub target_repository: ::std::string::String,
    }
    impl ApprovalRequest {
        pub fn builder() -> builder::ApprovalRequest {
            Default::default()
        }
    }
    #[doc = "`ApprovalResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"id\","]
    #[doc = "    \"requested_at\","]
    #[doc = "    \"requested_by\","]
    #[doc = "    \"source_repository\","]
    #[doc = "    \"status\","]
    #[doc = "    \"target_repository\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"policy_result\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"requested_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"requested_by\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"review_notes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"reviewed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"reviewed_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"source_repository\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_repository\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApprovalResponse {
        pub artifact_id: ::uuid::Uuid,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub policy_result:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub requested_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub requested_by: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub review_notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reviewed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reviewed_by: ::std::option::Option<::uuid::Uuid>,
        pub source_repository: ::std::string::String,
        pub status: ::std::string::String,
        pub target_repository: ::std::string::String,
    }
    impl ApprovalResponse {
        pub fn builder() -> builder::ApprovalResponse {
            Default::default()
        }
    }
    #[doc = "`ArtifactEvalEntry`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"passed\","]
    #[doc = "    \"violations\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"passed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"violations\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactEvalEntry {
        pub artifact_id: ::uuid::Uuid,
        pub passed: bool,
        pub violations: ::std::vec::Vec<::std::string::String>,
    }
    impl ArtifactEvalEntry {
        pub fn builder() -> builder::ArtifactEvalEntry {
            Default::default()
        }
    }
    #[doc = "`ArtifactFilterSchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"exclude_paths\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"include_paths\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"max_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_size_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactFilterSchema {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub exclude_paths: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub include_paths: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_age_days: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_size_bytes: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for ArtifactFilterSchema {
        fn default() -> Self {
            Self {
                exclude_paths: Default::default(),
                include_paths: Default::default(),
                max_age_days: Default::default(),
                max_size_bytes: Default::default(),
            }
        }
    }
    impl ArtifactFilterSchema {
        pub fn builder() -> builder::ArtifactFilterSchema {
            Default::default()
        }
    }
    #[doc = "`ArtifactHealthResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"checks\","]
    #[doc = "    \"checks_passed\","]
    #[doc = "    \"checks_total\","]
    #[doc = "    \"critical_issues\","]
    #[doc = "    \"health_grade\","]
    #[doc = "    \"health_score\","]
    #[doc = "    \"total_issues\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"checks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/CheckSummary\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"checks_passed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"checks_total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"critical_issues\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"health_grade\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"health_score\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"last_checked_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"license_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"metadata_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"quality_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"security_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"total_issues\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactHealthResponse {
        pub artifact_id: ::uuid::Uuid,
        pub checks: ::std::vec::Vec<CheckSummary>,
        pub checks_passed: i32,
        pub checks_total: i32,
        pub critical_issues: i32,
        pub health_grade: ::std::string::String,
        pub health_score: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_checked_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub license_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub quality_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub security_score: ::std::option::Option<i32>,
        pub total_issues: i32,
    }
    impl ArtifactHealthResponse {
        pub fn builder() -> builder::ArtifactHealthResponse {
            Default::default()
        }
    }
    #[doc = "`ArtifactListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ArtifactResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactListResponse {
        pub items: ::std::vec::Vec<ArtifactResponse>,
        pub pagination: Pagination,
    }
    impl ArtifactListResponse {
        pub fn builder() -> builder::ArtifactListResponse {
            Default::default()
        }
    }
    #[doc = "`ArtifactMetadataResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"format\","]
    #[doc = "    \"metadata\","]
    #[doc = "    \"properties\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {},"]
    #[doc = "    \"properties\": {}"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactMetadataResponse {
        pub artifact_id: ::uuid::Uuid,
        pub format: ::std::string::String,
        pub metadata: ::serde_json::Value,
        pub properties: ::serde_json::Value,
    }
    impl ArtifactMetadataResponse {
        pub fn builder() -> builder::ArtifactMetadataResponse {
            Default::default()
        }
    }
    #[doc = "`ArtifactResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"content_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"content_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactResponse {
        pub checksum_sha256: ::std::string::String,
        pub content_type: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub download_count: i64,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        pub repository_key: ::std::string::String,
        pub size_bytes: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl ArtifactResponse {
        pub fn builder() -> builder::ArtifactResponse {
            Default::default()
        }
    }
    #[doc = "`ArtifactStatsResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"download_count\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"first_downloaded\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"last_downloaded\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArtifactStatsResponse {
        pub artifact_id: ::uuid::Uuid,
        pub download_count: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_downloaded: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_downloaded: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl ArtifactStatsResponse {
        pub fn builder() -> builder::ArtifactStatsResponse {
            Default::default()
        }
    }
    #[doc = "`AssessmentResult`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"blockers\","]
    #[doc = "    \"estimated_duration_seconds\","]
    #[doc = "    \"groups_count\","]
    #[doc = "    \"job_id\","]
    #[doc = "    \"permissions_count\","]
    #[doc = "    \"repositories\","]
    #[doc = "    \"status\","]
    #[doc = "    \"total_artifacts\","]
    #[doc = "    \"total_size_bytes\","]
    #[doc = "    \"users_count\","]
    #[doc = "    \"warnings\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"blockers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"estimated_duration_seconds\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"groups_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"job_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"permissions_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repositories\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/RepositoryAssessment\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"total_artifacts\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"users_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"warnings\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssessmentResult {
        pub blockers: ::std::vec::Vec<::std::string::String>,
        pub estimated_duration_seconds: i64,
        pub groups_count: i64,
        pub job_id: ::uuid::Uuid,
        pub permissions_count: i64,
        pub repositories: ::std::vec::Vec<RepositoryAssessment>,
        pub status: ::std::string::String,
        pub total_artifacts: i64,
        pub total_size_bytes: i64,
        pub users_count: i64,
        pub warnings: ::std::vec::Vec<::std::string::String>,
    }
    impl AssessmentResult {
        pub fn builder() -> builder::AssessmentResult {
            Default::default()
        }
    }
    #[doc = "`AssignRepoRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"repository_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"replication_mode\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"replication_schedule\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"sync_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssignRepoRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub replication_mode: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub replication_schedule: ::std::option::Option<::std::string::String>,
        pub repository_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sync_enabled: ::std::option::Option<bool>,
    }
    impl AssignRepoRequest {
        pub fn builder() -> builder::AssignRepoRequest {
            Default::default()
        }
    }
    #[doc = "`AssignRoleRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"role_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"role_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssignRoleRequest {
        pub role_id: ::uuid::Uuid,
    }
    impl AssignRoleRequest {
        pub fn builder() -> builder::AssignRoleRequest {
            Default::default()
        }
    }
    #[doc = "`BackupListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BackupResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BackupListResponse {
        pub items: ::std::vec::Vec<BackupResponse>,
        pub total: i64,
    }
    impl BackupListResponse {
        pub fn builder() -> builder::BackupListResponse {
            Default::default()
        }
    }
    #[doc = "`BackupResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_count\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"status\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"completed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"created_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"error_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"storage_path\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BackupResponse {
        pub artifact_count: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_by: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub size_bytes: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub storage_path: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }
    impl BackupResponse {
        pub fn builder() -> builder::BackupResponse {
            Default::default()
        }
    }
    #[doc = "`BuildArtifact`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildArtifact {
        pub checksum_sha256: ::std::string::String,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        pub size_bytes: i64,
    }
    impl BuildArtifact {
        pub fn builder() -> builder::BuildArtifact {
            Default::default()
        }
    }
    #[doc = "`BuildArtifactDiff`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"new_checksum\","]
    #[doc = "    \"new_size_bytes\","]
    #[doc = "    \"old_checksum\","]
    #[doc = "    \"old_size_bytes\","]
    #[doc = "    \"path\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"new_checksum\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"new_size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"old_checksum\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"old_size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildArtifactDiff {
        pub name: ::std::string::String,
        pub new_checksum: ::std::string::String,
        pub new_size_bytes: i64,
        pub old_checksum: ::std::string::String,
        pub old_size_bytes: i64,
        pub path: ::std::string::String,
    }
    impl BuildArtifactDiff {
        pub fn builder() -> builder::BuildArtifactDiff {
            Default::default()
        }
    }
    #[doc = "`BuildArtifactInputPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"module_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildArtifactInputPayload {
        pub checksum_sha256: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub module_name: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        pub size_bytes: i64,
    }
    impl BuildArtifactInputPayload {
        pub fn builder() -> builder::BuildArtifactInputPayload {
            Default::default()
        }
    }
    #[doc = "`BuildArtifactResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"build_id\","]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"build_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"module_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildArtifactResponse {
        pub build_id: ::uuid::Uuid,
        pub checksum_sha256: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub module_name: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        pub size_bytes: i64,
    }
    impl BuildArtifactResponse {
        pub fn builder() -> builder::BuildArtifactResponse {
            Default::default()
        }
    }
    #[doc = "`BuildDiffQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"build_a\","]
    #[doc = "    \"build_b\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"build_a\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"build_b\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildDiffQuery {
        pub build_a: ::uuid::Uuid,
        pub build_b: ::uuid::Uuid,
    }
    impl BuildDiffQuery {
        pub fn builder() -> builder::BuildDiffQuery {
            Default::default()
        }
    }
    #[doc = "`BuildDiffResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"added\","]
    #[doc = "    \"build_a\","]
    #[doc = "    \"build_b\","]
    #[doc = "    \"modified\","]
    #[doc = "    \"removed\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"added\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildArtifact\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"build_a\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"build_b\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"modified\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildArtifactDiff\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"removed\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildArtifact\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildDiffResponse {
        pub added: ::std::vec::Vec<BuildArtifact>,
        pub build_a: ::uuid::Uuid,
        pub build_b: ::uuid::Uuid,
        pub modified: ::std::vec::Vec<BuildArtifactDiff>,
        pub removed: ::std::vec::Vec<BuildArtifact>,
    }
    impl BuildDiffResponse {
        pub fn builder() -> builder::BuildDiffResponse {
            Default::default()
        }
    }
    #[doc = "`BuildListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildListResponse {
        pub items: ::std::vec::Vec<BuildResponse>,
        pub pagination: Pagination,
    }
    impl BuildListResponse {
        pub fn builder() -> builder::BuildListResponse {
            Default::default()
        }
    }
    #[doc = "`BuildModule`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildArtifact\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildModule {
        pub artifacts: ::std::vec::Vec<BuildArtifact>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
    }
    impl BuildModule {
        pub fn builder() -> builder::BuildModule {
            Default::default()
        }
    }
    #[doc = "`BuildResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"number\","]
    #[doc = "    \"status\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"agent\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"artifact_count\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"duration_ms\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"finished_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"modules\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/BuildModule\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"number\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"vcs_branch\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vcs_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vcs_revision\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vcs_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_count: ::std::option::Option<i32>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub duration_ms: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub finished_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub modules: ::std::option::Option<::std::vec::Vec<BuildModule>>,
        pub name: ::std::string::String,
        pub number: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_branch: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_revision: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_url: ::std::option::Option<::std::string::String>,
    }
    impl BuildResponse {
        pub fn builder() -> builder::BuildResponse {
            Default::default()
        }
    }
    #[doc = "`BuildRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"build_number\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"status\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"agent\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"artifact_count\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"build_number\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"duration_ms\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"finished_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BuildRow {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_count: ::std::option::Option<i32>,
        pub build_number: i32,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub duration_ms: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub finished_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl BuildRow {
        pub fn builder() -> builder::BuildRow {
            Default::default()
        }
    }
    #[doc = "`BulkEvaluationResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"failed\","]
    #[doc = "    \"passed\","]
    #[doc = "    \"results\","]
    #[doc = "    \"rule_id\","]
    #[doc = "    \"rule_name\","]
    #[doc = "    \"total_artifacts\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"failed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"passed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"results\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ArtifactEvalEntry\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"rule_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"rule_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"total_artifacts\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BulkEvaluationResponse {
        pub failed: u64,
        pub passed: u64,
        pub results: ::std::vec::Vec<ArtifactEvalEntry>,
        pub rule_id: ::uuid::Uuid,
        pub rule_name: ::std::string::String,
        pub total_artifacts: u64,
    }
    impl BulkEvaluationResponse {
        pub fn builder() -> builder::BulkEvaluationResponse {
            Default::default()
        }
    }
    #[doc = "`BulkPromoteRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_ids\","]
    #[doc = "    \"target_repository\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"format\": \"uuid\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"skip_policy_check\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"target_repository\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BulkPromoteRequest {
        pub artifact_ids: ::std::vec::Vec<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_policy_check: ::std::option::Option<bool>,
        pub target_repository: ::std::string::String,
    }
    impl BulkPromoteRequest {
        pub fn builder() -> builder::BulkPromoteRequest {
            Default::default()
        }
    }
    #[doc = "`BulkPromotionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"failed\","]
    #[doc = "    \"promoted\","]
    #[doc = "    \"results\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"failed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"promoted\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"results\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PromotionResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BulkPromotionResponse {
        pub failed: u64,
        pub promoted: u64,
        pub results: ::std::vec::Vec<PromotionResponse>,
        pub total: u64,
    }
    impl BulkPromotionResponse {
        pub fn builder() -> builder::BulkPromotionResponse {
            Default::default()
        }
    }
    #[doc = "`ChangePasswordRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"new_password\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"current_password\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"new_password\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChangePasswordRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_password: ::std::option::Option<::std::string::String>,
        pub new_password: ::std::string::String,
    }
    impl ChangePasswordRequest {
        pub fn builder() -> builder::ChangePasswordRequest {
            Default::default()
        }
    }
    #[doc = "`CheckLicenseComplianceRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"licenses\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CheckLicenseComplianceRequest {
        pub licenses: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl CheckLicenseComplianceRequest {
        pub fn builder() -> builder::CheckLicenseComplianceRequest {
            Default::default()
        }
    }
    #[doc = "`CheckResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"check_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"critical_count\","]
    #[doc = "    \"high_count\","]
    #[doc = "    \"id\","]
    #[doc = "    \"info_count\","]
    #[doc = "    \"issues_count\","]
    #[doc = "    \"low_count\","]
    #[doc = "    \"medium_count\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"check_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"checker_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"completed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"critical_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"error_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"high_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"info_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"issues_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"low_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"medium_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"passed\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CheckResponse {
        pub artifact_id: ::uuid::Uuid,
        pub check_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checker_version: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub critical_count: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        pub high_count: i32,
        pub id: ::uuid::Uuid,
        pub info_count: i32,
        pub issues_count: i32,
        pub low_count: i32,
        pub medium_count: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub passed: ::std::option::Option<bool>,
        pub repository_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
    }
    impl CheckResponse {
        pub fn builder() -> builder::CheckResponse {
            Default::default()
        }
    }
    #[doc = "`CheckStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CheckStatus {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
        pub status: ::std::string::String,
    }
    impl CheckStatus {
        pub fn builder() -> builder::CheckStatus {
            Default::default()
        }
    }
    #[doc = "`CheckSummary`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"check_type\","]
    #[doc = "    \"issues_count\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"check_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"completed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"issues_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"passed\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CheckSummary {
        pub check_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub issues_count: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub passed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub score: ::std::option::Option<i32>,
        pub status: ::std::string::String,
    }
    impl CheckSummary {
        pub fn builder() -> builder::CheckSummary {
            Default::default()
        }
    }
    #[doc = "`ChecksumArtifact`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"content_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"content_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChecksumArtifact {
        pub checksum_sha256: ::std::string::String,
        pub content_type: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub download_count: i64,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        pub repository_key: ::std::string::String,
        pub size_bytes: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl ChecksumArtifact {
        pub fn builder() -> builder::ChecksumArtifact {
            Default::default()
        }
    }
    #[doc = "`ChecksumSearchResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ChecksumArtifact\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChecksumSearchResponse {
        pub artifacts: ::std::vec::Vec<ChecksumArtifact>,
    }
    impl ChecksumSearchResponse {
        pub fn builder() -> builder::ChecksumSearchResponse {
            Default::default()
        }
    }
    #[doc = "`ChunkAvailabilityResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"available_chunks\","]
    #[doc = "    \"chunk_bitmap\","]
    #[doc = "    \"peer_instance_id\","]
    #[doc = "    \"total_chunks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"available_chunks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"chunk_bitmap\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"integer\","]
    #[doc = "        \"format\": \"int32\","]
    #[doc = "        \"minimum\": 0.0"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"peer_instance_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"total_chunks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChunkAvailabilityResponse {
        pub artifact_id: ::uuid::Uuid,
        pub available_chunks: i32,
        pub chunk_bitmap: ::std::vec::Vec<i32>,
        pub peer_instance_id: ::uuid::Uuid,
        pub total_chunks: i32,
    }
    impl ChunkAvailabilityResponse {
        pub fn builder() -> builder::ChunkAvailabilityResponse {
            Default::default()
        }
    }
    #[doc = "`ChunkEntry`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"byte_length\","]
    #[doc = "    \"byte_offset\","]
    #[doc = "    \"checksum\","]
    #[doc = "    \"chunk_index\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"byte_length\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"byte_offset\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"checksum\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chunk_index\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"source_peer_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChunkEntry {
        pub byte_length: i32,
        pub byte_offset: i64,
        pub checksum: ::std::string::String,
        pub chunk_index: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_peer_id: ::std::option::Option<::uuid::Uuid>,
        pub status: ::std::string::String,
    }
    impl ChunkEntry {
        pub fn builder() -> builder::ChunkEntry {
            Default::default()
        }
    }
    #[doc = "`ChunkManifestResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chunks\","]
    #[doc = "    \"session_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chunks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ChunkEntry\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"session_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChunkManifestResponse {
        pub chunks: ::std::vec::Vec<ChunkEntry>,
        pub session_id: ::uuid::Uuid,
    }
    impl ChunkManifestResponse {
        pub fn builder() -> builder::ChunkManifestResponse {
            Default::default()
        }
    }
    #[doc = "`CleanupRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"cleanup_audit_logs\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"cleanup_old_backups\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"cleanup_stale_peers\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CleanupRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cleanup_audit_logs: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cleanup_old_backups: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cleanup_stale_peers: ::std::option::Option<bool>,
    }
    impl ::std::default::Default for CleanupRequest {
        fn default() -> Self {
            Self {
                cleanup_audit_logs: Default::default(),
                cleanup_old_backups: Default::default(),
                cleanup_stale_peers: Default::default(),
            }
        }
    }
    impl CleanupRequest {
        pub fn builder() -> builder::CleanupRequest {
            Default::default()
        }
    }
    #[doc = "`CleanupResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"audit_logs_deleted\","]
    #[doc = "    \"backups_deleted\","]
    #[doc = "    \"peers_marked_offline\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"audit_logs_deleted\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"backups_deleted\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"peers_marked_offline\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CleanupResponse {
        pub audit_logs_deleted: i64,
        pub backups_deleted: i64,
        pub peers_marked_offline: i64,
    }
    impl CleanupResponse {
        pub fn builder() -> builder::CleanupResponse {
            Default::default()
        }
    }
    #[doc = "`CompleteChunkBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_peer_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CompleteChunkBody {
        pub checksum: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_peer_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl CompleteChunkBody {
        pub fn builder() -> builder::CompleteChunkBody {
            Default::default()
        }
    }
    #[doc = "`ComponentResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"licenses\","]
    #[doc = "    \"name\","]
    #[doc = "    \"sbom_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"author\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"component_type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"cpe\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"md5\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"purl\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sbom_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"sha1\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sha256\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"supplier\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ComponentResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub author: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub component_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cpe: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub licenses: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub md5: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub purl: ::std::option::Option<::std::string::String>,
        pub sbom_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sha1: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sha256: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supplier: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl ComponentResponse {
        pub fn builder() -> builder::ComponentResponse {
            Default::default()
        }
    }
    #[doc = "`ConnectionCredentials`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"password\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"token\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectionCredentials {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub password: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub token: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ConnectionCredentials {
        fn default() -> Self {
            Self {
                password: Default::default(),
                token: Default::default(),
                username: Default::default(),
            }
        }
    }
    impl ConnectionCredentials {
        pub fn builder() -> builder::ConnectionCredentials {
            Default::default()
        }
    }
    #[doc = "`ConnectionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"auth_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"source_type\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"auth_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectionResponse {
        pub auth_type: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub source_type: ::std::string::String,
        pub url: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub verified_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl ConnectionResponse {
        pub fn builder() -> builder::ConnectionResponse {
            Default::default()
        }
    }
    #[doc = "`ConnectionTestResult`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\","]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifactory_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"license_type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectionTestResult {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifactory_version: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub license_type: ::std::option::Option<::std::string::String>,
        pub message: ::std::string::String,
        pub success: bool,
    }
    impl ConnectionTestResult {
        pub fn builder() -> builder::ConnectionTestResult {
            Default::default()
        }
    }
    #[doc = "`ConvertSbomRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"target_format\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"target_format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConvertSbomRequest {
        pub target_format: ::std::string::String,
    }
    impl ConvertSbomRequest {
        pub fn builder() -> builder::ConvertSbomRequest {
            Default::default()
        }
    }
    #[doc = "`CrashListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/CrashReport\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CrashListResponse {
        pub items: ::std::vec::Vec<CrashReport>,
        pub total: i64,
    }
    impl CrashListResponse {
        pub fn builder() -> builder::CrashListResponse {
            Default::default()
        }
    }
    #[doc = "A stored crash report."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"A stored crash report.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"app_version\","]
    #[doc = "    \"component\","]
    #[doc = "    \"context\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"error_message\","]
    #[doc = "    \"error_signature\","]
    #[doc = "    \"error_type\","]
    #[doc = "    \"first_seen_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"last_seen_at\","]
    #[doc = "    \"occurrence_count\","]
    #[doc = "    \"severity\","]
    #[doc = "    \"submitted\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"app_version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"component\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"context\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"error_message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error_signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_seen_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"last_seen_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"occurrence_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"os_info\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"stack_trace\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"submission_error\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"submitted\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"submitted_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"uptime_seconds\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CrashReport {
        pub app_version: ::std::string::String,
        pub component: ::std::string::String,
        pub context: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub error_message: ::std::string::String,
        pub error_signature: ::std::string::String,
        pub error_type: ::std::string::String,
        pub first_seen_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub last_seen_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub occurrence_count: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub os_info: ::std::option::Option<::std::string::String>,
        pub severity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub stack_trace: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub submission_error: ::std::option::Option<::std::string::String>,
        pub submitted: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub submitted_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uptime_seconds: ::std::option::Option<i64>,
    }
    impl CrashReport {
        pub fn builder() -> builder::CrashReport {
            Default::default()
        }
    }
    #[doc = "Create API token request"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Create API token request\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"scopes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"expires_in_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"scopes\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateApiTokenRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_in_days: ::std::option::Option<i64>,
        pub name: ::std::string::String,
        pub scopes: ::std::vec::Vec<::std::string::String>,
    }
    impl CreateApiTokenRequest {
        pub fn builder() -> builder::CreateApiTokenRequest {
            Default::default()
        }
    }
    #[doc = "Create API token response"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Create API token response\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"token\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateApiTokenResponse {
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub token: ::std::string::String,
    }
    impl CreateApiTokenResponse {
        pub fn builder() -> builder::CreateApiTokenResponse {
            Default::default()
        }
    }
    #[doc = "`CreateBackupRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"repository_ids\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"format\": \"uuid\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateBackupRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_ids: ::std::option::Option<::std::vec::Vec<::uuid::Uuid>>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for CreateBackupRequest {
        fn default() -> Self {
            Self {
                repository_ids: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl CreateBackupRequest {
        pub fn builder() -> builder::CreateBackupRequest {
            Default::default()
        }
    }
    #[doc = "`CreateBuildRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"build_number\","]
    #[doc = "    \"metadata\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"agent\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"build_number\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"vcs_branch\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vcs_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vcs_revision\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vcs_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateBuildRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent: ::std::option::Option<::std::string::String>,
        pub build_number: i32,
        pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_branch: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_revision: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vcs_url: ::std::option::Option<::std::string::String>,
    }
    impl CreateBuildRequest {
        pub fn builder() -> builder::CreateBuildRequest {
            Default::default()
        }
    }
    #[doc = "`CreateConnectionRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"auth_type\","]
    #[doc = "    \"credentials\","]
    #[doc = "    \"name\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"auth_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"credentials\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConnectionCredentials\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_type\": {"]
    #[doc = "      \"description\": \"Source registry type: \\\"artifactory\\\" (default) or \\\"nexus\\\"\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateConnectionRequest {
        pub auth_type: ::std::string::String,
        pub credentials: ConnectionCredentials,
        pub name: ::std::string::String,
        #[doc = "Source registry type: \"artifactory\" (default) or \"nexus\""]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_type: ::std::option::Option<::std::string::String>,
        pub url: ::std::string::String,
    }
    impl CreateConnectionRequest {
        pub fn builder() -> builder::CreateConnectionRequest {
            Default::default()
        }
    }
    #[doc = "`CreateGateRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"enforce_on_download\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"enforce_on_promotion\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_critical_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_high_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_medium_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_health_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_metadata_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_quality_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_security_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"required_checks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateGateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub action: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enforce_on_download: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enforce_on_promotion: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_critical_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_high_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_medium_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_health_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_metadata_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_quality_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_security_score: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub required_checks: ::std::vec::Vec<::std::string::String>,
    }
    impl CreateGateRequest {
        pub fn builder() -> builder::CreateGateRequest {
            Default::default()
        }
    }
    #[doc = "`CreateGroupRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateGroupRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
    }
    impl CreateGroupRequest {
        pub fn builder() -> builder::CreateGroupRequest {
            Default::default()
        }
    }
    #[doc = "`CreateInstanceRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"api_key\","]
    #[doc = "    \"name\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"api_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateInstanceRequest {
        pub api_key: ::std::string::String,
        pub name: ::std::string::String,
        pub url: ::std::string::String,
    }
    impl CreateInstanceRequest {
        pub fn builder() -> builder::CreateInstanceRequest {
            Default::default()
        }
    }
    #[doc = "`CreateKeyPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"algorithm\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"key_type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"uid_email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"uid_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateKeyPayload {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub algorithm: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub key_type: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uid_email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uid_name: ::std::option::Option<::std::string::String>,
    }
    impl CreateKeyPayload {
        pub fn builder() -> builder::CreateKeyPayload {
            Default::default()
        }
    }
    #[doc = "`CreateLdapConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"server_url\","]
    #[doc = "    \"user_base_dn\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"admin_group_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"bind_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"bind_password\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"display_name_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"email_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"group_base_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"group_filter\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"groups_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"server_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"use_starttls\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"user_base_dn\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"user_filter\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateLdapConfigRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bind_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bind_password: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name_attribute: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email_attribute: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_base_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_filter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub groups_attribute: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub priority: ::std::option::Option<i32>,
        pub server_url: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub use_starttls: ::std::option::Option<bool>,
        pub user_base_dn: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_filter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username_attribute: ::std::option::Option<::std::string::String>,
    }
    impl CreateLdapConfigRequest {
        pub fn builder() -> builder::CreateLdapConfigRequest {
            Default::default()
        }
    }
    #[doc = "`CreateMigrationRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"config\","]
    #[doc = "    \"source_connection_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"job_type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"source_connection_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateMigrationRequest {
        pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub job_type: ::std::option::Option<::std::string::String>,
        pub source_connection_id: ::uuid::Uuid,
    }
    impl CreateMigrationRequest {
        pub fn builder() -> builder::CreateMigrationRequest {
            Default::default()
        }
    }
    #[doc = "`CreateOidcConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"client_id\","]
    #[doc = "    \"client_secret\","]
    #[doc = "    \"issuer_url\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"attribute_mapping\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"auto_create_users\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"client_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"client_secret\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"issuer_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"scopes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateOidcConfigRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attribute_mapping:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_create_users: ::std::option::Option<bool>,
        pub client_id: ::std::string::String,
        pub client_secret: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        pub issuer_url: ::std::string::String,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scopes: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    }
    impl CreateOidcConfigRequest {
        pub fn builder() -> builder::CreateOidcConfigRequest {
            Default::default()
        }
    }
    #[doc = "`CreatePermissionRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"actions\","]
    #[doc = "    \"principal_id\","]
    #[doc = "    \"principal_type\","]
    #[doc = "    \"target_id\","]
    #[doc = "    \"target_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"actions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"principal_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"target_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatePermissionRequest {
        pub actions: ::std::vec::Vec<::std::string::String>,
        pub principal_id: ::uuid::Uuid,
        pub principal_type: ::std::string::String,
        pub target_id: ::uuid::Uuid,
        pub target_type: ::std::string::String,
    }
    impl CreatePermissionRequest {
        pub fn builder() -> builder::CreatePermissionRequest {
            Default::default()
        }
    }
    #[doc = "`CreatePolicyRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"block_on_fail\","]
    #[doc = "    \"block_unscanned\","]
    #[doc = "    \"max_severity\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"block_on_fail\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"block_unscanned\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_artifact_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"min_staging_hours\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"require_signature\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatePolicyRequest {
        pub block_on_fail: bool,
        pub block_unscanned: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_artifact_age_days: ::std::option::Option<i32>,
        pub max_severity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_staging_hours: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signature: ::std::option::Option<bool>,
    }
    impl CreatePolicyRequest {
        pub fn builder() -> builder::CreatePolicyRequest {
            Default::default()
        }
    }
    #[doc = "`CreateRepositoryRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"format\","]
    #[doc = "    \"key\","]
    #[doc = "    \"name\","]
    #[doc = "    \"repo_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"is_public\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"quota_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repo_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"upstream_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateRepositoryRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub format: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_public: ::std::option::Option<bool>,
        pub key: ::std::string::String,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub quota_bytes: ::std::option::Option<i64>,
        pub repo_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub upstream_url: ::std::option::Option<::std::string::String>,
    }
    impl CreateRepositoryRequest {
        pub fn builder() -> builder::CreateRepositoryRequest {
            Default::default()
        }
    }
    #[doc = "`CreateRuleRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"source_repo_id\","]
    #[doc = "    \"target_repo_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"allowed_licenses\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"auto_promote\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_artifact_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_cve_severity\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"min_health_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_staging_hours\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"require_signature\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"source_repo_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"target_repo_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateRuleRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allowed_licenses: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_promote: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_artifact_age_days: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_cve_severity: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_health_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_staging_hours: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signature: ::std::option::Option<bool>,
        pub source_repo_id: ::uuid::Uuid,
        pub target_repo_id: ::uuid::Uuid,
    }
    impl CreateRuleRequest {
        pub fn builder() -> builder::CreateRuleRequest {
            Default::default()
        }
    }
    #[doc = "`CreateSamlConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"certificate\","]
    #[doc = "    \"entity_id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"sso_url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"admin_group\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"attribute_mapping\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"certificate\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"entity_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name_id_format\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"require_signed_assertions\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sign_requests\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"slo_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sp_entity_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sso_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateSamlConfigRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attribute_mapping:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub certificate: ::std::string::String,
        pub entity_id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name_id_format: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signed_assertions: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sign_requests: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub slo_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sp_entity_id: ::std::option::Option<::std::string::String>,
        pub sso_url: ::std::string::String,
    }
    impl CreateSamlConfigRequest {
        pub fn builder() -> builder::CreateSamlConfigRequest {
            Default::default()
        }
    }
    #[doc = "`CreateSyncPolicyPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_filter\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"precedence\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"replication_mode\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repo_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateSyncPolicyPayload {
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub artifact_filter: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enabled: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub peer_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub precedence: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub priority: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub replication_mode: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub repo_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl CreateSyncPolicyPayload {
        pub fn builder() -> builder::CreateSyncPolicyPayload {
            Default::default()
        }
    }
    #[doc = "`CreateTicketRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"purpose\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"purpose\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"resource_path\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateTicketRequest {
        pub purpose: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource_path: ::std::option::Option<::std::string::String>,
    }
    impl CreateTicketRequest {
        pub fn builder() -> builder::CreateTicketRequest {
            Default::default()
        }
    }
    #[doc = "`CreateUserRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"is_admin\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"password\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<::std::string::String>,
        pub email: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_admin: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub password: ::std::option::Option<::std::string::String>,
        pub username: ::std::string::String,
    }
    impl CreateUserRequest {
        pub fn builder() -> builder::CreateUserRequest {
            Default::default()
        }
    }
    #[doc = "`CreateUserResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"user\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"generated_password\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"user\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/AdminUserResponse\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub generated_password: ::std::option::Option<::std::string::String>,
        pub user: AdminUserResponse,
    }
    impl CreateUserResponse {
        pub fn builder() -> builder::CreateUserResponse {
            Default::default()
        }
    }
    #[doc = "`CreateWebhookRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"events\","]
    #[doc = "    \"name\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"events\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"headers\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"secret\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateWebhookRequest {
        pub events: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub headers:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub secret: ::std::option::Option<::std::string::String>,
        pub url: ::std::string::String,
    }
    impl CreateWebhookRequest {
        pub fn builder() -> builder::CreateWebhookRequest {
            Default::default()
        }
    }
    #[doc = "`CreatedGroupRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatedGroupRow {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl CreatedGroupRow {
        pub fn builder() -> builder::CreatedGroupRow {
            Default::default()
        }
    }
    #[doc = "`CreatedPermissionRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"actions\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"principal_id\","]
    #[doc = "    \"principal_type\","]
    #[doc = "    \"target_id\","]
    #[doc = "    \"target_type\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"actions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"target_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatedPermissionRow {
        pub actions: ::std::vec::Vec<::std::string::String>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub principal_id: ::uuid::Uuid,
        pub principal_type: ::std::string::String,
        pub target_id: ::uuid::Uuid,
        pub target_type: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl CreatedPermissionRow {
        pub fn builder() -> builder::CreatedPermissionRow {
            Default::default()
        }
    }
    #[doc = "CVE history entry for tracking vulnerability timeline."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"CVE history entry for tracking vulnerability timeline.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"cve_id\","]
    #[doc = "    \"first_detected_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"last_detected_at\","]
    #[doc = "    \"status\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"acknowledged_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"acknowledged_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"acknowledged_reason\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"affected_component\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"affected_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"component_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"cve_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"cve_published_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"cvss_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"first_detected_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"fixed_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"last_detected_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"sbom_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"scan_result_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CveHistoryEntry {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub acknowledged_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub acknowledged_by: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub acknowledged_reason: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub affected_component: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub affected_version: ::std::option::Option<::std::string::String>,
        pub artifact_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub component_id: ::std::option::Option<::uuid::Uuid>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub cve_id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cve_published_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cvss_score: ::std::option::Option<f64>,
        pub first_detected_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub fixed_version: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub last_detected_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sbom_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scan_result_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub severity: ::std::option::Option<::std::string::String>,
        pub status: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl CveHistoryEntry {
        pub fn builder() -> builder::CveHistoryEntry {
            Default::default()
        }
    }
    #[doc = "CVE status for tracking."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"CVE status for tracking.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"open\","]
    #[doc = "    \"fixed\","]
    #[doc = "    \"acknowledged\","]
    #[doc = "    \"false_positive\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CveStatus {
        #[serde(rename = "open")]
        Open,
        #[serde(rename = "fixed")]
        Fixed,
        #[serde(rename = "acknowledged")]
        Acknowledged,
        #[serde(rename = "false_positive")]
        FalsePositive,
    }
    impl ::std::fmt::Display for CveStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Open => f.write_str("open"),
                Self::Fixed => f.write_str("fixed"),
                Self::Acknowledged => f.write_str("acknowledged"),
                Self::FalsePositive => f.write_str("false_positive"),
            }
        }
    }
    impl ::std::str::FromStr for CveStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "open" => Ok(Self::Open),
                "fixed" => Ok(Self::Fixed),
                "acknowledged" => Ok(Self::Acknowledged),
                "false_positive" => Ok(Self::FalsePositive),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CveStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CveStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CveStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "CVE timeline entry for trending."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"CVE timeline entry for trending.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"affected_component\","]
    #[doc = "    \"cve_id\","]
    #[doc = "    \"days_exposed\","]
    #[doc = "    \"first_detected_at\","]
    #[doc = "    \"severity\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"affected_component\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"cve_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"cve_published_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"days_exposed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"first_detected_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CveStatus\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CveTimelineEntry {
        pub affected_component: ::std::string::String,
        pub cve_id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cve_published_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub days_exposed: i64,
        pub first_detected_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub severity: ::std::string::String,
        pub status: CveStatus,
    }
    impl CveTimelineEntry {
        pub fn builder() -> builder::CveTimelineEntry {
            Default::default()
        }
    }
    #[doc = "CVE trends summary."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"CVE trends summary.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"acknowledged_cves\","]
    #[doc = "    \"critical_count\","]
    #[doc = "    \"fixed_cves\","]
    #[doc = "    \"high_count\","]
    #[doc = "    \"low_count\","]
    #[doc = "    \"medium_count\","]
    #[doc = "    \"open_cves\","]
    #[doc = "    \"timeline\","]
    #[doc = "    \"total_cves\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"acknowledged_cves\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"avg_days_to_fix\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"critical_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"fixed_cves\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"high_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"low_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"medium_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"open_cves\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"timeline\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/CveTimelineEntry\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total_cves\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CveTrends {
        pub acknowledged_cves: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub avg_days_to_fix: ::std::option::Option<f64>,
        pub critical_count: i64,
        pub fixed_cves: i64,
        pub high_count: i64,
        pub low_count: i64,
        pub medium_count: i64,
        pub open_cves: i64,
        pub timeline: ::std::vec::Vec<CveTimelineEntry>,
        pub total_cves: i64,
    }
    impl CveTrends {
        pub fn builder() -> builder::CveTrends {
            Default::default()
        }
    }
    #[doc = "`DashboardResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"critical_findings\","]
    #[doc = "    \"high_findings\","]
    #[doc = "    \"policy_violations_blocked\","]
    #[doc = "    \"repos_grade_a\","]
    #[doc = "    \"repos_grade_f\","]
    #[doc = "    \"repos_with_scanning\","]
    #[doc = "    \"total_findings\","]
    #[doc = "    \"total_scans\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"critical_findings\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"high_findings\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policy_violations_blocked\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_a\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_f\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_with_scanning\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_findings\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_scans\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DashboardResponse {
        pub critical_findings: i64,
        pub high_findings: i64,
        pub policy_violations_blocked: i64,
        pub repos_grade_a: i64,
        pub repos_grade_f: i64,
        pub repos_with_scanning: i64,
        pub total_findings: i64,
        pub total_scans: i64,
    }
    impl DashboardResponse {
        pub fn builder() -> builder::DashboardResponse {
            Default::default()
        }
    }
    #[doc = "`DateRangeQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"from\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"to\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DateRangeQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for DateRangeQuery {
        fn default() -> Self {
            Self {
                from: Default::default(),
                to: Default::default(),
            }
        }
    }
    impl DateRangeQuery {
        pub fn builder() -> builder::DateRangeQuery {
            Default::default()
        }
    }
    #[doc = "Database connection pool statistics."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Database connection pool statistics.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"active_connections\","]
    #[doc = "    \"idle_connections\","]
    #[doc = "    \"max_connections\","]
    #[doc = "    \"size\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"active_connections\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"idle_connections\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"max_connections\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"size\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DbPoolStats {
        pub active_connections: i32,
        pub idle_connections: i32,
        pub max_connections: i32,
        pub size: i32,
    }
    impl DbPoolStats {
        pub fn builder() -> builder::DbPoolStats {
            Default::default()
        }
    }
    #[doc = "`DeliveryListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/DeliveryResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeliveryListResponse {
        pub items: ::std::vec::Vec<DeliveryResponse>,
        pub total: i64,
    }
    impl DeliveryListResponse {
        pub fn builder() -> builder::DeliveryListResponse {
            Default::default()
        }
    }
    #[doc = "`DeliveryResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"attempts\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"event\","]
    #[doc = "    \"id\","]
    #[doc = "    \"payload\","]
    #[doc = "    \"success\","]
    #[doc = "    \"webhook_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"attempts\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"delivered_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"event\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"payload\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"response_body\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"response_status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"webhook_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeliveryResponse {
        pub attempts: i32,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub delivered_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub event: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub payload: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response_body: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response_status: ::std::option::Option<i32>,
        pub success: bool,
        pub webhook_id: ::uuid::Uuid,
    }
    impl DeliveryResponse {
        pub fn builder() -> builder::DeliveryResponse {
            Default::default()
        }
    }
    #[doc = "`DiscoverablePeerResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"endpoint_url\","]
    #[doc = "    \"name\","]
    #[doc = "    \"peer_id\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"endpoint_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"region\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DiscoverablePeerResponse {
        pub endpoint_url: ::std::string::String,
        pub name: ::std::string::String,
        pub peer_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
        pub status: ::std::string::String,
    }
    impl DiscoverablePeerResponse {
        pub fn builder() -> builder::DiscoverablePeerResponse {
            Default::default()
        }
    }
    #[doc = "Download trend data point."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Download trend data point.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"date\","]
    #[doc = "    \"download_count\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"date\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DownloadTrend {
        pub date: ::chrono::naive::NaiveDate,
        pub download_count: i64,
    }
    impl DownloadTrend {
        pub fn builder() -> builder::DownloadTrend {
            Default::default()
        }
    }
    #[doc = "Analysis state for a finding"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Analysis state for a finding\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"isSuppressed\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"isSuppressed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"justification\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"response\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"state\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtAnalysis {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<::std::string::String>,
        #[serde(rename = "isSuppressed")]
        pub is_suppressed: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub justification: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<::std::string::String>,
    }
    impl DtAnalysis {
        pub fn builder() -> builder::DtAnalysis {
            Default::default()
        }
    }
    #[doc = "Response from analysis update"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Response from analysis update\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"analysisState\","]
    #[doc = "    \"isSuppressed\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"analysisDetails\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"analysisJustification\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"analysisState\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"isSuppressed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtAnalysisResponse {
        #[serde(
            rename = "analysisDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub analysis_details: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "analysisJustification",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub analysis_justification: ::std::option::Option<::std::string::String>,
        #[serde(rename = "analysisState")]
        pub analysis_state: ::std::string::String,
        #[serde(rename = "isSuppressed")]
        pub is_suppressed: bool,
    }
    impl DtAnalysisResponse {
        pub fn builder() -> builder::DtAnalysisResponse {
            Default::default()
        }
    }
    #[doc = "Attribution info"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Attribution info\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"analyzerIdentity\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"attributedOn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtAttribution {
        #[serde(
            rename = "analyzerIdentity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub analyzer_identity: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "attributedOn",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub attributed_on: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for DtAttribution {
        fn default() -> Self {
            Self {
                analyzer_identity: Default::default(),
                attributed_on: Default::default(),
            }
        }
    }
    impl DtAttribution {
        pub fn builder() -> builder::DtAttribution {
            Default::default()
        }
    }
    #[doc = "Component affected by a vulnerability"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Component affected by a vulnerability\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"uuid\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"group\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"purl\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtComponent {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub purl: ::std::option::Option<::std::string::String>,
        pub uuid: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl DtComponent {
        pub fn builder() -> builder::DtComponent {
            Default::default()
        }
    }
    #[doc = "Full component representation from Dependency-Track"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Full component representation from Dependency-Track\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"uuid\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"cpe\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"group\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"isInternal\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"purl\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"resolvedLicense\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtLicense\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtComponentFull {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cpe: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "isInternal",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_internal: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub purl: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "resolvedLicense",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub resolved_license: ::std::option::Option<DtLicense>,
        pub uuid: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl DtComponentFull {
        pub fn builder() -> builder::DtComponentFull {
            Default::default()
        }
    }
    #[doc = "CWE reference"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"CWE reference\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"cweId\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"cweId\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtCwe {
        #[serde(rename = "cweId")]
        pub cwe_id: i32,
        pub name: ::std::string::String,
    }
    impl DtCwe {
        pub fn builder() -> builder::DtCwe {
            Default::default()
        }
    }
    #[doc = "Vulnerability finding from Dependency-Track"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Vulnerability finding from Dependency-Track\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"component\","]
    #[doc = "    \"vulnerability\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"analysis\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtAnalysis\""]
    #[doc = "    },"]
    #[doc = "    \"attribution\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtAttribution\""]
    #[doc = "    },"]
    #[doc = "    \"component\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtComponent\""]
    #[doc = "    },"]
    #[doc = "    \"vulnerability\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtVulnerability\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtFinding {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub analysis: ::std::option::Option<DtAnalysis>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attribution: ::std::option::Option<DtAttribution>,
        pub component: DtComponent,
        pub vulnerability: DtVulnerability,
    }
    impl DtFinding {
        pub fn builder() -> builder::DtFinding {
            Default::default()
        }
    }
    #[doc = "License information from Dependency-Track"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"License information from Dependency-Track\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"licenseId\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtLicense {
        #[serde(
            rename = "licenseId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub license_id: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uuid: ::std::option::Option<::std::string::String>,
    }
    impl DtLicense {
        pub fn builder() -> builder::DtLicense {
            Default::default()
        }
    }
    #[doc = "Policy definition"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Policy definition\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"uuid\","]
    #[doc = "    \"violationState\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"violationState\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtPolicy {
        pub name: ::std::string::String,
        pub uuid: ::std::string::String,
        #[serde(rename = "violationState")]
        pub violation_state: ::std::string::String,
    }
    impl DtPolicy {
        pub fn builder() -> builder::DtPolicy {
            Default::default()
        }
    }
    #[doc = "Policy condition that was violated"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Policy condition that was violated\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"operator\","]
    #[doc = "    \"policy\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"uuid\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"policy\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtPolicy\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtPolicyCondition {
        pub operator: ::std::string::String,
        pub policy: DtPolicy,
        pub subject: ::std::string::String,
        pub uuid: ::std::string::String,
        pub value: ::std::string::String,
    }
    impl DtPolicyCondition {
        pub fn builder() -> builder::DtPolicyCondition {
            Default::default()
        }
    }
    #[doc = "Full policy condition with all fields"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Full policy condition with all fields\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"operator\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"uuid\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtPolicyConditionFull {
        pub operator: ::std::string::String,
        pub subject: ::std::string::String,
        pub uuid: ::std::string::String,
        pub value: ::std::string::String,
    }
    impl DtPolicyConditionFull {
        pub fn builder() -> builder::DtPolicyConditionFull {
            Default::default()
        }
    }
    #[doc = "Full policy representation with conditions and projects"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Full policy representation with conditions and projects\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"policyConditions\","]
    #[doc = "    \"projects\","]
    #[doc = "    \"tags\","]
    #[doc = "    \"uuid\","]
    #[doc = "    \"violationState\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"includeChildren\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"policyConditions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/DtPolicyConditionFull\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"projects\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/DtProject\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"tags\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"violationState\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtPolicyFull {
        #[serde(
            rename = "includeChildren",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub include_children: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(rename = "policyConditions")]
        pub policy_conditions: ::std::vec::Vec<DtPolicyConditionFull>,
        pub projects: ::std::vec::Vec<DtProject>,
        pub tags: ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub uuid: ::std::string::String,
        #[serde(rename = "violationState")]
        pub violation_state: ::std::string::String,
    }
    impl DtPolicyFull {
        pub fn builder() -> builder::DtPolicyFull {
            Default::default()
        }
    }
    #[doc = "Policy violation from Dependency-Track"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Policy violation from Dependency-Track\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"component\","]
    #[doc = "    \"policyCondition\","]
    #[doc = "    \"type\","]
    #[doc = "    \"uuid\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"component\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtComponent\""]
    #[doc = "    },"]
    #[doc = "    \"policyCondition\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtPolicyCondition\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtPolicyViolation {
        pub component: DtComponent,
        #[serde(rename = "policyCondition")]
        pub policy_condition: DtPolicyCondition,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
        pub uuid: ::std::string::String,
    }
    impl DtPolicyViolation {
        pub fn builder() -> builder::DtPolicyViolation {
            Default::default()
        }
    }
    #[doc = "Portfolio-level metrics from Dependency-Track"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Portfolio-level metrics from Dependency-Track\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"critical\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"findingsAudited\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"findingsTotal\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"findingsUnaudited\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"high\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"inheritedRiskScore\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"low\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"medium\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsFail\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsInfo\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsTotal\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsWarn\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"projects\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"suppressions\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"unassigned\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"vulnerabilities\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtPortfolioMetrics {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub critical: ::std::option::Option<i64>,
        #[serde(
            rename = "findingsAudited",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub findings_audited: ::std::option::Option<i64>,
        #[serde(
            rename = "findingsTotal",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub findings_total: ::std::option::Option<i64>,
        #[serde(
            rename = "findingsUnaudited",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub findings_unaudited: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub high: ::std::option::Option<i64>,
        #[serde(
            rename = "inheritedRiskScore",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub inherited_risk_score: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub low: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub medium: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsFail",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_fail: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsInfo",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_info: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsTotal",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_total: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsWarn",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_warn: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub projects: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressions: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unassigned: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vulnerabilities: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for DtPortfolioMetrics {
        fn default() -> Self {
            Self {
                critical: Default::default(),
                findings_audited: Default::default(),
                findings_total: Default::default(),
                findings_unaudited: Default::default(),
                high: Default::default(),
                inherited_risk_score: Default::default(),
                low: Default::default(),
                medium: Default::default(),
                policy_violations_fail: Default::default(),
                policy_violations_info: Default::default(),
                policy_violations_total: Default::default(),
                policy_violations_warn: Default::default(),
                projects: Default::default(),
                suppressions: Default::default(),
                unassigned: Default::default(),
                vulnerabilities: Default::default(),
            }
        }
    }
    impl DtPortfolioMetrics {
        pub fn builder() -> builder::DtPortfolioMetrics {
            Default::default()
        }
    }
    #[doc = "Dependency-Track project representation"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Dependency-Track project representation\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"uuid\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"lastBomImport\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"lastBomImportFormat\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtProject {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "lastBomImport",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub last_bom_import: ::std::option::Option<i64>,
        #[serde(
            rename = "lastBomImportFormat",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub last_bom_import_format: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        pub uuid: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl DtProject {
        pub fn builder() -> builder::DtProject {
            Default::default()
        }
    }
    #[doc = "Project-level metrics from Dependency-Track"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Project-level metrics from Dependency-Track\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"critical\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"findingsAudited\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"findingsTotal\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"findingsUnaudited\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"firstOccurrence\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"high\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"inheritedRiskScore\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"lastOccurrence\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"low\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"medium\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsFail\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsInfo\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsTotal\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"policyViolationsWarn\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"suppressions\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"unassigned\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"vulnerabilities\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtProjectMetrics {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub critical: ::std::option::Option<i64>,
        #[serde(
            rename = "findingsAudited",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub findings_audited: ::std::option::Option<i64>,
        #[serde(
            rename = "findingsTotal",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub findings_total: ::std::option::Option<i64>,
        #[serde(
            rename = "findingsUnaudited",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub findings_unaudited: ::std::option::Option<i64>,
        #[serde(
            rename = "firstOccurrence",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub first_occurrence: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub high: ::std::option::Option<i64>,
        #[serde(
            rename = "inheritedRiskScore",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub inherited_risk_score: ::std::option::Option<f64>,
        #[serde(
            rename = "lastOccurrence",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub last_occurrence: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub low: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub medium: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsFail",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_fail: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsInfo",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_info: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsTotal",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_total: ::std::option::Option<i64>,
        #[serde(
            rename = "policyViolationsWarn",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub policy_violations_warn: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressions: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unassigned: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vulnerabilities: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for DtProjectMetrics {
        fn default() -> Self {
            Self {
                critical: Default::default(),
                findings_audited: Default::default(),
                findings_total: Default::default(),
                findings_unaudited: Default::default(),
                first_occurrence: Default::default(),
                high: Default::default(),
                inherited_risk_score: Default::default(),
                last_occurrence: Default::default(),
                low: Default::default(),
                medium: Default::default(),
                policy_violations_fail: Default::default(),
                policy_violations_info: Default::default(),
                policy_violations_total: Default::default(),
                policy_violations_warn: Default::default(),
                suppressions: Default::default(),
                unassigned: Default::default(),
                vulnerabilities: Default::default(),
            }
        }
    }
    impl DtProjectMetrics {
        pub fn builder() -> builder::DtProjectMetrics {
            Default::default()
        }
    }
    #[doc = "`DtStatusResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"enabled\","]
    #[doc = "    \"healthy\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"healthy\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtStatusResponse {
        pub enabled: bool,
        pub healthy: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
    }
    impl DtStatusResponse {
        pub fn builder() -> builder::DtStatusResponse {
            Default::default()
        }
    }
    #[doc = "Vulnerability details"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Vulnerability details\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"severity\","]
    #[doc = "    \"source\","]
    #[doc = "    \"uuid\","]
    #[doc = "    \"vulnId\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"cvssV3BaseScore\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"cwe\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DtCwe\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"title\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"vulnId\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DtVulnerability {
        #[serde(
            rename = "cvssV3BaseScore",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cvss_v3_base_score: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cwe: ::std::option::Option<DtCwe>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub severity: ::std::string::String,
        pub source: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
        pub uuid: ::std::string::String,
        #[serde(rename = "vulnId")]
        pub vuln_id: ::std::string::String,
    }
    impl DtVulnerability {
        pub fn builder() -> builder::DtVulnerability {
            Default::default()
        }
    }
    #[doc = "Standard error response body returned by all endpoints on failure."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Standard error response body returned by all endpoints on failure.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"description\": \"Machine-readable error code (e.g. \\\"NOT_FOUND\\\", \\\"VALIDATION_ERROR\\\")\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"description\": \"Human-readable error message\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ErrorResponse {
        #[doc = "Machine-readable error code (e.g. \"NOT_FOUND\", \"VALIDATION_ERROR\")"]
        pub code: ::std::string::String,
        #[doc = "Human-readable error message"]
        pub message: ::std::string::String,
    }
    impl ErrorResponse {
        pub fn builder() -> builder::ErrorResponse {
            Default::default()
        }
    }
    #[doc = "`EvaluationResultResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created\","]
    #[doc = "    \"policies_evaluated\","]
    #[doc = "    \"removed\","]
    #[doc = "    \"updated\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"policies_evaluated\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"removed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"updated\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EvaluationResultResponse {
        pub created: u64,
        pub policies_evaluated: u64,
        pub removed: u64,
        pub updated: u64,
    }
    impl EvaluationResultResponse {
        pub fn builder() -> builder::EvaluationResultResponse {
            Default::default()
        }
    }
    #[doc = "`EventsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"limit\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EventsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for EventsQuery {
        fn default() -> Self {
            Self {
                limit: Default::default(),
            }
        }
    }
    impl EventsQuery {
        pub fn builder() -> builder::EventsQuery {
            Default::default()
        }
    }
    #[doc = "`ExchangeCodeRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExchangeCodeRequest {
        pub code: ::std::string::String,
    }
    impl ExchangeCodeRequest {
        pub fn builder() -> builder::ExchangeCodeRequest {
            Default::default()
        }
    }
    #[doc = "`ExchangeCodeResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"access_token\","]
    #[doc = "    \"refresh_token\","]
    #[doc = "    \"token_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"access_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"token_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExchangeCodeResponse {
        pub access_token: ::std::string::String,
        pub refresh_token: ::std::string::String,
        pub token_type: ::std::string::String,
    }
    impl ExchangeCodeResponse {
        pub fn builder() -> builder::ExchangeCodeResponse {
            Default::default()
        }
    }
    #[doc = "`FacetValue`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"count\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FacetValue {
        pub count: i64,
        pub value: ::std::string::String,
    }
    impl FacetValue {
        pub fn builder() -> builder::FacetValue {
            Default::default()
        }
    }
    #[doc = "`FacetsResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"content_types\","]
    #[doc = "    \"formats\","]
    #[doc = "    \"repositories\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"content_types\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/FacetValue\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"formats\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/FacetValue\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"repositories\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/FacetValue\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FacetsResponse {
        pub content_types: ::std::vec::Vec<FacetValue>,
        pub formats: ::std::vec::Vec<FacetValue>,
        pub repositories: ::std::vec::Vec<FacetValue>,
    }
    impl FacetsResponse {
        pub fn builder() -> builder::FacetsResponse {
            Default::default()
        }
    }
    #[doc = "`FailBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FailBody {
        pub error: ::std::string::String,
    }
    impl FailBody {
        pub fn builder() -> builder::FailBody {
            Default::default()
        }
    }
    #[doc = "`FindingListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/FindingResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FindingListResponse {
        pub items: ::std::vec::Vec<FindingResponse>,
        pub total: i64,
    }
    impl FindingListResponse {
        pub fn builder() -> builder::FindingListResponse {
            Default::default()
        }
    }
    #[doc = "`FindingResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_acknowledged\","]
    #[doc = "    \"scan_result_id\","]
    #[doc = "    \"severity\","]
    #[doc = "    \"title\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"acknowledged_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"acknowledged_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"acknowledged_reason\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"affected_component\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"affected_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"cve_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"fixed_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_acknowledged\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scan_result_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"source_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"title\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FindingResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub acknowledged_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub acknowledged_by: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub acknowledged_reason: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub affected_component: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub affected_version: ::std::option::Option<::std::string::String>,
        pub artifact_id: ::uuid::Uuid,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cve_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub fixed_version: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub is_acknowledged: bool,
        pub scan_result_id: ::uuid::Uuid,
        pub severity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_url: ::std::option::Option<::std::string::String>,
        pub title: ::std::string::String,
    }
    impl FindingResponse {
        pub fn builder() -> builder::FindingResponse {
            Default::default()
        }
    }
    #[doc = "Format handler response with additional computed fields."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Format handler response with additional computed fields.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"display_name\","]
    #[doc = "    \"extensions\","]
    #[doc = "    \"format_key\","]
    #[doc = "    \"handler_type\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"priority\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"capabilities\": {"]
    #[doc = "      \"description\": \"Plugin capabilities if this is a WASM handler\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"extensions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"format_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"handler_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/FormatHandlerType\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"plugin_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"repository_count\": {"]
    #[doc = "      \"description\": \"Number of repositories using this format (computed)\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FormatHandlerResponse {
        #[doc = "Plugin capabilities if this is a WASM handler"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub capabilities:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub display_name: ::std::string::String,
        pub extensions: ::std::vec::Vec<::std::string::String>,
        pub format_key: ::std::string::String,
        pub handler_type: FormatHandlerType,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub plugin_id: ::std::option::Option<::uuid::Uuid>,
        pub priority: i32,
        #[doc = "Number of repositories using this format (computed)"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_count: ::std::option::Option<i64>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl FormatHandlerResponse {
        pub fn builder() -> builder::FormatHandlerResponse {
            Default::default()
        }
    }
    #[doc = "Format handler type enum.\n\nIndicates whether the handler is compiled-in (core) or loaded from WASM."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Format handler type enum.\\n\\nIndicates whether the handler is compiled-in (core) or loaded from WASM.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"Core\","]
    #[doc = "    \"Wasm\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum FormatHandlerType {
        Core,
        Wasm,
    }
    impl ::std::fmt::Display for FormatHandlerType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Core => f.write_str("Core"),
                Self::Wasm => f.write_str("Wasm"),
            }
        }
    }
    impl ::std::str::FromStr for FormatHandlerType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Core" => Ok(Self::Core),
                "Wasm" => Ok(Self::Wasm),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for FormatHandlerType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for FormatHandlerType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for FormatHandlerType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GateEvaluationResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"action\","]
    #[doc = "    \"component_scores\","]
    #[doc = "    \"gate_name\","]
    #[doc = "    \"health_grade\","]
    #[doc = "    \"health_score\","]
    #[doc = "    \"passed\","]
    #[doc = "    \"violations\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"component_scores\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"gate_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"health_grade\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"health_score\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"passed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"violations\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/GateViolationResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GateEvaluationResponse {
        pub action: ::std::string::String,
        pub component_scores: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub gate_name: ::std::string::String,
        pub health_grade: ::std::string::String,
        pub health_score: i32,
        pub passed: bool,
        pub violations: ::std::vec::Vec<GateViolationResponse>,
    }
    impl GateEvaluationResponse {
        pub fn builder() -> builder::GateEvaluationResponse {
            Default::default()
        }
    }
    #[doc = "`GateResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"action\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"enforce_on_download\","]
    #[doc = "    \"enforce_on_promotion\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"name\","]
    #[doc = "    \"required_checks\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"enforce_on_download\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"enforce_on_promotion\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_critical_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_high_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_medium_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_health_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_metadata_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_quality_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_security_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"required_checks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GateResponse {
        pub action: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub enforce_on_download: bool,
        pub enforce_on_promotion: bool,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_critical_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_high_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_medium_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_health_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_metadata_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_quality_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_security_score: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        pub required_checks: ::std::vec::Vec<::std::string::String>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl GateResponse {
        pub fn builder() -> builder::GateResponse {
            Default::default()
        }
    }
    #[doc = "`GateViolationResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"actual\","]
    #[doc = "    \"expected\","]
    #[doc = "    \"message\","]
    #[doc = "    \"rule\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"actual\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"expected\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"rule\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GateViolationResponse {
        pub actual: ::std::string::String,
        pub expected: ::std::string::String,
        pub message: ::std::string::String,
        pub rule: ::std::string::String,
    }
    impl GateViolationResponse {
        pub fn builder() -> builder::GateViolationResponse {
            Default::default()
        }
    }
    #[doc = "`GenerateSbomRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"force_regenerate\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GenerateSbomRequest {
        pub artifact_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub force_regenerate: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub format: ::std::option::Option<::std::string::String>,
    }
    impl GenerateSbomRequest {
        pub fn builder() -> builder::GenerateSbomRequest {
            Default::default()
        }
    }
    #[doc = "`GetCveTrendsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetCveTrendsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub days: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for GetCveTrendsQuery {
        fn default() -> Self {
            Self {
                days: Default::default(),
                repository_id: Default::default(),
            }
        }
    }
    impl GetCveTrendsQuery {
        pub fn builder() -> builder::GetCveTrendsQuery {
            Default::default()
        }
    }
    #[doc = "`GroupListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/GroupResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GroupListResponse {
        pub items: ::std::vec::Vec<GroupResponse>,
        pub pagination: Pagination,
    }
    impl GroupListResponse {
        pub fn builder() -> builder::GroupListResponse {
            Default::default()
        }
    }
    #[doc = "`GroupResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"member_count\","]
    #[doc = "    \"name\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"member_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GroupResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub member_count: i64,
        pub name: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl GroupResponse {
        pub fn builder() -> builder::GroupResponse {
            Default::default()
        }
    }
    #[doc = "`GroupRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"member_count\","]
    #[doc = "    \"name\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"member_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GroupRow {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub member_count: i64,
        pub name: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl GroupRow {
        pub fn builder() -> builder::GroupRow {
            Default::default()
        }
    }
    #[doc = "Growth summary for a time range."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Growth summary for a time range.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_added\","]
    #[doc = "    \"artifacts_end\","]
    #[doc = "    \"artifacts_start\","]
    #[doc = "    \"downloads_in_period\","]
    #[doc = "    \"period_end\","]
    #[doc = "    \"period_start\","]
    #[doc = "    \"storage_bytes_end\","]
    #[doc = "    \"storage_bytes_start\","]
    #[doc = "    \"storage_growth_bytes\","]
    #[doc = "    \"storage_growth_percent\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_added\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"artifacts_end\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"artifacts_start\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"downloads_in_period\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"period_end\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date\""]
    #[doc = "    },"]
    #[doc = "    \"period_start\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date\""]
    #[doc = "    },"]
    #[doc = "    \"storage_bytes_end\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"storage_bytes_start\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"storage_growth_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"storage_growth_percent\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GrowthSummary {
        pub artifacts_added: i64,
        pub artifacts_end: i64,
        pub artifacts_start: i64,
        pub downloads_in_period: i64,
        pub period_end: ::chrono::naive::NaiveDate,
        pub period_start: ::chrono::naive::NaiveDate,
        pub storage_bytes_end: i64,
        pub storage_bytes_start: i64,
        pub storage_growth_bytes: i64,
        pub storage_growth_percent: f64,
    }
    impl GrowthSummary {
        pub fn builder() -> builder::GrowthSummary {
            Default::default()
        }
    }
    #[doc = "`HealthChecks`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"database\","]
    #[doc = "    \"storage\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"database\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    },"]
    #[doc = "    \"meilisearch\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    },"]
    #[doc = "    \"security_scanner\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    },"]
    #[doc = "    \"storage\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HealthChecks {
        pub database: CheckStatus,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub meilisearch: ::std::option::Option<CheckStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub security_scanner: ::std::option::Option<CheckStatus>,
        pub storage: CheckStatus,
    }
    impl HealthChecks {
        pub fn builder() -> builder::HealthChecks {
            Default::default()
        }
    }
    #[doc = "`HealthDashboardResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"avg_health_score\","]
    #[doc = "    \"repos_grade_a\","]
    #[doc = "    \"repos_grade_b\","]
    #[doc = "    \"repos_grade_c\","]
    #[doc = "    \"repos_grade_d\","]
    #[doc = "    \"repos_grade_f\","]
    #[doc = "    \"repositories\","]
    #[doc = "    \"total_artifacts_evaluated\","]
    #[doc = "    \"total_repositories\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"avg_health_score\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_a\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_b\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_c\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_d\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repos_grade_f\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repositories\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/RepoHealthResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total_artifacts_evaluated\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_repositories\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HealthDashboardResponse {
        pub avg_health_score: i32,
        pub repos_grade_a: i64,
        pub repos_grade_b: i64,
        pub repos_grade_c: i64,
        pub repos_grade_d: i64,
        pub repos_grade_f: i64,
        pub repositories: ::std::vec::Vec<RepoHealthResponse>,
        pub total_artifacts_evaluated: i64,
        pub total_repositories: i64,
    }
    impl HealthDashboardResponse {
        pub fn builder() -> builder::HealthDashboardResponse {
            Default::default()
        }
    }
    #[doc = "`HealthResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checks\","]
    #[doc = "    \"demo_mode\","]
    #[doc = "    \"status\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checks\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HealthChecks\""]
    #[doc = "    },"]
    #[doc = "    \"db_pool\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/DbPoolStats\""]
    #[doc = "    },"]
    #[doc = "    \"demo_mode\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HealthResponse {
        pub checks: HealthChecks,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub db_pool: ::std::option::Option<DbPoolStats>,
        pub demo_mode: bool,
        pub status: ::std::string::String,
        pub version: ::std::string::String,
    }
    impl HealthResponse {
        pub fn builder() -> builder::HealthResponse {
            Default::default()
        }
    }
    #[doc = "`HeartbeatRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"cache_used_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"cache_used_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HeartbeatRequest {
        pub cache_used_bytes: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
    }
    impl HeartbeatRequest {
        pub fn builder() -> builder::HeartbeatRequest {
            Default::default()
        }
    }
    #[doc = "`IdentityResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"api_key\","]
    #[doc = "    \"endpoint_url\","]
    #[doc = "    \"name\","]
    #[doc = "    \"peer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"api_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"endpoint_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IdentityResponse {
        pub api_key: ::std::string::String,
        pub endpoint_url: ::std::string::String,
        pub name: ::std::string::String,
        pub peer_id: ::uuid::Uuid,
    }
    impl IdentityResponse {
        pub fn builder() -> builder::IdentityResponse {
            Default::default()
        }
    }
    #[doc = "`InitTransferBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"chunk_size\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitTransferBody {
        pub artifact_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chunk_size: ::std::option::Option<i32>,
    }
    impl InitTransferBody {
        pub fn builder() -> builder::InitTransferBody {
            Default::default()
        }
    }
    #[doc = "Request to install a plugin from Git"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Request to install a plugin from Git\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"ref\": {"]
    #[doc = "      \"description\": \"Git ref (tag, branch, or commit)\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"description\": \"Git repository URL\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstallFromGitRequest {
        #[doc = "Git ref (tag, branch, or commit)"]
        #[serde(
            rename = "ref",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub ref_: ::std::option::Option<::std::string::String>,
        #[doc = "Git repository URL"]
        pub url: ::std::string::String,
    }
    impl InstallFromGitRequest {
        pub fn builder() -> builder::InstallFromGitRequest {
            Default::default()
        }
    }
    #[doc = "Request for installing from local file path"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Request for installing from local file path\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"path\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"description\": \"Local filesystem path to plugin directory\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstallFromLocalRequest {
        #[doc = "Local filesystem path to plugin directory"]
        pub path: ::std::string::String,
    }
    impl InstallFromLocalRequest {
        pub fn builder() -> builder::InstallFromLocalRequest {
            Default::default()
        }
    }
    #[doc = "`IssueResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"category\","]
    #[doc = "    \"check_result_id\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_suppressed\","]
    #[doc = "    \"severity\","]
    #[doc = "    \"title\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"category\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"check_result_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_suppressed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"location\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"suppressed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"suppressed_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"suppressed_reason\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"title\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IssueResponse {
        pub artifact_id: ::uuid::Uuid,
        pub category: ::std::string::String,
        pub check_result_id: ::uuid::Uuid,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub is_suppressed: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub location: ::std::option::Option<::std::string::String>,
        pub severity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressed_by: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressed_reason: ::std::option::Option<::std::string::String>,
        pub title: ::std::string::String,
    }
    impl IssueResponse {
        pub fn builder() -> builder::IssueResponse {
            Default::default()
        }
    }
    #[doc = "`KeyListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"keys\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"keys\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/SigningKeyPublic\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KeyListResponse {
        pub keys: ::std::vec::Vec<SigningKeyPublic>,
        pub total: u64,
    }
    impl KeyListResponse {
        pub fn builder() -> builder::KeyListResponse {
            Default::default()
        }
    }
    #[doc = "`LabelEntrySchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LabelEntrySchema {
        pub key: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }
    impl LabelEntrySchema {
        pub fn builder() -> builder::LabelEntrySchema {
            Default::default()
        }
    }
    #[doc = "`LabelResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"key\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LabelResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub key: ::std::string::String,
        pub repository_id: ::uuid::Uuid,
        pub value: ::std::string::String,
    }
    impl LabelResponse {
        pub fn builder() -> builder::LabelResponse {
            Default::default()
        }
    }
    #[doc = "`LabelsListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/LabelResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LabelsListResponse {
        pub items: ::std::vec::Vec<LabelResponse>,
        pub total: u64,
    }
    impl LabelsListResponse {
        pub fn builder() -> builder::LabelsListResponse {
            Default::default()
        }
    }
    #[doc = "`LdapConfigResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"display_name_attribute\","]
    #[doc = "    \"email_attribute\","]
    #[doc = "    \"groups_attribute\","]
    #[doc = "    \"has_bind_password\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"name\","]
    #[doc = "    \"priority\","]
    #[doc = "    \"server_url\","]
    #[doc = "    \"updated_at\","]
    #[doc = "    \"use_starttls\","]
    #[doc = "    \"user_base_dn\","]
    #[doc = "    \"user_filter\","]
    #[doc = "    \"username_attribute\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"admin_group_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"bind_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"display_name_attribute\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"email_attribute\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"group_base_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"group_filter\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"groups_attribute\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"has_bind_password\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"server_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"use_starttls\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"user_base_dn\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"user_filter\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"username_attribute\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LdapConfigResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bind_dn: ::std::option::Option<::std::string::String>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub display_name_attribute: ::std::string::String,
        pub email_attribute: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_base_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_filter: ::std::option::Option<::std::string::String>,
        pub groups_attribute: ::std::string::String,
        pub has_bind_password: bool,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        pub name: ::std::string::String,
        pub priority: i32,
        pub server_url: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub use_starttls: bool,
        pub user_base_dn: ::std::string::String,
        pub user_filter: ::std::string::String,
        pub username_attribute: ::std::string::String,
    }
    impl LdapConfigResponse {
        pub fn builder() -> builder::LdapConfigResponse {
            Default::default()
        }
    }
    #[doc = "`LdapLoginRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"password\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"password\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LdapLoginRequest {
        pub password: ::std::string::String,
        pub username: ::std::string::String,
    }
    impl LdapLoginRequest {
        pub fn builder() -> builder::LdapLoginRequest {
            Default::default()
        }
    }
    #[doc = "`LdapTestResult`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\","]
    #[doc = "    \"response_time_ms\","]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"response_time_ms\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LdapTestResult {
        pub message: ::std::string::String,
        pub response_time_ms: i64,
        pub success: bool,
    }
    impl LdapTestResult {
        pub fn builder() -> builder::LdapTestResult {
            Default::default()
        }
    }
    #[doc = "Result of license compliance check."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Result of license compliance check.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"compliant\","]
    #[doc = "    \"violations\","]
    #[doc = "    \"warnings\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"compliant\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"violations\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"warnings\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LicenseCheckResult {
        pub compliant: bool,
        pub violations: ::std::vec::Vec<::std::string::String>,
        pub warnings: ::std::vec::Vec<::std::string::String>,
    }
    impl LicenseCheckResult {
        pub fn builder() -> builder::LicenseCheckResult {
            Default::default()
        }
    }
    #[doc = "`LicensePolicyResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"action\","]
    #[doc = "    \"allow_unknown\","]
    #[doc = "    \"allowed_licenses\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"denied_licenses\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"allow_unknown\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"allowed_licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"denied_licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LicensePolicyResponse {
        pub action: ::std::string::String,
        pub allow_unknown: bool,
        pub allowed_licenses: ::std::vec::Vec<::std::string::String>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub denied_licenses: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl LicensePolicyResponse {
        pub fn builder() -> builder::LicensePolicyResponse {
            Default::default()
        }
    }
    #[doc = "A lifecycle policy attached to a repository (or global if repository_id is NULL)."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"A lifecycle policy attached to a repository (or global if repository_id is NULL).\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"config\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"enabled\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"policy_type\","]
    #[doc = "    \"priority\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"last_run_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"last_run_items_removed\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"policy_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LifecyclePolicy {
        pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub enabled: bool,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_run_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_run_items_removed: ::std::option::Option<i64>,
        pub name: ::std::string::String,
        pub policy_type: ::std::string::String,
        pub priority: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl LifecyclePolicy {
        pub fn builder() -> builder::LifecyclePolicy {
            Default::default()
        }
    }
    #[doc = "`ListArtifactsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"path_prefix\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"q\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListArtifactsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub path_prefix: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub q: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListArtifactsQuery {
        fn default() -> Self {
            Self {
                page: Default::default(),
                path_prefix: Default::default(),
                per_page: Default::default(),
                q: Default::default(),
            }
        }
    }
    impl ListArtifactsQuery {
        pub fn builder() -> builder::ListArtifactsQuery {
            Default::default()
        }
    }
    #[doc = "`ListBackupsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListBackupsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListBackupsQuery {
        fn default() -> Self {
            Self {
                page: Default::default(),
                per_page: Default::default(),
                status: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl ListBackupsQuery {
        pub fn builder() -> builder::ListBackupsQuery {
            Default::default()
        }
    }
    #[doc = "`ListBuildsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"search\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sort_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sort_order\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListBuildsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub search: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sort_by: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sort_order: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListBuildsQuery {
        fn default() -> Self {
            Self {
                page: Default::default(),
                per_page: Default::default(),
                search: Default::default(),
                sort_by: Default::default(),
                sort_order: Default::default(),
                status: Default::default(),
            }
        }
    }
    impl ListBuildsQuery {
        pub fn builder() -> builder::ListBuildsQuery {
            Default::default()
        }
    }
    #[doc = "`ListFormatsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListFormatsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enabled: ::std::option::Option<bool>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListFormatsQuery {
        fn default() -> Self {
            Self {
                enabled: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl ListFormatsQuery {
        pub fn builder() -> builder::ListFormatsQuery {
            Default::default()
        }
    }
    #[doc = "`ListKeysQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListKeysQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for ListKeysQuery {
        fn default() -> Self {
            Self {
                repository_id: Default::default(),
            }
        }
    }
    impl ListKeysQuery {
        pub fn builder() -> builder::ListKeysQuery {
            Default::default()
        }
    }
    #[doc = "`ListPluginsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPluginsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListPluginsQuery {
        fn default() -> Self {
            Self {
                status: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl ListPluginsQuery {
        pub fn builder() -> builder::ListPluginsQuery {
            Default::default()
        }
    }
    #[doc = "`ListRepositoriesQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"q\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListRepositoriesQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub format: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub q: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListRepositoriesQuery {
        fn default() -> Self {
            Self {
                format: Default::default(),
                page: Default::default(),
                per_page: Default::default(),
                q: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl ListRepositoriesQuery {
        pub fn builder() -> builder::ListRepositoriesQuery {
            Default::default()
        }
    }
    #[doc = "`ListSbomsQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSbomsQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub format: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for ListSbomsQuery {
        fn default() -> Self {
            Self {
                artifact_id: Default::default(),
                format: Default::default(),
                repository_id: Default::default(),
            }
        }
    }
    impl ListSbomsQuery {
        pub fn builder() -> builder::ListSbomsQuery {
            Default::default()
        }
    }
    #[doc = "`ListUsersQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"is_active\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_admin\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"search\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListUsersQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_active: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_admin: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub search: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ListUsersQuery {
        fn default() -> Self {
            Self {
                is_active: Default::default(),
                is_admin: Default::default(),
                page: Default::default(),
                per_page: Default::default(),
                search: Default::default(),
            }
        }
    }
    impl ListUsersQuery {
        pub fn builder() -> builder::ListUsersQuery {
            Default::default()
        }
    }
    #[doc = "Lightweight liveness response."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Lightweight liveness response.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LivezResponse {
        pub status: ::std::string::String,
    }
    impl LivezResponse {
        pub fn builder() -> builder::LivezResponse {
            Default::default()
        }
    }
    #[doc = "`LoginRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"password\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"password\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LoginRequest {
        pub password: ::std::string::String,
        pub username: ::std::string::String,
    }
    impl LoginRequest {
        pub fn builder() -> builder::LoginRequest {
            Default::default()
        }
    }
    #[doc = "`LoginResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"access_token\","]
    #[doc = "    \"expires_in\","]
    #[doc = "    \"must_change_password\","]
    #[doc = "    \"refresh_token\","]
    #[doc = "    \"token_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"access_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"expires_in\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"must_change_password\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"token_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"totp_required\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"totp_token\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LoginResponse {
        pub access_token: ::std::string::String,
        pub expires_in: i64,
        pub must_change_password: bool,
        pub refresh_token: ::std::string::String,
        pub token_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub totp_required: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub totp_token: ::std::option::Option<::std::string::String>,
    }
    impl LoginResponse {
        pub fn builder() -> builder::LoginResponse {
            Default::default()
        }
    }
    #[doc = "`MatchedPeerSchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"region\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MatchedPeerSchema {
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
    }
    impl MatchedPeerSchema {
        pub fn builder() -> builder::MatchedPeerSchema {
            Default::default()
        }
    }
    #[doc = "`MatchedRepoSchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"format\","]
    #[doc = "    \"id\","]
    #[doc = "    \"key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MatchedRepoSchema {
        pub format: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub key: ::std::string::String,
    }
    impl MatchedRepoSchema {
        pub fn builder() -> builder::MatchedRepoSchema {
            Default::default()
        }
    }
    #[doc = "`MembersRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"user_ids\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"user_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"format\": \"uuid\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MembersRequest {
        pub user_ids: ::std::vec::Vec<::uuid::Uuid>,
    }
    impl MembersRequest {
        pub fn builder() -> builder::MembersRequest {
            Default::default()
        }
    }
    #[doc = "`MigrationItemResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"item_type\","]
    #[doc = "    \"job_id\","]
    #[doc = "    \"retry_count\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"source_path\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_source\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"checksum_target\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"completed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"error_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"item_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"job_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"retry_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"source_path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_path\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MigrationItemResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checksum_source: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checksum_target: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub item_type: ::std::string::String,
        pub job_id: ::uuid::Uuid,
        pub retry_count: i32,
        pub size_bytes: i64,
        pub source_path: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub target_path: ::std::option::Option<::std::string::String>,
    }
    impl MigrationItemResponse {
        pub fn builder() -> builder::MigrationItemResponse {
            Default::default()
        }
    }
    #[doc = "`MigrationItemRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"item_type\","]
    #[doc = "    \"job_id\","]
    #[doc = "    \"metadata\","]
    #[doc = "    \"retry_count\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"source_path\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_source\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"checksum_target\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"completed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"error_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"item_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"job_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"retry_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"source_path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_path\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MigrationItemRow {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checksum_source: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checksum_target: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub item_type: ::std::string::String,
        pub job_id: ::uuid::Uuid,
        pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub retry_count: i32,
        pub size_bytes: i64,
        pub source_path: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub target_path: ::std::option::Option<::std::string::String>,
    }
    impl MigrationItemRow {
        pub fn builder() -> builder::MigrationItemRow {
            Default::default()
        }
    }
    #[doc = "`MigrationJobResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"completed_items\","]
    #[doc = "    \"config\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"failed_items\","]
    #[doc = "    \"id\","]
    #[doc = "    \"job_type\","]
    #[doc = "    \"progress_percent\","]
    #[doc = "    \"skipped_items\","]
    #[doc = "    \"source_connection_id\","]
    #[doc = "    \"status\","]
    #[doc = "    \"total_bytes\","]
    #[doc = "    \"total_items\","]
    #[doc = "    \"transferred_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"completed_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"error_summary\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"estimated_time_remaining\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"failed_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"finished_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"job_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"progress_percent\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"skipped_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"source_connection_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"total_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"transferred_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MigrationJobResponse {
        pub completed_items: i32,
        pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_summary: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub estimated_time_remaining: ::std::option::Option<i64>,
        pub failed_items: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub finished_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub id: ::uuid::Uuid,
        pub job_type: ::std::string::String,
        pub progress_percent: f64,
        pub skipped_items: i32,
        pub source_connection_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        pub total_bytes: i64,
        pub total_items: i32,
        pub transferred_bytes: i64,
    }
    impl MigrationJobResponse {
        pub fn builder() -> builder::MigrationJobResponse {
            Default::default()
        }
    }
    #[doc = "`MigrationJobRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"completed_items\","]
    #[doc = "    \"config\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"failed_items\","]
    #[doc = "    \"id\","]
    #[doc = "    \"job_type\","]
    #[doc = "    \"skipped_items\","]
    #[doc = "    \"source_connection_id\","]
    #[doc = "    \"status\","]
    #[doc = "    \"total_bytes\","]
    #[doc = "    \"total_items\","]
    #[doc = "    \"transferred_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"completed_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"created_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"error_summary\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"failed_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"finished_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"job_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"skipped_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"source_connection_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"total_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_items\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"transferred_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MigrationJobRow {
        pub completed_items: i32,
        pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_by: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_summary: ::std::option::Option<::std::string::String>,
        pub failed_items: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub finished_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub id: ::uuid::Uuid,
        pub job_type: ::std::string::String,
        pub skipped_items: i32,
        pub source_connection_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
        pub total_bytes: i64,
        pub total_items: i32,
        pub transferred_bytes: i64,
    }
    impl MigrationJobRow {
        pub fn builder() -> builder::MigrationJobRow {
            Default::default()
        }
    }
    #[doc = "`MigrationReportResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"errors\","]
    #[doc = "    \"generated_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"job_id\","]
    #[doc = "    \"recommendations\","]
    #[doc = "    \"summary\","]
    #[doc = "    \"warnings\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"errors\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"generated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"job_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"recommendations\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"summary\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"warnings\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MigrationReportResponse {
        pub errors: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub generated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub job_id: ::uuid::Uuid,
        pub recommendations: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub summary: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub warnings: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl MigrationReportResponse {
        pub fn builder() -> builder::MigrationReportResponse {
            Default::default()
        }
    }
    #[doc = "`MigrationReportRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"errors\","]
    #[doc = "    \"generated_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"job_id\","]
    #[doc = "    \"recommendations\","]
    #[doc = "    \"summary\","]
    #[doc = "    \"warnings\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"errors\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"generated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"job_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"recommendations\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"summary\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"warnings\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MigrationReportRow {
        pub errors: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub generated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub job_id: ::uuid::Uuid,
        pub recommendations: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub summary: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub warnings: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl MigrationReportRow {
        pub fn builder() -> builder::MigrationReportRow {
            Default::default()
        }
    }
    #[doc = "`NetworkProfileBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"concurrent_transfers_limit\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_bandwidth_bps\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"sync_window_end\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sync_window_start\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sync_window_timezone\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkProfileBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub concurrent_transfers_limit: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_bandwidth_bps: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sync_window_end: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sync_window_start: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sync_window_timezone: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for NetworkProfileBody {
        fn default() -> Self {
            Self {
                concurrent_transfers_limit: Default::default(),
                max_bandwidth_bps: Default::default(),
                sync_window_end: Default::default(),
                sync_window_start: Default::default(),
                sync_window_timezone: Default::default(),
            }
        }
    }
    impl NetworkProfileBody {
        pub fn builder() -> builder::NetworkProfileBody {
            Default::default()
        }
    }
    #[doc = "`OidcConfigResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"attribute_mapping\","]
    #[doc = "    \"auto_create_users\","]
    #[doc = "    \"client_id\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"has_secret\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"issuer_url\","]
    #[doc = "    \"name\","]
    #[doc = "    \"scopes\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"attribute_mapping\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"auto_create_users\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"client_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"has_secret\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"issuer_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"scopes\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OidcConfigResponse {
        pub attribute_mapping: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub auto_create_users: bool,
        pub client_id: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub has_secret: bool,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        pub issuer_url: ::std::string::String,
        pub name: ::std::string::String,
        pub scopes: ::std::vec::Vec<::std::string::String>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl OidcConfigResponse {
        pub fn builder() -> builder::OidcConfigResponse {
            Default::default()
        }
    }
    #[doc = "`PackageListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PackageResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PackageListResponse {
        pub items: ::std::vec::Vec<PackageResponse>,
        pub pagination: Pagination,
    }
    impl PackageListResponse {
        pub fn builder() -> builder::PackageListResponse {
            Default::default()
        }
    }
    #[doc = "`PackageResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"format\","]
    #[doc = "    \"id\","]
    #[doc = "    \"metadata\","]
    #[doc = "    \"name\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"updated_at\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PackageResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub download_count: i64,
        pub format: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub name: ::std::string::String,
        pub repository_key: ::std::string::String,
        pub size_bytes: i64,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: ::std::string::String,
    }
    impl PackageResponse {
        pub fn builder() -> builder::PackageResponse {
            Default::default()
        }
    }
    #[doc = "`PackageRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"format\","]
    #[doc = "    \"id\","]
    #[doc = "    \"metadata\","]
    #[doc = "    \"name\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"updated_at\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PackageRow {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub download_count: i64,
        pub format: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub name: ::std::string::String,
        pub repository_key: ::std::string::String,
        pub size_bytes: i64,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: ::std::string::String,
    }
    impl PackageRow {
        pub fn builder() -> builder::PackageRow {
            Default::default()
        }
    }
    #[doc = "`PackageVersionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PackageVersionResponse {
        pub checksum_sha256: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub download_count: i64,
        pub size_bytes: i64,
        pub version: ::std::string::String,
    }
    impl PackageVersionResponse {
        pub fn builder() -> builder::PackageVersionResponse {
            Default::default()
        }
    }
    #[doc = "`PackageVersionRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checksum_sha256\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"size_bytes\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checksum_sha256\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PackageVersionRow {
        pub checksum_sha256: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub download_count: i64,
        pub size_bytes: i64,
        pub version: ::std::string::String,
    }
    impl PackageVersionRow {
        pub fn builder() -> builder::PackageVersionRow {
            Default::default()
        }
    }
    #[doc = "`PackageVersionsResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"versions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"versions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PackageVersionResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PackageVersionsResponse {
        pub versions: ::std::vec::Vec<PackageVersionResponse>,
    }
    impl PackageVersionsResponse {
        pub fn builder() -> builder::PackageVersionsResponse {
            Default::default()
        }
    }
    #[doc = "Pagination metadata for list responses.\n\nUsed consistently across all paginated API endpoints to provide\nstandard pagination information to clients."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Pagination metadata for list responses.\\n\\nUsed consistently across all paginated API endpoints to provide\\nstandard pagination information to clients.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"page\","]
    #[doc = "    \"per_page\","]
    #[doc = "    \"total\","]
    #[doc = "    \"total_pages\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"description\": \"Current page number (1-indexed)\","]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"description\": \"Number of items per page\","]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"description\": \"Total number of items across all pages\","]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_pages\": {"]
    #[doc = "      \"description\": \"Total number of pages\","]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Pagination {
        #[doc = "Current page number (1-indexed)"]
        pub page: i32,
        #[doc = "Number of items per page"]
        pub per_page: i32,
        #[doc = "Total number of items across all pages"]
        pub total: i64,
        #[doc = "Total number of pages"]
        pub total_pages: i32,
    }
    impl Pagination {
        pub fn builder() -> builder::Pagination {
            Default::default()
        }
    }
    #[doc = "`PaginationInfo`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"page\","]
    #[doc = "    \"per_page\","]
    #[doc = "    \"total\","]
    #[doc = "    \"total_pages\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_pages\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaginationInfo {
        pub page: i32,
        pub per_page: i32,
        pub total: i64,
        pub total_pages: i32,
    }
    impl PaginationInfo {
        pub fn builder() -> builder::PaginationInfo {
            Default::default()
        }
    }
    #[doc = "`PeerInstanceListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PeerInstanceResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerInstanceListResponse {
        pub items: ::std::vec::Vec<PeerInstanceResponse>,
        pub total: i64,
    }
    impl PeerInstanceListResponse {
        pub fn builder() -> builder::PeerInstanceListResponse {
            Default::default()
        }
    }
    #[doc = "`PeerInstanceResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"cache_size_bytes\","]
    #[doc = "    \"cache_usage_percent\","]
    #[doc = "    \"cache_used_bytes\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"endpoint_url\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_local\","]
    #[doc = "    \"name\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"cache_size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"cache_usage_percent\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    },"]
    #[doc = "    \"cache_used_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"endpoint_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_local\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"last_heartbeat_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"last_sync_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"region\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerInstanceResponse {
        pub cache_size_bytes: i64,
        pub cache_usage_percent: f64,
        pub cache_used_bytes: i64,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub endpoint_url: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub is_local: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_heartbeat_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_sync_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
        pub status: ::std::string::String,
    }
    impl PeerInstanceResponse {
        pub fn builder() -> builder::PeerInstanceResponse {
            Default::default()
        }
    }
    #[doc = "`PeerLabelEntrySchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerLabelEntrySchema {
        pub key: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }
    impl PeerLabelEntrySchema {
        pub fn builder() -> builder::PeerLabelEntrySchema {
            Default::default()
        }
    }
    #[doc = "`PeerLabelResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"key\","]
    #[doc = "    \"peer_instance_id\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_instance_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerLabelResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub key: ::std::string::String,
        pub peer_instance_id: ::uuid::Uuid,
        pub value: ::std::string::String,
    }
    impl PeerLabelResponse {
        pub fn builder() -> builder::PeerLabelResponse {
            Default::default()
        }
    }
    #[doc = "`PeerLabelsListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PeerLabelResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerLabelsListResponse {
        pub items: ::std::vec::Vec<PeerLabelResponse>,
        pub total: u64,
    }
    impl PeerLabelsListResponse {
        pub fn builder() -> builder::PeerLabelsListResponse {
            Default::default()
        }
    }
    #[doc = "`PeerResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"bytes_transferred_total\","]
    #[doc = "    \"id\","]
    #[doc = "    \"shared_artifacts_count\","]
    #[doc = "    \"shared_chunks_count\","]
    #[doc = "    \"status\","]
    #[doc = "    \"target_peer_id\","]
    #[doc = "    \"transfer_failure_count\","]
    #[doc = "    \"transfer_success_count\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"bandwidth_estimate_bps\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"bytes_transferred_total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"last_probed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"last_transfer_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"latency_ms\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"shared_artifacts_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"shared_chunks_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"transfer_failure_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"transfer_success_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bandwidth_estimate_bps: ::std::option::Option<i64>,
        pub bytes_transferred_total: i64,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_probed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_transfer_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latency_ms: ::std::option::Option<i32>,
        pub shared_artifacts_count: i32,
        pub shared_chunks_count: i32,
        pub status: ::std::string::String,
        pub target_peer_id: ::uuid::Uuid,
        pub transfer_failure_count: i32,
        pub transfer_success_count: i32,
    }
    impl PeerResponse {
        pub fn builder() -> builder::PeerResponse {
            Default::default()
        }
    }
    #[doc = "`PeerSelectorSchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"all\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"match_labels\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"match_peers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"format\": \"uuid\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"match_region\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeerSelectorSchema {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub all: ::std::option::Option<bool>,
        #[serde(
            default,
            skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
        )]
        pub match_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub match_peers: ::std::vec::Vec<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub match_region: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PeerSelectorSchema {
        fn default() -> Self {
            Self {
                all: Default::default(),
                match_labels: Default::default(),
                match_peers: Default::default(),
                match_region: Default::default(),
            }
        }
    }
    impl PeerSelectorSchema {
        pub fn builder() -> builder::PeerSelectorSchema {
            Default::default()
        }
    }
    #[doc = "`PendingQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"source_repository\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PendingQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_repository: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PendingQuery {
        fn default() -> Self {
            Self {
                page: Default::default(),
                per_page: Default::default(),
                source_repository: Default::default(),
            }
        }
    }
    impl PendingQuery {
        pub fn builder() -> builder::PendingQuery {
            Default::default()
        }
    }
    #[doc = "`PermissionListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PermissionResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PermissionListResponse {
        pub items: ::std::vec::Vec<PermissionResponse>,
        pub pagination: Pagination,
    }
    impl PermissionListResponse {
        pub fn builder() -> builder::PermissionListResponse {
            Default::default()
        }
    }
    #[doc = "`PermissionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"actions\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"principal_id\","]
    #[doc = "    \"principal_type\","]
    #[doc = "    \"target_id\","]
    #[doc = "    \"target_type\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"actions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"principal_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"target_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"target_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PermissionResponse {
        pub actions: ::std::vec::Vec<::std::string::String>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub principal_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub principal_name: ::std::option::Option<::std::string::String>,
        pub principal_type: ::std::string::String,
        pub target_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub target_name: ::std::option::Option<::std::string::String>,
        pub target_type: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl PermissionResponse {
        pub fn builder() -> builder::PermissionResponse {
            Default::default()
        }
    }
    #[doc = "`PermissionRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"actions\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"principal_id\","]
    #[doc = "    \"principal_type\","]
    #[doc = "    \"target_id\","]
    #[doc = "    \"target_type\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"actions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"principal_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"principal_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"target_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"target_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PermissionRow {
        pub actions: ::std::vec::Vec<::std::string::String>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub principal_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub principal_name: ::std::option::Option<::std::string::String>,
        pub principal_type: ::std::string::String,
        pub target_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub target_name: ::std::option::Option<::std::string::String>,
        pub target_type: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl PermissionRow {
        pub fn builder() -> builder::PermissionRow {
            Default::default()
        }
    }
    #[doc = "`PluginConfigResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"config\","]
    #[doc = "    \"plugin_id\","]
    #[doc = "    \"schema\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"plugin_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"schema\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PluginConfigResponse {
        pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub plugin_id: ::uuid::Uuid,
        pub schema: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl PluginConfigResponse {
        pub fn builder() -> builder::PluginConfigResponse {
            Default::default()
        }
    }
    #[doc = "Response for plugin installation"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Response for plugin installation\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"format_key\","]
    #[doc = "    \"message\","]
    #[doc = "    \"name\","]
    #[doc = "    \"plugin_id\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"format_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"plugin_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PluginInstallResponse {
        pub format_key: ::std::string::String,
        pub message: ::std::string::String,
        pub name: ::std::string::String,
        pub plugin_id: ::uuid::Uuid,
        pub version: ::std::string::String,
    }
    impl PluginInstallResponse {
        pub fn builder() -> builder::PluginInstallResponse {
            Default::default()
        }
    }
    #[doc = "`PluginListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PluginResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PluginListResponse {
        pub items: ::std::vec::Vec<PluginResponse>,
    }
    impl PluginListResponse {
        pub fn builder() -> builder::PluginListResponse {
            Default::default()
        }
    }
    #[doc = "`PluginResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"config_schema\","]
    #[doc = "    \"display_name\","]
    #[doc = "    \"id\","]
    #[doc = "    \"installed_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"plugin_type\","]
    #[doc = "    \"status\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"author\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"config_schema\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"enabled_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"homepage\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"installed_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"plugin_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PluginResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub author: ::std::option::Option<::std::string::String>,
        pub config_schema: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub display_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enabled_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub homepage: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub installed_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub name: ::std::string::String,
        pub plugin_type: ::std::string::String,
        pub status: ::std::string::String,
        pub version: ::std::string::String,
    }
    impl PluginResponse {
        pub fn builder() -> builder::PluginResponse {
            Default::default()
        }
    }
    #[doc = "Plugin status"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Plugin status\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"active\","]
    #[doc = "    \"disabled\","]
    #[doc = "    \"error\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PluginStatus {
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "error")]
        Error,
    }
    impl ::std::fmt::Display for PluginStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => f.write_str("active"),
                Self::Disabled => f.write_str("disabled"),
                Self::Error => f.write_str("error"),
            }
        }
    }
    impl ::std::str::FromStr for PluginStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "active" => Ok(Self::Active),
                "disabled" => Ok(Self::Disabled),
                "error" => Ok(Self::Error),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PluginStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PluginStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PluginStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Plugin type"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Plugin type\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"format_handler\","]
    #[doc = "    \"storage_backend\","]
    #[doc = "    \"authentication\","]
    #[doc = "    \"authorization\","]
    #[doc = "    \"webhook\","]
    #[doc = "    \"custom\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PluginType {
        #[serde(rename = "format_handler")]
        FormatHandler,
        #[serde(rename = "storage_backend")]
        StorageBackend,
        #[serde(rename = "authentication")]
        Authentication,
        #[serde(rename = "authorization")]
        Authorization,
        #[serde(rename = "webhook")]
        Webhook,
        #[serde(rename = "custom")]
        Custom,
    }
    impl ::std::fmt::Display for PluginType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FormatHandler => f.write_str("format_handler"),
                Self::StorageBackend => f.write_str("storage_backend"),
                Self::Authentication => f.write_str("authentication"),
                Self::Authorization => f.write_str("authorization"),
                Self::Webhook => f.write_str("webhook"),
                Self::Custom => f.write_str("custom"),
            }
        }
    }
    impl ::std::str::FromStr for PluginType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "format_handler" => Ok(Self::FormatHandler),
                "storage_backend" => Ok(Self::StorageBackend),
                "authentication" => Ok(Self::Authentication),
                "authorization" => Ok(Self::Authorization),
                "webhook" => Ok(Self::Webhook),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PluginType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PluginType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PluginType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Result of a lifecycle policy dry-run or execution."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Result of a lifecycle policy dry-run or execution.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_matched\","]
    #[doc = "    \"artifacts_removed\","]
    #[doc = "    \"bytes_freed\","]
    #[doc = "    \"dry_run\","]
    #[doc = "    \"errors\","]
    #[doc = "    \"policy_id\","]
    #[doc = "    \"policy_name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_matched\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"artifacts_removed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"bytes_freed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"dry_run\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"errors\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"policy_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"policy_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyExecutionResult {
        pub artifacts_matched: i64,
        pub artifacts_removed: i64,
        pub bytes_freed: i64,
        pub dry_run: bool,
        pub errors: ::std::vec::Vec<::std::string::String>,
        pub policy_id: ::uuid::Uuid,
        pub policy_name: ::std::string::String,
    }
    impl PolicyExecutionResult {
        pub fn builder() -> builder::PolicyExecutionResult {
            Default::default()
        }
    }
    #[doc = "`PolicyResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"block_on_fail\","]
    #[doc = "    \"block_unscanned\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"max_severity\","]
    #[doc = "    \"name\","]
    #[doc = "    \"require_signature\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"block_on_fail\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"block_unscanned\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_artifact_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"min_staging_hours\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"require_signature\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyResponse {
        pub block_on_fail: bool,
        pub block_unscanned: bool,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_artifact_age_days: ::std::option::Option<i32>,
        pub max_severity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_staging_hours: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        pub require_signature: bool,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl PolicyResponse {
        pub fn builder() -> builder::PolicyResponse {
            Default::default()
        }
    }
    #[doc = "`PolicyViolation`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\","]
    #[doc = "    \"rule\","]
    #[doc = "    \"severity\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"rule\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyViolation {
        pub message: ::std::string::String,
        pub rule: ::std::string::String,
        pub severity: ::std::string::String,
    }
    impl PolicyViolation {
        pub fn builder() -> builder::PolicyViolation {
            Default::default()
        }
    }
    #[doc = "`PreviewPolicyPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_filter\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"precedence\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"replication_mode\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repo_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PreviewPolicyPayload {
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub artifact_filter: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enabled: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub peer_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub precedence: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub priority: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub replication_mode: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub repo_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl PreviewPolicyPayload {
        pub fn builder() -> builder::PreviewPolicyPayload {
            Default::default()
        }
    }
    #[doc = "`PreviewResultResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"matched_peers\","]
    #[doc = "    \"matched_repositories\","]
    #[doc = "    \"subscription_count\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"matched_peers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/MatchedPeerSchema\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"matched_repositories\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/MatchedRepoSchema\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"subscription_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PreviewResultResponse {
        pub matched_peers: ::std::vec::Vec<MatchedPeerSchema>,
        pub matched_repositories: ::std::vec::Vec<MatchedRepoSchema>,
        pub subscription_count: u64,
    }
    impl PreviewResultResponse {
        pub fn builder() -> builder::PreviewResultResponse {
            Default::default()
        }
    }
    #[doc = "`ProbeBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"latency_ms\","]
    #[doc = "    \"target_peer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"bandwidth_estimate_bps\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"latency_ms\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"target_peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProbeBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bandwidth_estimate_bps: ::std::option::Option<i64>,
        pub latency_ms: i32,
        pub target_peer_id: ::uuid::Uuid,
    }
    impl ProbeBody {
        pub fn builder() -> builder::ProbeBody {
            Default::default()
        }
    }
    #[doc = "`PromoteArtifactRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"target_repository\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"skip_policy_check\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"target_repository\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromoteArtifactRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_policy_check: ::std::option::Option<bool>,
        pub target_repository: ::std::string::String,
    }
    impl PromoteArtifactRequest {
        pub fn builder() -> builder::PromoteArtifactRequest {
            Default::default()
        }
    }
    #[doc = "`PromotionHistoryEntry`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"artifact_path\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"source_repo_key\","]
    #[doc = "    \"status\","]
    #[doc = "    \"target_repo_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"artifact_path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"policy_result\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"promoted_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"promoted_by_username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"rejection_reason\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"source_repo_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target_repo_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromotionHistoryEntry {
        pub artifact_id: ::uuid::Uuid,
        pub artifact_path: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub policy_result:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub promoted_by: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub promoted_by_username: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rejection_reason: ::std::option::Option<::std::string::String>,
        pub source_repo_key: ::std::string::String,
        pub status: ::std::string::String,
        pub target_repo_key: ::std::string::String,
    }
    impl PromotionHistoryEntry {
        pub fn builder() -> builder::PromotionHistoryEntry {
            Default::default()
        }
    }
    #[doc = "`PromotionHistoryQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"per_page\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromotionHistoryQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PromotionHistoryQuery {
        fn default() -> Self {
            Self {
                artifact_id: Default::default(),
                page: Default::default(),
                per_page: Default::default(),
                status: Default::default(),
            }
        }
    }
    impl PromotionHistoryQuery {
        pub fn builder() -> builder::PromotionHistoryQuery {
            Default::default()
        }
    }
    #[doc = "`PromotionHistoryResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PromotionHistoryEntry\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromotionHistoryResponse {
        pub items: ::std::vec::Vec<PromotionHistoryEntry>,
        pub pagination: Pagination,
    }
    impl PromotionHistoryResponse {
        pub fn builder() -> builder::PromotionHistoryResponse {
            Default::default()
        }
    }
    #[doc = "`PromotionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"policy_violations\","]
    #[doc = "    \"promoted\","]
    #[doc = "    \"source\","]
    #[doc = "    \"target\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"policy_violations\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PolicyViolation\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"promoted\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"promotion_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"source\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"target\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromotionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
        pub policy_violations: ::std::vec::Vec<PolicyViolation>,
        pub promoted: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub promotion_id: ::std::option::Option<::uuid::Uuid>,
        pub source: ::std::string::String,
        pub target: ::std::string::String,
    }
    impl PromotionResponse {
        pub fn builder() -> builder::PromotionResponse {
            Default::default()
        }
    }
    #[doc = "`PromotionRuleListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PromotionRuleResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromotionRuleListResponse {
        pub items: ::std::vec::Vec<PromotionRuleResponse>,
        pub total: u64,
    }
    impl PromotionRuleListResponse {
        pub fn builder() -> builder::PromotionRuleListResponse {
            Default::default()
        }
    }
    #[doc = "`PromotionRuleResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"auto_promote\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"name\","]
    #[doc = "    \"require_signature\","]
    #[doc = "    \"source_repo_id\","]
    #[doc = "    \"target_repo_id\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"allowed_licenses\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"auto_promote\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_artifact_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_cve_severity\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"min_health_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_staging_hours\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"require_signature\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"source_repo_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"target_repo_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PromotionRuleResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allowed_licenses: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        pub auto_promote: bool,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_artifact_age_days: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_cve_severity: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_health_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_staging_hours: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        pub require_signature: bool,
        pub source_repo_id: ::uuid::Uuid,
        pub target_repo_id: ::uuid::Uuid,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl PromotionRuleResponse {
        pub fn builder() -> builder::PromotionRuleResponse {
            Default::default()
        }
    }
    #[doc = "`QuickSearchResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"results\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"results\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/SearchResultItem\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct QuickSearchResponse {
        pub results: ::std::vec::Vec<SearchResultItem>,
    }
    impl QuickSearchResponse {
        pub fn builder() -> builder::QuickSearchResponse {
            Default::default()
        }
    }
    #[doc = "`ReadyzChecks`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"database\","]
    #[doc = "    \"migrations\","]
    #[doc = "    \"setup_complete\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"database\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    },"]
    #[doc = "    \"migrations\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    },"]
    #[doc = "    \"setup_complete\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CheckStatus\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReadyzChecks {
        pub database: CheckStatus,
        pub migrations: CheckStatus,
        pub setup_complete: CheckStatus,
    }
    impl ReadyzChecks {
        pub fn builder() -> builder::ReadyzChecks {
            Default::default()
        }
    }
    #[doc = "Readiness response with per-check detail."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Readiness response with per-check detail.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checks\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checks\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ReadyzChecks\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReadyzResponse {
        pub checks: ReadyzChecks,
        pub status: ::std::string::String,
    }
    impl ReadyzResponse {
        pub fn builder() -> builder::ReadyzResponse {
            Default::default()
        }
    }
    #[doc = "`RefreshTokenRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RefreshTokenRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refresh_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for RefreshTokenRequest {
        fn default() -> Self {
            Self {
                refresh_token: Default::default(),
            }
        }
    }
    impl RefreshTokenRequest {
        pub fn builder() -> builder::RefreshTokenRequest {
            Default::default()
        }
    }
    #[doc = "`RegisterPeerRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"api_key\","]
    #[doc = "    \"endpoint_url\","]
    #[doc = "    \"name\","]
    #[doc = "    \"sync_filter\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"api_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"cache_size_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"endpoint_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"region\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sync_filter\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RegisterPeerRequest {
        pub api_key: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cache_size_bytes: ::std::option::Option<i64>,
        pub endpoint_url: ::std::string::String,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
        pub sync_filter: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl RegisterPeerRequest {
        pub fn builder() -> builder::RegisterPeerRequest {
            Default::default()
        }
    }
    #[doc = "`ReindexResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_indexed\","]
    #[doc = "    \"message\","]
    #[doc = "    \"repositories_indexed\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_indexed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repositories_indexed\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReindexResponse {
        pub artifacts_indexed: i64,
        pub message: ::std::string::String,
        pub repositories_indexed: i64,
    }
    impl ReindexResponse {
        pub fn builder() -> builder::ReindexResponse {
            Default::default()
        }
    }
    #[doc = "`RejectArtifactRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"reason\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"reason\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RejectArtifactRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        pub reason: ::std::string::String,
    }
    impl RejectArtifactRequest {
        pub fn builder() -> builder::RejectArtifactRequest {
            Default::default()
        }
    }
    #[doc = "`RejectionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"reason\","]
    #[doc = "    \"rejected\","]
    #[doc = "    \"rejection_id\","]
    #[doc = "    \"source\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"reason\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"rejected\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"rejection_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"source\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RejectionResponse {
        pub artifact_id: ::uuid::Uuid,
        pub reason: ::std::string::String,
        pub rejected: bool,
        pub rejection_id: ::uuid::Uuid,
        pub source: ::std::string::String,
    }
    impl RejectionResponse {
        pub fn builder() -> builder::RejectionResponse {
            Default::default()
        }
    }
    #[doc = "`RemoteInstanceResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RemoteInstanceResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub url: ::std::string::String,
    }
    impl RemoteInstanceResponse {
        pub fn builder() -> builder::RemoteInstanceResponse {
            Default::default()
        }
    }
    #[doc = "`RepoHealthResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_evaluated\","]
    #[doc = "    \"artifacts_failing\","]
    #[doc = "    \"artifacts_passing\","]
    #[doc = "    \"health_grade\","]
    #[doc = "    \"health_score\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"repository_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_evaluated\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"artifacts_failing\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"artifacts_passing\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"avg_license_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"avg_metadata_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"avg_quality_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"avg_security_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"health_grade\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"health_score\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"last_evaluated_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepoHealthResponse {
        pub artifacts_evaluated: i32,
        pub artifacts_failing: i32,
        pub artifacts_passing: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub avg_license_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub avg_metadata_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub avg_quality_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub avg_security_score: ::std::option::Option<i32>,
        pub health_grade: ::std::string::String,
        pub health_score: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_evaluated_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub repository_id: ::uuid::Uuid,
        pub repository_key: ::std::string::String,
    }
    impl RepoHealthResponse {
        pub fn builder() -> builder::RepoHealthResponse {
            Default::default()
        }
    }
    #[doc = "`RepoSecurityResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ScanConfigResponse\""]
    #[doc = "    },"]
    #[doc = "    \"score\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ScoreResponse\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepoSecurityResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub config: ::std::option::Option<ScanConfigResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub score: ::std::option::Option<ScoreResponse>,
    }
    impl ::std::default::Default for RepoSecurityResponse {
        fn default() -> Self {
            Self {
                config: Default::default(),
                score: Default::default(),
            }
        }
    }
    impl RepoSecurityResponse {
        pub fn builder() -> builder::RepoSecurityResponse {
            Default::default()
        }
    }
    #[doc = "`RepoSelectorSchema`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"match_formats\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"match_labels\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"match_pattern\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"match_repos\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"format\": \"uuid\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepoSelectorSchema {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub match_formats: ::std::vec::Vec<::std::string::String>,
        #[serde(
            default,
            skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
        )]
        pub match_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub match_pattern: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub match_repos: ::std::vec::Vec<::uuid::Uuid>,
    }
    impl ::std::default::Default for RepoSelectorSchema {
        fn default() -> Self {
            Self {
                match_formats: Default::default(),
                match_labels: Default::default(),
                match_pattern: Default::default(),
                match_repos: Default::default(),
            }
        }
    }
    impl RepoSelectorSchema {
        pub fn builder() -> builder::RepoSelectorSchema {
            Default::default()
        }
    }
    #[doc = "`RepositoryAssessment`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_count\","]
    #[doc = "    \"compatibility\","]
    #[doc = "    \"key\","]
    #[doc = "    \"package_type\","]
    #[doc = "    \"total_size_bytes\","]
    #[doc = "    \"type\","]
    #[doc = "    \"warnings\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"compatibility\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"package_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"total_size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"warnings\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositoryAssessment {
        pub artifact_count: i64,
        pub compatibility: ::std::string::String,
        pub key: ::std::string::String,
        pub package_type: ::std::string::String,
        pub total_size_bytes: i64,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
        pub warnings: ::std::vec::Vec<::std::string::String>,
    }
    impl RepositoryAssessment {
        pub fn builder() -> builder::RepositoryAssessment {
            Default::default()
        }
    }
    #[doc = "`RepositoryListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/RepositoryResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositoryListResponse {
        pub items: ::std::vec::Vec<RepositoryResponse>,
        pub pagination: Pagination,
    }
    impl RepositoryListResponse {
        pub fn builder() -> builder::RepositoryListResponse {
            Default::default()
        }
    }
    #[doc = "`RepositoryResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"format\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_public\","]
    #[doc = "    \"key\","]
    #[doc = "    \"name\","]
    #[doc = "    \"repo_type\","]
    #[doc = "    \"storage_used_bytes\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_public\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"quota_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repo_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"storage_used_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositoryResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub format: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub is_public: bool,
        pub key: ::std::string::String,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub quota_bytes: ::std::option::Option<i64>,
        pub repo_type: ::std::string::String,
        pub storage_used_bytes: i64,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl RepositoryResponse {
        pub fn builder() -> builder::RepositoryResponse {
            Default::default()
        }
    }
    #[doc = "Repository signing configuration."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Repository signing configuration.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"require_signatures\","]
    #[doc = "    \"sign_metadata\","]
    #[doc = "    \"sign_packages\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"require_signatures\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"sign_metadata\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"sign_packages\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"signing_key_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositorySigningConfig {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub repository_id: ::uuid::Uuid,
        pub require_signatures: bool,
        pub sign_metadata: bool,
        pub sign_packages: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signing_key_id: ::std::option::Option<::uuid::Uuid>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl RepositorySigningConfig {
        pub fn builder() -> builder::RepositorySigningConfig {
            Default::default()
        }
    }
    #[doc = "Per-repository metrics snapshot."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Per-repository metrics snapshot.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_count\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"snapshot_date\","]
    #[doc = "    \"storage_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"repository_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"snapshot_date\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date\""]
    #[doc = "    },"]
    #[doc = "    \"storage_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositorySnapshot {
        pub artifact_count: i64,
        pub download_count: i64,
        pub repository_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_key: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_name: ::std::option::Option<::std::string::String>,
        pub snapshot_date: ::chrono::naive::NaiveDate,
        pub storage_bytes: i64,
    }
    impl RepositorySnapshot {
        pub fn builder() -> builder::RepositorySnapshot {
            Default::default()
        }
    }
    #[doc = "Current per-repository storage breakdown."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Current per-repository storage breakdown.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_count\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"format\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"repository_name\","]
    #[doc = "    \"storage_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"last_upload_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"storage_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositoryStorageBreakdown {
        pub artifact_count: i64,
        pub download_count: i64,
        pub format: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_upload_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub repository_id: ::uuid::Uuid,
        pub repository_key: ::std::string::String,
        pub repository_name: ::std::string::String,
        pub storage_bytes: i64,
    }
    impl RepositoryStorageBreakdown {
        pub fn builder() -> builder::RepositoryStorageBreakdown {
            Default::default()
        }
    }
    #[doc = "Response for password reset"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Response for password reset\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"temporary_password\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"temporary_password\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ResetPasswordResponse {
        pub temporary_password: ::std::string::String,
    }
    impl ResetPasswordResponse {
        pub fn builder() -> builder::ResetPasswordResponse {
            Default::default()
        }
    }
    #[doc = "`RestoreRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"restore_artifacts\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"restore_database\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"target_repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RestoreRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub restore_artifacts: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub restore_database: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub target_repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for RestoreRequest {
        fn default() -> Self {
            Self {
                restore_artifacts: Default::default(),
                restore_database: Default::default(),
                target_repository_id: Default::default(),
            }
        }
    }
    impl RestoreRequest {
        pub fn builder() -> builder::RestoreRequest {
            Default::default()
        }
    }
    #[doc = "`RestoreResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_restored\","]
    #[doc = "    \"errors\","]
    #[doc = "    \"tables_restored\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_restored\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"errors\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"tables_restored\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RestoreResponse {
        pub artifacts_restored: i32,
        pub errors: ::std::vec::Vec<::std::string::String>,
        pub tables_restored: ::std::vec::Vec<::std::string::String>,
    }
    impl RestoreResponse {
        pub fn builder() -> builder::RestoreResponse {
            Default::default()
        }
    }
    #[doc = "`ReviewRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"notes\": {"]
    #[doc = "      \"description\": \"Optional reviewer notes\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReviewRequest {
        #[doc = "Optional reviewer notes"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for ReviewRequest {
        fn default() -> Self {
            Self {
                notes: Default::default(),
            }
        }
    }
    impl ReviewRequest {
        pub fn builder() -> builder::ReviewRequest {
            Default::default()
        }
    }
    #[doc = "`RoleListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/RoleResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RoleListResponse {
        pub items: ::std::vec::Vec<RoleResponse>,
    }
    impl RoleListResponse {
        pub fn builder() -> builder::RoleListResponse {
            Default::default()
        }
    }
    #[doc = "`RoleResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"permissions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"permissions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RoleResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub permissions: ::std::vec::Vec<::std::string::String>,
    }
    impl RoleResponse {
        pub fn builder() -> builder::RoleResponse {
            Default::default()
        }
    }
    #[doc = "`RuleEvaluationResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"passed\","]
    #[doc = "    \"rule_id\","]
    #[doc = "    \"rule_name\","]
    #[doc = "    \"violations\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"passed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"rule_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"rule_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"violations\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RuleEvaluationResponse {
        pub passed: bool,
        pub rule_id: ::uuid::Uuid,
        pub rule_name: ::std::string::String,
        pub violations: ::std::vec::Vec<::std::string::String>,
    }
    impl RuleEvaluationResponse {
        pub fn builder() -> builder::RuleEvaluationResponse {
            Default::default()
        }
    }
    #[doc = "`SamlAcsForm`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"SAMLResponse\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"RelayState\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"SAMLResponse\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SamlAcsForm {
        #[serde(
            rename = "RelayState",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub relay_state: ::std::option::Option<::std::string::String>,
        #[serde(rename = "SAMLResponse")]
        pub saml_response: ::std::string::String,
    }
    impl SamlAcsForm {
        pub fn builder() -> builder::SamlAcsForm {
            Default::default()
        }
    }
    #[doc = "`SamlConfigResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"attribute_mapping\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"entity_id\","]
    #[doc = "    \"has_certificate\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"name\","]
    #[doc = "    \"name_id_format\","]
    #[doc = "    \"require_signed_assertions\","]
    #[doc = "    \"sign_requests\","]
    #[doc = "    \"sp_entity_id\","]
    #[doc = "    \"sso_url\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"admin_group\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"attribute_mapping\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"entity_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"has_certificate\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name_id_format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"require_signed_assertions\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"sign_requests\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"slo_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sp_entity_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"sso_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SamlConfigResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group: ::std::option::Option<::std::string::String>,
        pub attribute_mapping: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub entity_id: ::std::string::String,
        pub has_certificate: bool,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        pub name: ::std::string::String,
        pub name_id_format: ::std::string::String,
        pub require_signed_assertions: bool,
        pub sign_requests: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub slo_url: ::std::option::Option<::std::string::String>,
        pub sp_entity_id: ::std::string::String,
        pub sso_url: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl SamlConfigResponse {
        pub fn builder() -> builder::SamlConfigResponse {
            Default::default()
        }
    }
    #[doc = "`SbomContentResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"allOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SbomResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"content\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"content\": {"]
    #[doc = "          \"type\": \"object\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SbomContentResponse {
        pub artifact_id: ::uuid::Uuid,
        pub component_count: i32,
        pub content: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub content_hash: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub dependency_count: i32,
        pub format: ::std::string::String,
        pub format_version: ::std::string::String,
        pub generated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub generator: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub generator_version: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub license_count: i32,
        pub licenses: ::std::vec::Vec<::std::string::String>,
        pub repository_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub spec_version: ::std::option::Option<::std::string::String>,
    }
    impl SbomContentResponse {
        pub fn builder() -> builder::SbomContentResponse {
            Default::default()
        }
    }
    #[doc = "`SbomResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"component_count\","]
    #[doc = "    \"content_hash\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"dependency_count\","]
    #[doc = "    \"format\","]
    #[doc = "    \"format_version\","]
    #[doc = "    \"generated_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"license_count\","]
    #[doc = "    \"licenses\","]
    #[doc = "    \"repository_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"component_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"content_hash\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"dependency_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"format_version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"generated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"generator\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"generator_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"license_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"spec_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SbomResponse {
        pub artifact_id: ::uuid::Uuid,
        pub component_count: i32,
        pub content_hash: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub dependency_count: i32,
        pub format: ::std::string::String,
        pub format_version: ::std::string::String,
        pub generated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub generator: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub generator_version: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub license_count: i32,
        pub licenses: ::std::vec::Vec<::std::string::String>,
        pub repository_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub spec_version: ::std::option::Option<::std::string::String>,
    }
    impl SbomResponse {
        pub fn builder() -> builder::SbomResponse {
            Default::default()
        }
    }
    #[doc = "`ScanConfigResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"block_on_policy_violation\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"scan_enabled\","]
    #[doc = "    \"scan_on_proxy\","]
    #[doc = "    \"scan_on_upload\","]
    #[doc = "    \"severity_threshold\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"block_on_policy_violation\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"scan_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scan_on_proxy\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scan_on_upload\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"severity_threshold\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScanConfigResponse {
        pub block_on_policy_violation: bool,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub repository_id: ::uuid::Uuid,
        pub scan_enabled: bool,
        pub scan_on_proxy: bool,
        pub scan_on_upload: bool,
        pub severity_threshold: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl ScanConfigResponse {
        pub fn builder() -> builder::ScanConfigResponse {
            Default::default()
        }
    }
    #[doc = "`ScanListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/ScanResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScanListResponse {
        pub items: ::std::vec::Vec<ScanResponse>,
        pub total: i64,
    }
    impl ScanListResponse {
        pub fn builder() -> builder::ScanListResponse {
            Default::default()
        }
    }
    #[doc = "`ScanResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"critical_count\","]
    #[doc = "    \"findings_count\","]
    #[doc = "    \"high_count\","]
    #[doc = "    \"id\","]
    #[doc = "    \"info_count\","]
    #[doc = "    \"low_count\","]
    #[doc = "    \"medium_count\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"scan_type\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"artifact_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"artifact_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"completed_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"critical_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"error_message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"findings_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"high_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"info_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"low_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"medium_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"scan_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"scanner_version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"started_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScanResponse {
        pub artifact_id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_version: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub critical_count: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        pub findings_count: i32,
        pub high_count: i32,
        pub id: ::uuid::Uuid,
        pub info_count: i32,
        pub low_count: i32,
        pub medium_count: i32,
        pub repository_id: ::uuid::Uuid,
        pub scan_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scanner_version: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
    }
    impl ScanResponse {
        pub fn builder() -> builder::ScanResponse {
            Default::default()
        }
    }
    #[doc = "`ScoreResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"acknowledged_count\","]
    #[doc = "    \"calculated_at\","]
    #[doc = "    \"critical_count\","]
    #[doc = "    \"grade\","]
    #[doc = "    \"high_count\","]
    #[doc = "    \"id\","]
    #[doc = "    \"low_count\","]
    #[doc = "    \"medium_count\","]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"score\","]
    #[doc = "    \"total_findings\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"acknowledged_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"calculated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"critical_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"grade\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"high_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"last_scan_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"low_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"medium_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"score\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"total_findings\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScoreResponse {
        pub acknowledged_count: i32,
        pub calculated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub critical_count: i32,
        pub grade: ::std::string::String,
        pub high_count: i32,
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_scan_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub low_count: i32,
        pub medium_count: i32,
        pub repository_id: ::uuid::Uuid,
        pub score: i32,
        pub total_findings: i32,
    }
    impl ScoreResponse {
        pub fn builder() -> builder::ScoreResponse {
            Default::default()
        }
    }
    #[doc = "`ScoredPeerResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"available_chunks\","]
    #[doc = "    \"endpoint_url\","]
    #[doc = "    \"peer_id\","]
    #[doc = "    \"score\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"available_chunks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"bandwidth_estimate_bps\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"endpoint_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"latency_ms\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"score\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"format\": \"double\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScoredPeerResponse {
        pub available_chunks: i32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bandwidth_estimate_bps: ::std::option::Option<i64>,
        pub endpoint_url: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latency_ms: ::std::option::Option<i32>,
        pub peer_id: ::uuid::Uuid,
        pub score: f64,
    }
    impl ScoredPeerResponse {
        pub fn builder() -> builder::ScoredPeerResponse {
            Default::default()
        }
    }
    #[doc = "A unified search result matching the frontend `SearchResult` interface."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"A unified search result matching the frontend `SearchResult` interface.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"format\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"highlights\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SearchResultItem {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub format: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub highlights: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub path: ::std::option::Option<::std::string::String>,
        pub repository_key: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size_bytes: ::std::option::Option<i64>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl SearchResultItem {
        pub fn builder() -> builder::SearchResultItem {
            Default::default()
        }
    }
    #[doc = "A health check result for a single service."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"A health check result for a single service.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"checked_at\","]
    #[doc = "    \"service_name\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"checked_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"previous_status\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"response_time_ms\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"service_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ServiceHealthEntry {
        pub checked_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub previous_status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response_time_ms: ::std::option::Option<i32>,
        pub service_name: ::std::string::String,
        pub status: ::std::string::String,
    }
    impl ServiceHealthEntry {
        pub fn builder() -> builder::ServiceHealthEntry {
            Default::default()
        }
    }
    #[doc = "`SetLabelsRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"labels\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"labels\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/LabelEntrySchema\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SetLabelsRequest {
        pub labels: ::std::vec::Vec<LabelEntrySchema>,
    }
    impl SetLabelsRequest {
        pub fn builder() -> builder::SetLabelsRequest {
            Default::default()
        }
    }
    #[doc = "`SetPeerLabelsRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"labels\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"labels\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PeerLabelEntrySchema\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SetPeerLabelsRequest {
        pub labels: ::std::vec::Vec<PeerLabelEntrySchema>,
    }
    impl SetPeerLabelsRequest {
        pub fn builder() -> builder::SetPeerLabelsRequest {
            Default::default()
        }
    }
    #[doc = "Response body for the setup status endpoint."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Response body for the setup status endpoint.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"setup_required\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"setup_required\": {"]
    #[doc = "      \"description\": \"Whether the initial admin password change is still required.\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SetupStatusResponse {
        #[doc = "Whether the initial admin password change is still required."]
        pub setup_required: bool,
    }
    impl SetupStatusResponse {
        pub fn builder() -> builder::SetupStatusResponse {
            Default::default()
        }
    }
    #[doc = "`SigningConfigResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"repository_id\","]
    #[doc = "    \"require_signatures\","]
    #[doc = "    \"sign_metadata\","]
    #[doc = "    \"sign_packages\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SigningKeyPublic\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"require_signatures\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"sign_metadata\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"sign_packages\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"signing_key_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SigningConfigResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub key: ::std::option::Option<SigningKeyPublic>,
        pub repository_id: ::uuid::Uuid,
        pub require_signatures: bool,
        pub sign_metadata: bool,
        pub sign_packages: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signing_key_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl SigningConfigResponse {
        pub fn builder() -> builder::SigningConfigResponse {
            Default::default()
        }
    }
    #[doc = "Public view of a signing key (no private material)."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Public view of a signing key (no private material).\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"algorithm\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_active\","]
    #[doc = "    \"key_type\","]
    #[doc = "    \"name\","]
    #[doc = "    \"public_key_pem\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"algorithm\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"expires_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"fingerprint\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_active\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"key_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"key_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"last_used_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"public_key_pem\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"uid_email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"uid_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SigningKeyPublic {
        pub algorithm: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub fingerprint: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub is_active: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub key_id: ::std::option::Option<::std::string::String>,
        pub key_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_used_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub name: ::std::string::String,
        pub public_key_pem: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uid_email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uid_name: ::std::option::Option<::std::string::String>,
    }
    impl SigningKeyPublic {
        pub fn builder() -> builder::SigningKeyPublic {
            Default::default()
        }
    }
    #[doc = "`SourceConnectionRow`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"auth_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"credentials_enc\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"source_type\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"auth_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"created_by\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"credentials_enc\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"integer\","]
    #[doc = "        \"format\": \"int32\","]
    #[doc = "        \"minimum\": 0.0"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SourceConnectionRow {
        pub auth_type: ::std::string::String,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_by: ::std::option::Option<::uuid::Uuid>,
        pub credentials_enc: ::std::vec::Vec<i32>,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub source_type: ::std::string::String,
        pub url: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub verified_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl SourceConnectionRow {
        pub fn builder() -> builder::SourceConnectionRow {
            Default::default()
        }
    }
    #[doc = "`SourceRepository`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"key\","]
    #[doc = "    \"package_type\","]
    #[doc = "    \"type\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"package_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SourceRepository {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub key: ::std::string::String,
        pub package_type: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
        pub url: ::std::string::String,
    }
    impl SourceRepository {
        pub fn builder() -> builder::SourceRepository {
            Default::default()
        }
    }
    #[doc = "`SsoProviderInfo`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"id\","]
    #[doc = "    \"login_url\","]
    #[doc = "    \"name\","]
    #[doc = "    \"provider_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"login_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"provider_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SsoProviderInfo {
        pub id: ::uuid::Uuid,
        pub login_url: ::std::string::String,
        pub name: ::std::string::String,
        pub provider_type: ::std::string::String,
    }
    impl SsoProviderInfo {
        pub fn builder() -> builder::SsoProviderInfo {
            Default::default()
        }
    }
    #[doc = "Artifact aging report entry."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Artifact aging report entry.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"days_since_download\","]
    #[doc = "    \"download_count\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"repository_key\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"days_since_download\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"download_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"last_downloaded_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StaleArtifact {
        pub artifact_id: ::uuid::Uuid,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub days_since_download: i64,
        pub download_count: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_downloaded_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        pub repository_key: ::std::string::String,
        pub size_bytes: i64,
    }
    impl StaleArtifact {
        pub fn builder() -> builder::StaleArtifact {
            Default::default()
        }
    }
    #[doc = "`StaleQuery`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"limit\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StaleQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub days: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for StaleQuery {
        fn default() -> Self {
            Self {
                days: Default::default(),
                limit: Default::default(),
            }
        }
    }
    impl StaleQuery {
        pub fn builder() -> builder::StaleQuery {
            Default::default()
        }
    }
    #[doc = "A single day's storage metrics snapshot."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"A single day's storage metrics snapshot.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"snapshot_date\","]
    #[doc = "    \"total_artifacts\","]
    #[doc = "    \"total_downloads\","]
    #[doc = "    \"total_repositories\","]
    #[doc = "    \"total_storage_bytes\","]
    #[doc = "    \"total_users\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"snapshot_date\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date\""]
    #[doc = "    },"]
    #[doc = "    \"total_artifacts\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_downloads\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_repositories\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_storage_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_users\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StorageSnapshot {
        pub snapshot_date: ::chrono::naive::NaiveDate,
        pub total_artifacts: i64,
        pub total_downloads: i64,
        pub total_repositories: i64,
        pub total_storage_bytes: i64,
        pub total_users: i64,
    }
    impl StorageSnapshot {
        pub fn builder() -> builder::StorageSnapshot {
            Default::default()
        }
    }
    #[doc = "`SubmitCrashesRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"ids\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"format\": \"uuid\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubmitCrashesRequest {
        pub ids: ::std::vec::Vec<::uuid::Uuid>,
    }
    impl SubmitCrashesRequest {
        pub fn builder() -> builder::SubmitCrashesRequest {
            Default::default()
        }
    }
    #[doc = "`SubmitResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"marked_submitted\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"marked_submitted\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubmitResponse {
        pub marked_submitted: i64,
    }
    impl SubmitResponse {
        pub fn builder() -> builder::SubmitResponse {
            Default::default()
        }
    }
    #[doc = "`SuggestResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"suggestions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"suggestions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SuggestResponse {
        pub suggestions: ::std::vec::Vec<::std::string::String>,
    }
    impl SuggestResponse {
        pub fn builder() -> builder::SuggestResponse {
            Default::default()
        }
    }
    #[doc = "`SuppressIssueRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"reason\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"reason\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SuppressIssueRequest {
        pub reason: ::std::string::String,
    }
    impl SuppressIssueRequest {
        pub fn builder() -> builder::SuppressIssueRequest {
            Default::default()
        }
    }
    #[doc = "`SuppressRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"service_name\","]
    #[doc = "    \"until\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"service_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"until\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SuppressRequest {
        pub service_name: ::std::string::String,
        pub until: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl SuppressRequest {
        pub fn builder() -> builder::SuppressRequest {
            Default::default()
        }
    }
    #[doc = "`SyncPolicyListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/SyncPolicyResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SyncPolicyListResponse {
        pub items: ::std::vec::Vec<SyncPolicyResponse>,
        pub total: u64,
    }
    impl SyncPolicyListResponse {
        pub fn builder() -> builder::SyncPolicyListResponse {
            Default::default()
        }
    }
    #[doc = "`SyncPolicyResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_filter\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"description\","]
    #[doc = "    \"enabled\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"peer_selector\","]
    #[doc = "    \"precedence\","]
    #[doc = "    \"priority\","]
    #[doc = "    \"replication_mode\","]
    #[doc = "    \"repo_selector\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_filter\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"peer_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"precedence\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"replication_mode\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repo_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SyncPolicyResponse {
        pub artifact_filter: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub description: ::std::string::String,
        pub enabled: bool,
        pub id: ::uuid::Uuid,
        pub name: ::std::string::String,
        pub peer_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub precedence: i32,
        pub priority: i32,
        pub replication_mode: ::std::string::String,
        pub repo_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl SyncPolicyResponse {
        pub fn builder() -> builder::SyncPolicyResponse {
            Default::default()
        }
    }
    #[doc = "`SyncTaskResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"artifact_size\","]
    #[doc = "    \"id\","]
    #[doc = "    \"priority\","]
    #[doc = "    \"storage_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"artifact_size\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"storage_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SyncTaskResponse {
        pub artifact_id: ::uuid::Uuid,
        pub artifact_size: i64,
        pub id: ::uuid::Uuid,
        pub priority: i32,
        pub storage_key: ::std::string::String,
    }
    impl SyncTaskResponse {
        pub fn builder() -> builder::SyncTaskResponse {
            Default::default()
        }
    }
    #[doc = "`SystemSettings`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"allow_anonymous_download\","]
    #[doc = "    \"audit_retention_days\","]
    #[doc = "    \"backup_retention_count\","]
    #[doc = "    \"edge_stale_threshold_minutes\","]
    #[doc = "    \"max_upload_size_bytes\","]
    #[doc = "    \"retention_days\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"allow_anonymous_download\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"audit_retention_days\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"backup_retention_count\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"edge_stale_threshold_minutes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_upload_size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"retention_days\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemSettings {
        pub allow_anonymous_download: bool,
        pub audit_retention_days: i32,
        pub backup_retention_count: i32,
        pub edge_stale_threshold_minutes: i32,
        pub max_upload_size_bytes: i64,
        pub retention_days: i32,
    }
    impl SystemSettings {
        pub fn builder() -> builder::SystemSettings {
            Default::default()
        }
    }
    #[doc = "`SystemStats`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"active_peers\","]
    #[doc = "    \"pending_sync_tasks\","]
    #[doc = "    \"total_artifacts\","]
    #[doc = "    \"total_downloads\","]
    #[doc = "    \"total_repositories\","]
    #[doc = "    \"total_storage_bytes\","]
    #[doc = "    \"total_users\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"active_peers\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"pending_sync_tasks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_artifacts\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_downloads\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_repositories\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_storage_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"total_users\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemStats {
        pub active_peers: i64,
        pub pending_sync_tasks: i64,
        pub total_artifacts: i64,
        pub total_downloads: i64,
        pub total_repositories: i64,
        pub total_storage_bytes: i64,
        pub total_users: i64,
    }
    impl SystemStats {
        pub fn builder() -> builder::SystemStats {
            Default::default()
        }
    }
    #[doc = "Telemetry configuration."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Telemetry configuration.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"enabled\","]
    #[doc = "    \"include_logs\","]
    #[doc = "    \"review_before_send\","]
    #[doc = "    \"scrub_level\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"include_logs\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"review_before_send\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scrub_level\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TelemetrySettings {
        pub enabled: bool,
        pub include_logs: bool,
        pub review_before_send: bool,
        pub scrub_level: ::std::string::String,
    }
    impl TelemetrySettings {
        pub fn builder() -> builder::TelemetrySettings {
            Default::default()
        }
    }
    #[doc = "Request for testing a format handler"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Request for testing a format handler\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"content\","]
    #[doc = "    \"path\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"base64\": {"]
    #[doc = "      \"description\": \"Whether content is base64 encoded\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"content\": {"]
    #[doc = "      \"description\": \"Base64-encoded content to test, or raw string content\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"description\": \"Path to simulate for the artifact\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TestFormatRequest {
        #[doc = "Whether content is base64 encoded"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub base64: ::std::option::Option<bool>,
        #[doc = "Base64-encoded content to test, or raw string content"]
        pub content: ::std::string::String,
        #[doc = "Path to simulate for the artifact"]
        pub path: ::std::string::String,
    }
    impl TestFormatRequest {
        pub fn builder() -> builder::TestFormatRequest {
            Default::default()
        }
    }
    #[doc = "Response from format handler test"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Response from format handler test\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"valid\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"metadata\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/TestMetadata\""]
    #[doc = "    },"]
    #[doc = "    \"parse_error\": {"]
    #[doc = "      \"description\": \"Parse error message if any\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"valid\": {"]
    #[doc = "      \"description\": \"Whether validation passed\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"validation_error\": {"]
    #[doc = "      \"description\": \"Validation error message if any\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TestFormatResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<TestMetadata>,
        #[doc = "Parse error message if any"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parse_error: ::std::option::Option<::std::string::String>,
        #[doc = "Whether validation passed"]
        pub valid: bool,
        #[doc = "Validation error message if any"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub validation_error: ::std::option::Option<::std::string::String>,
    }
    impl TestFormatResponse {
        pub fn builder() -> builder::TestFormatResponse {
            Default::default()
        }
    }
    #[doc = "Metadata returned from testing"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Metadata returned from testing\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"content_type\","]
    #[doc = "    \"path\","]
    #[doc = "    \"size_bytes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"content_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TestMetadata {
        pub content_type: ::std::string::String,
        pub path: ::std::string::String,
        pub size_bytes: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl TestMetadata {
        pub fn builder() -> builder::TestMetadata {
            Default::default()
        }
    }
    #[doc = "`TestWebhookResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"response_body\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status_code\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TestWebhookResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response_body: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status_code: ::std::option::Option<i32>,
        pub success: bool,
    }
    impl TestWebhookResponse {
        pub fn builder() -> builder::TestWebhookResponse {
            Default::default()
        }
    }
    #[doc = "`TicketResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"expires_in\","]
    #[doc = "    \"ticket\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"expires_in\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"ticket\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TicketResponse {
        pub expires_in: i64,
        pub ticket: ::std::string::String,
    }
    impl TicketResponse {
        pub fn builder() -> builder::TicketResponse {
            Default::default()
        }
    }
    #[doc = "`TogglePolicyPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"enabled\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TogglePolicyPayload {
        pub enabled: bool,
    }
    impl TogglePolicyPayload {
        pub fn builder() -> builder::TogglePolicyPayload {
            Default::default()
        }
    }
    #[doc = "`ToggleRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"enabled\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ToggleRequest {
        pub enabled: bool,
    }
    impl ToggleRequest {
        pub fn builder() -> builder::ToggleRequest {
            Default::default()
        }
    }
    #[doc = "`TotpCodeRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpCodeRequest {
        pub code: ::std::string::String,
    }
    impl TotpCodeRequest {
        pub fn builder() -> builder::TotpCodeRequest {
            Default::default()
        }
    }
    #[doc = "`TotpDisableRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"password\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"password\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpDisableRequest {
        pub code: ::std::string::String,
        pub password: ::std::string::String,
    }
    impl TotpDisableRequest {
        pub fn builder() -> builder::TotpDisableRequest {
            Default::default()
        }
    }
    #[doc = "`TotpEnableResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"backup_codes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"backup_codes\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpEnableResponse {
        pub backup_codes: ::std::vec::Vec<::std::string::String>,
    }
    impl TotpEnableResponse {
        pub fn builder() -> builder::TotpEnableResponse {
            Default::default()
        }
    }
    #[doc = "`TotpSetupResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"qr_code_url\","]
    #[doc = "    \"secret\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"qr_code_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"secret\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpSetupResponse {
        pub qr_code_url: ::std::string::String,
        pub secret: ::std::string::String,
    }
    impl TotpSetupResponse {
        pub fn builder() -> builder::TotpSetupResponse {
            Default::default()
        }
    }
    #[doc = "`TotpVerifyRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"totp_token\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"totp_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpVerifyRequest {
        pub code: ::std::string::String,
        pub totp_token: ::std::string::String,
    }
    impl TotpVerifyRequest {
        pub fn builder() -> builder::TotpVerifyRequest {
            Default::default()
        }
    }
    #[doc = "`TransferSessionResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifact_checksum\","]
    #[doc = "    \"artifact_id\","]
    #[doc = "    \"checksum_algo\","]
    #[doc = "    \"chunk_size\","]
    #[doc = "    \"completed_chunks\","]
    #[doc = "    \"id\","]
    #[doc = "    \"requesting_peer_id\","]
    #[doc = "    \"status\","]
    #[doc = "    \"total_chunks\","]
    #[doc = "    \"total_size\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_checksum\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"checksum_algo\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chunk_size\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"completed_chunks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"requesting_peer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"total_chunks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"total_size\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransferSessionResponse {
        pub artifact_checksum: ::std::string::String,
        pub artifact_id: ::uuid::Uuid,
        pub checksum_algo: ::std::string::String,
        pub chunk_size: i32,
        pub completed_chunks: i32,
        pub id: ::uuid::Uuid,
        pub requesting_peer_id: ::uuid::Uuid,
        pub status: ::std::string::String,
        pub total_chunks: i32,
        pub total_size: i64,
    }
    impl TransferSessionResponse {
        pub fn builder() -> builder::TransferSessionResponse {
            Default::default()
        }
    }
    #[doc = "`TreeNodeResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"has_children\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"path\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"children_count\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"has_children\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"path\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_key\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"size_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TreeNodeResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub children_count: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        pub has_children: bool,
        pub id: ::std::string::String,
        pub name: ::std::string::String,
        pub path: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_key: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size_bytes: ::std::option::Option<i64>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }
    impl TreeNodeResponse {
        pub fn builder() -> builder::TreeNodeResponse {
            Default::default()
        }
    }
    #[doc = "`TreeResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"nodes\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"nodes\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/TreeNodeResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TreeResponse {
        pub nodes: ::std::vec::Vec<TreeNodeResponse>,
    }
    impl TreeResponse {
        pub fn builder() -> builder::TreeResponse {
            Default::default()
        }
    }
    #[doc = "`TriggerChecksRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TriggerChecksRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for TriggerChecksRequest {
        fn default() -> Self {
            Self {
                artifact_id: Default::default(),
                repository_id: Default::default(),
            }
        }
    }
    impl TriggerChecksRequest {
        pub fn builder() -> builder::TriggerChecksRequest {
            Default::default()
        }
    }
    #[doc = "`TriggerChecksResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_queued\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_queued\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TriggerChecksResponse {
        pub artifacts_queued: i32,
        pub message: ::std::string::String,
    }
    impl TriggerChecksResponse {
        pub fn builder() -> builder::TriggerChecksResponse {
            Default::default()
        }
    }
    #[doc = "`TriggerScanRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TriggerScanRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub artifact_id: ::std::option::Option<::uuid::Uuid>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for TriggerScanRequest {
        fn default() -> Self {
            Self {
                artifact_id: Default::default(),
                repository_id: Default::default(),
            }
        }
    }
    impl TriggerScanRequest {
        pub fn builder() -> builder::TriggerScanRequest {
            Default::default()
        }
    }
    #[doc = "`TriggerScanResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"artifacts_queued\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifacts_queued\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TriggerScanResponse {
        pub artifacts_queued: i32,
        pub message: ::std::string::String,
    }
    impl TriggerScanResponse {
        pub fn builder() -> builder::TriggerScanResponse {
            Default::default()
        }
    }
    #[doc = "Request for uninstalling a plugin"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Request for uninstalling a plugin\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"force\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UninstallQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub force: ::std::option::Option<bool>,
    }
    impl ::std::default::Default for UninstallQuery {
        fn default() -> Self {
            Self {
                force: Default::default(),
            }
        }
    }
    impl UninstallQuery {
        pub fn builder() -> builder::UninstallQuery {
            Default::default()
        }
    }
    #[doc = "`UpdateAnalysisBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"component_uuid\","]
    #[doc = "    \"project_uuid\","]
    #[doc = "    \"state\","]
    #[doc = "    \"vulnerability_uuid\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"component_uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"justification\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"project_uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"state\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"suppressed\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"vulnerability_uuid\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateAnalysisBody {
        pub component_uuid: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub justification: ::std::option::Option<::std::string::String>,
        pub project_uuid: ::std::string::String,
        pub state: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppressed: ::std::option::Option<bool>,
        pub vulnerability_uuid: ::std::string::String,
    }
    impl UpdateAnalysisBody {
        pub fn builder() -> builder::UpdateAnalysisBody {
            Default::default()
        }
    }
    #[doc = "`UpdateBuildRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"finished_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateBuildRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub finished_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub status: ::std::string::String,
    }
    impl UpdateBuildRequest {
        pub fn builder() -> builder::UpdateBuildRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateChunkAvailabilityBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chunk_bitmap\","]
    #[doc = "    \"total_chunks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chunk_bitmap\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"integer\","]
    #[doc = "        \"format\": \"int32\","]
    #[doc = "        \"minimum\": 0.0"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total_chunks\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateChunkAvailabilityBody {
        pub chunk_bitmap: ::std::vec::Vec<i32>,
        pub total_chunks: i32,
    }
    impl UpdateChunkAvailabilityBody {
        pub fn builder() -> builder::UpdateChunkAvailabilityBody {
            Default::default()
        }
    }
    #[doc = "`UpdateCveStatusRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"reason\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateCveStatusRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reason: ::std::option::Option<::std::string::String>,
        pub status: ::std::string::String,
    }
    impl UpdateCveStatusRequest {
        pub fn builder() -> builder::UpdateCveStatusRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateGateRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"enforce_on_download\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"enforce_on_promotion\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_critical_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_high_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_medium_issues\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_health_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_metadata_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_quality_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_security_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"required_checks\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateGateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub action: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enforce_on_download: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enforce_on_promotion: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_critical_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_high_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_medium_issues: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_health_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_metadata_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_quality_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_security_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub required_checks: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    }
    impl ::std::default::Default for UpdateGateRequest {
        fn default() -> Self {
            Self {
                action: Default::default(),
                description: Default::default(),
                enforce_on_download: Default::default(),
                enforce_on_promotion: Default::default(),
                is_enabled: Default::default(),
                max_critical_issues: Default::default(),
                max_high_issues: Default::default(),
                max_medium_issues: Default::default(),
                min_health_score: Default::default(),
                min_metadata_score: Default::default(),
                min_quality_score: Default::default(),
                min_security_score: Default::default(),
                name: Default::default(),
                required_checks: Default::default(),
            }
        }
    }
    impl UpdateGateRequest {
        pub fn builder() -> builder::UpdateGateRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateLdapConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"admin_group_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"bind_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"bind_password\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"display_name_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"email_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"group_base_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"group_filter\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"groups_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"server_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"use_starttls\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"user_base_dn\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"user_filter\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username_attribute\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateLdapConfigRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bind_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bind_password: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name_attribute: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email_attribute: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_base_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_filter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub groups_attribute: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub priority: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub server_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub use_starttls: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_base_dn: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_filter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username_attribute: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for UpdateLdapConfigRequest {
        fn default() -> Self {
            Self {
                admin_group_dn: Default::default(),
                bind_dn: Default::default(),
                bind_password: Default::default(),
                display_name_attribute: Default::default(),
                email_attribute: Default::default(),
                group_base_dn: Default::default(),
                group_filter: Default::default(),
                groups_attribute: Default::default(),
                is_enabled: Default::default(),
                name: Default::default(),
                priority: Default::default(),
                server_url: Default::default(),
                use_starttls: Default::default(),
                user_base_dn: Default::default(),
                user_filter: Default::default(),
                username_attribute: Default::default(),
            }
        }
    }
    impl UpdateLdapConfigRequest {
        pub fn builder() -> builder::UpdateLdapConfigRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateOidcConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"attribute_mapping\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"auto_create_users\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"client_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"client_secret\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"issuer_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"scopes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateOidcConfigRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attribute_mapping:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_create_users: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_secret: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scopes: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    }
    impl ::std::default::Default for UpdateOidcConfigRequest {
        fn default() -> Self {
            Self {
                attribute_mapping: Default::default(),
                auto_create_users: Default::default(),
                client_id: Default::default(),
                client_secret: Default::default(),
                is_enabled: Default::default(),
                issuer_url: Default::default(),
                name: Default::default(),
                scopes: Default::default(),
            }
        }
    }
    impl UpdateOidcConfigRequest {
        pub fn builder() -> builder::UpdateOidcConfigRequest {
            Default::default()
        }
    }
    #[doc = "`UpdatePluginConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"config\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"config\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdatePluginConfigRequest {
        pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl UpdatePluginConfigRequest {
        pub fn builder() -> builder::UpdatePluginConfigRequest {
            Default::default()
        }
    }
    #[doc = "`UpdatePolicyRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"block_on_fail\","]
    #[doc = "    \"block_unscanned\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"max_severity\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"block_on_fail\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"block_unscanned\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"max_artifact_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_severity\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"min_staging_hours\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"require_signature\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdatePolicyRequest {
        pub block_on_fail: bool,
        pub block_unscanned: bool,
        pub is_enabled: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_artifact_age_days: ::std::option::Option<i32>,
        pub max_severity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_staging_hours: ::std::option::Option<i32>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signature: ::std::option::Option<bool>,
    }
    impl UpdatePolicyRequest {
        pub fn builder() -> builder::UpdatePolicyRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateRepositoryRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_public\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"key\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"quota_bytes\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateRepositoryRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_public: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub key: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub quota_bytes: ::std::option::Option<i64>,
    }
    impl ::std::default::Default for UpdateRepositoryRequest {
        fn default() -> Self {
            Self {
                description: Default::default(),
                is_public: Default::default(),
                key: Default::default(),
                name: Default::default(),
                quota_bytes: Default::default(),
            }
        }
    }
    impl UpdateRepositoryRequest {
        pub fn builder() -> builder::UpdateRepositoryRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateRuleRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"allowed_licenses\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"array\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"auto_promote\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_artifact_age_days\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"max_cve_severity\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"min_health_score\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"min_staging_hours\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"require_signature\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateRuleRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allowed_licenses: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_promote: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_artifact_age_days: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_cve_severity: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_health_score: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_staging_hours: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signature: ::std::option::Option<bool>,
    }
    impl ::std::default::Default for UpdateRuleRequest {
        fn default() -> Self {
            Self {
                allowed_licenses: Default::default(),
                auto_promote: Default::default(),
                is_enabled: Default::default(),
                max_artifact_age_days: Default::default(),
                max_cve_severity: Default::default(),
                min_health_score: Default::default(),
                min_staging_hours: Default::default(),
                name: Default::default(),
                require_signature: Default::default(),
            }
        }
    }
    impl UpdateRuleRequest {
        pub fn builder() -> builder::UpdateRuleRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateSamlConfigRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"admin_group\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"attribute_mapping\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"certificate\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"entity_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name_id_format\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"require_signed_assertions\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sign_requests\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"slo_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sp_entity_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sso_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateSamlConfigRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attribute_mapping:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certificate: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub entity_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name_id_format: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signed_assertions: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sign_requests: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub slo_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sp_entity_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sso_url: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for UpdateSamlConfigRequest {
        fn default() -> Self {
            Self {
                admin_group: Default::default(),
                attribute_mapping: Default::default(),
                certificate: Default::default(),
                entity_id: Default::default(),
                is_enabled: Default::default(),
                name: Default::default(),
                name_id_format: Default::default(),
                require_signed_assertions: Default::default(),
                sign_requests: Default::default(),
                slo_url: Default::default(),
                sp_entity_id: Default::default(),
                sso_url: Default::default(),
            }
        }
    }
    impl UpdateSamlConfigRequest {
        pub fn builder() -> builder::UpdateSamlConfigRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateSigningConfigPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"require_signatures\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sign_metadata\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"sign_packages\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signing_key_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateSigningConfigPayload {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_signatures: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sign_metadata: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sign_packages: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signing_key_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::default::Default for UpdateSigningConfigPayload {
        fn default() -> Self {
            Self {
                require_signatures: Default::default(),
                sign_metadata: Default::default(),
                sign_packages: Default::default(),
                signing_key_id: Default::default(),
            }
        }
    }
    impl UpdateSigningConfigPayload {
        pub fn builder() -> builder::UpdateSigningConfigPayload {
            Default::default()
        }
    }
    #[doc = "`UpdateSyncPolicyPayload`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"artifact_filter\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"enabled\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"peer_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"precedence\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"integer\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    },"]
    #[doc = "    \"replication_mode\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"repo_selector\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateSyncPolicyPayload {
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub artifact_filter: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub peer_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub precedence: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub priority: ::std::option::Option<i32>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub replication_mode: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub repo_selector: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl ::std::default::Default for UpdateSyncPolicyPayload {
        fn default() -> Self {
            Self {
                artifact_filter: Default::default(),
                description: Default::default(),
                enabled: Default::default(),
                name: Default::default(),
                peer_selector: Default::default(),
                precedence: Default::default(),
                priority: Default::default(),
                replication_mode: Default::default(),
                repo_selector: Default::default(),
            }
        }
    }
    impl UpdateSyncPolicyPayload {
        pub fn builder() -> builder::UpdateSyncPolicyPayload {
            Default::default()
        }
    }
    #[doc = "`UpdateUserRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_active\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_admin\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"boolean\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_active: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_admin: ::std::option::Option<bool>,
    }
    impl ::std::default::Default for UpdateUserRequest {
        fn default() -> Self {
            Self {
                display_name: Default::default(),
                email: Default::default(),
                is_active: Default::default(),
                is_admin: Default::default(),
            }
        }
    }
    impl UpdateUserRequest {
        pub fn builder() -> builder::UpdateUserRequest {
            Default::default()
        }
    }
    #[doc = "`UpdateVirtualMembersRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"members\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"members\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/VirtualMemberPriority\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateVirtualMembersRequest {
        pub members: ::std::vec::Vec<VirtualMemberPriority>,
    }
    impl UpdateVirtualMembersRequest {
        pub fn builder() -> builder::UpdateVirtualMembersRequest {
            Default::default()
        }
    }
    #[doc = "`UpsertLicensePolicyRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"allowed_licenses\","]
    #[doc = "    \"denied_licenses\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"allow_unknown\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"allowed_licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"denied_licenses\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpsertLicensePolicyRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub action: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allow_unknown: ::std::option::Option<bool>,
        pub allowed_licenses: ::std::vec::Vec<::std::string::String>,
        pub denied_licenses: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_enabled: ::std::option::Option<bool>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
    }
    impl UpsertLicensePolicyRequest {
        pub fn builder() -> builder::UpsertLicensePolicyRequest {
            Default::default()
        }
    }
    #[doc = "Request to create or update a scan configuration."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Request to create or update a scan configuration.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"block_on_policy_violation\","]
    #[doc = "    \"scan_enabled\","]
    #[doc = "    \"scan_on_proxy\","]
    #[doc = "    \"scan_on_upload\","]
    #[doc = "    \"severity_threshold\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"block_on_policy_violation\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scan_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scan_on_proxy\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"scan_on_upload\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"severity_threshold\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpsertScanConfigRequest {
        pub block_on_policy_violation: bool,
        pub scan_enabled: bool,
        pub scan_on_proxy: bool,
        pub scan_on_upload: bool,
        pub severity_threshold: ::std::string::String,
    }
    impl UpsertScanConfigRequest {
        pub fn builder() -> builder::UpsertScanConfigRequest {
            Default::default()
        }
    }
    #[doc = "`UserListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"pagination\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/AdminUserResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"pagination\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Pagination\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserListResponse {
        pub items: ::std::vec::Vec<AdminUserResponse>,
        pub pagination: Pagination,
    }
    impl UserListResponse {
        pub fn builder() -> builder::UserListResponse {
            Default::default()
        }
    }
    #[doc = "`UserResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_admin\","]
    #[doc = "    \"totp_enabled\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_admin\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"totp_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<::std::string::String>,
        pub email: ::std::string::String,
        pub id: ::uuid::Uuid,
        pub is_admin: bool,
        pub totp_enabled: bool,
        pub username: ::std::string::String,
    }
    impl UserResponse {
        pub fn builder() -> builder::UserResponse {
            Default::default()
        }
    }
    #[doc = "`VirtualMemberPriority`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"member_key\","]
    #[doc = "    \"priority\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"member_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VirtualMemberPriority {
        pub member_key: ::std::string::String,
        pub priority: i32,
    }
    impl VirtualMemberPriority {
        pub fn builder() -> builder::VirtualMemberPriority {
            Default::default()
        }
    }
    #[doc = "`VirtualMemberResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"member_repo_id\","]
    #[doc = "    \"member_repo_key\","]
    #[doc = "    \"member_repo_name\","]
    #[doc = "    \"member_repo_type\","]
    #[doc = "    \"priority\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"member_repo_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"member_repo_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"member_repo_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"member_repo_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"priority\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int32\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VirtualMemberResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: ::uuid::Uuid,
        pub member_repo_id: ::uuid::Uuid,
        pub member_repo_key: ::std::string::String,
        pub member_repo_name: ::std::string::String,
        pub member_repo_type: ::std::string::String,
        pub priority: i32,
    }
    impl VirtualMemberResponse {
        pub fn builder() -> builder::VirtualMemberResponse {
            Default::default()
        }
    }
    #[doc = "`VirtualMembersListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/VirtualMemberResponse\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VirtualMembersListResponse {
        pub items: ::std::vec::Vec<VirtualMemberResponse>,
    }
    impl VirtualMembersListResponse {
        pub fn builder() -> builder::VirtualMembersListResponse {
            Default::default()
        }
    }
    #[doc = "WASM plugin response with extended fields"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"WASM plugin response with extended fields\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"capabilities\","]
    #[doc = "    \"display_name\","]
    #[doc = "    \"id\","]
    #[doc = "    \"installed_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"plugin_type\","]
    #[doc = "    \"resource_limits\","]
    #[doc = "    \"source_type\","]
    #[doc = "    \"status\","]
    #[doc = "    \"updated_at\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"author\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"capabilities\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"enabled_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"homepage\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"installed_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"license\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"plugin_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"resource_limits\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"source_ref\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"source_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WasmPluginResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub author: ::std::option::Option<::std::string::String>,
        pub capabilities: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub display_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enabled_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub homepage: ::std::option::Option<::std::string::String>,
        pub id: ::uuid::Uuid,
        pub installed_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub license: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        pub plugin_type: ::std::string::String,
        pub resource_limits: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_ref: ::std::option::Option<::std::string::String>,
        pub source_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_url: ::std::option::Option<::std::string::String>,
        pub status: ::std::string::String,
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: ::std::string::String,
    }
    impl WasmPluginResponse {
        pub fn builder() -> builder::WasmPluginResponse {
            Default::default()
        }
    }
    #[doc = "Webhook event types"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Webhook event types\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"artifact_uploaded\","]
    #[doc = "    \"artifact_deleted\","]
    #[doc = "    \"repository_created\","]
    #[doc = "    \"repository_deleted\","]
    #[doc = "    \"user_created\","]
    #[doc = "    \"user_deleted\","]
    #[doc = "    \"build_started\","]
    #[doc = "    \"build_completed\","]
    #[doc = "    \"build_failed\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WebhookEvent {
        #[serde(rename = "artifact_uploaded")]
        ArtifactUploaded,
        #[serde(rename = "artifact_deleted")]
        ArtifactDeleted,
        #[serde(rename = "repository_created")]
        RepositoryCreated,
        #[serde(rename = "repository_deleted")]
        RepositoryDeleted,
        #[serde(rename = "user_created")]
        UserCreated,
        #[serde(rename = "user_deleted")]
        UserDeleted,
        #[serde(rename = "build_started")]
        BuildStarted,
        #[serde(rename = "build_completed")]
        BuildCompleted,
        #[serde(rename = "build_failed")]
        BuildFailed,
    }
    impl ::std::fmt::Display for WebhookEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ArtifactUploaded => f.write_str("artifact_uploaded"),
                Self::ArtifactDeleted => f.write_str("artifact_deleted"),
                Self::RepositoryCreated => f.write_str("repository_created"),
                Self::RepositoryDeleted => f.write_str("repository_deleted"),
                Self::UserCreated => f.write_str("user_created"),
                Self::UserDeleted => f.write_str("user_deleted"),
                Self::BuildStarted => f.write_str("build_started"),
                Self::BuildCompleted => f.write_str("build_completed"),
                Self::BuildFailed => f.write_str("build_failed"),
            }
        }
    }
    impl ::std::str::FromStr for WebhookEvent {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "artifact_uploaded" => Ok(Self::ArtifactUploaded),
                "artifact_deleted" => Ok(Self::ArtifactDeleted),
                "repository_created" => Ok(Self::RepositoryCreated),
                "repository_deleted" => Ok(Self::RepositoryDeleted),
                "user_created" => Ok(Self::UserCreated),
                "user_deleted" => Ok(Self::UserDeleted),
                "build_started" => Ok(Self::BuildStarted),
                "build_completed" => Ok(Self::BuildCompleted),
                "build_failed" => Ok(Self::BuildFailed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WebhookEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WebhookEvent {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WebhookEvent {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WebhookListResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"items\","]
    #[doc = "    \"total\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"items\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/WebhookResponse\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"format\": \"int64\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WebhookListResponse {
        pub items: ::std::vec::Vec<WebhookResponse>,
        pub total: i64,
    }
    impl WebhookListResponse {
        pub fn builder() -> builder::WebhookListResponse {
            Default::default()
        }
    }
    #[doc = "`WebhookResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"events\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_enabled\","]
    #[doc = "    \"name\","]
    #[doc = "    \"url\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"events\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"headers\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"object\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"is_enabled\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"last_triggered_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"repository_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WebhookResponse {
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub events: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub headers:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        pub id: ::uuid::Uuid,
        pub is_enabled: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_triggered_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repository_id: ::std::option::Option<::uuid::Uuid>,
        pub url: ::std::string::String,
    }
    impl WebhookResponse {
        pub fn builder() -> builder::WebhookResponse {
            Default::default()
        }
    }
    #[doc = r" Types for composing complex structures."]
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct AcknowledgeRequest {
            reason: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for AcknowledgeRequest {
            fn default() -> Self {
                Self {
                    reason: Err("no value supplied for reason".to_string()),
                }
            }
        }
        impl AcknowledgeRequest {
            pub fn reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.reason = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reason: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AcknowledgeRequest> for super::AcknowledgeRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AcknowledgeRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    reason: value.reason?,
                })
            }
        }
        impl ::std::convert::From<super::AcknowledgeRequest> for AcknowledgeRequest {
            fn from(value: super::AcknowledgeRequest) -> Self {
                Self {
                    reason: Ok(value.reason),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddBuildArtifactsRequest {
            artifacts: ::std::result::Result<
                ::std::vec::Vec<super::BuildArtifactInputPayload>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AddBuildArtifactsRequest {
            fn default() -> Self {
                Self {
                    artifacts: Err("no value supplied for artifacts".to_string()),
                }
            }
        }
        impl AddBuildArtifactsRequest {
            pub fn artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildArtifactInputPayload>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifacts: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AddBuildArtifactsRequest> for super::AddBuildArtifactsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddBuildArtifactsRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts: value.artifacts?,
                })
            }
        }
        impl ::std::convert::From<super::AddBuildArtifactsRequest> for AddBuildArtifactsRequest {
            fn from(value: super::AddBuildArtifactsRequest) -> Self {
                Self {
                    artifacts: Ok(value.artifacts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddBuildArtifactsResponse {
            artifacts: ::std::result::Result<
                ::std::vec::Vec<super::BuildArtifactResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AddBuildArtifactsResponse {
            fn default() -> Self {
                Self {
                    artifacts: Err("no value supplied for artifacts".to_string()),
                }
            }
        }
        impl AddBuildArtifactsResponse {
            pub fn artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildArtifactResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifacts: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AddBuildArtifactsResponse> for super::AddBuildArtifactsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddBuildArtifactsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts: value.artifacts?,
                })
            }
        }
        impl ::std::convert::From<super::AddBuildArtifactsResponse> for AddBuildArtifactsResponse {
            fn from(value: super::AddBuildArtifactsResponse) -> Self {
                Self {
                    artifacts: Ok(value.artifacts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddLabelRequest {
            value: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AddLabelRequest {
            fn default() -> Self {
                Self {
                    value: Ok(Default::default()),
                }
            }
        }
        impl AddLabelRequest {
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AddLabelRequest> for super::AddLabelRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddLabelRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::AddLabelRequest> for AddLabelRequest {
            fn from(value: super::AddLabelRequest) -> Self {
                Self {
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddPeerLabelRequest {
            value: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AddPeerLabelRequest {
            fn default() -> Self {
                Self {
                    value: Ok(Default::default()),
                }
            }
        }
        impl AddPeerLabelRequest {
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AddPeerLabelRequest> for super::AddPeerLabelRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddPeerLabelRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::AddPeerLabelRequest> for AddPeerLabelRequest {
            fn from(value: super::AddPeerLabelRequest) -> Self {
                Self {
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddVirtualMemberRequest {
            member_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            priority: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        }
        impl ::std::default::Default for AddVirtualMemberRequest {
            fn default() -> Self {
                Self {
                    member_key: Err("no value supplied for member_key".to_string()),
                    priority: Ok(Default::default()),
                }
            }
        }
        impl AddVirtualMemberRequest {
            pub fn member_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.member_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for member_key: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AddVirtualMemberRequest> for super::AddVirtualMemberRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddVirtualMemberRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    member_key: value.member_key?,
                    priority: value.priority?,
                })
            }
        }
        impl ::std::convert::From<super::AddVirtualMemberRequest> for AddVirtualMemberRequest {
            fn from(value: super::AddVirtualMemberRequest) -> Self {
                Self {
                    member_key: Ok(value.member_key),
                    priority: Ok(value.priority),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AdminUserResponse {
            auth_provider: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            display_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_active: ::std::result::Result<bool, ::std::string::String>,
            is_admin: ::std::result::Result<bool, ::std::string::String>,
            last_login_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            must_change_password: ::std::result::Result<bool, ::std::string::String>,
            username: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for AdminUserResponse {
            fn default() -> Self {
                Self {
                    auth_provider: Err("no value supplied for auth_provider".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    display_name: Ok(Default::default()),
                    email: Err("no value supplied for email".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_active: Err("no value supplied for is_active".to_string()),
                    is_admin: Err("no value supplied for is_admin".to_string()),
                    last_login_at: Ok(Default::default()),
                    must_change_password: Err(
                        "no value supplied for must_change_password".to_string()
                    ),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl AdminUserResponse {
            pub fn auth_provider<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.auth_provider = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auth_provider: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_active<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_active = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_active: {e}"));
                self
            }
            pub fn is_admin<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_admin = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_admin: {e}"));
                self
            }
            pub fn last_login_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_login_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_login_at: {e}"));
                self
            }
            pub fn must_change_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.must_change_password = value.try_into().map_err(|e| {
                    format!("error converting supplied value for must_change_password: {e}")
                });
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AdminUserResponse> for super::AdminUserResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AdminUserResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auth_provider: value.auth_provider?,
                    created_at: value.created_at?,
                    display_name: value.display_name?,
                    email: value.email?,
                    id: value.id?,
                    is_active: value.is_active?,
                    is_admin: value.is_admin?,
                    last_login_at: value.last_login_at?,
                    must_change_password: value.must_change_password?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::AdminUserResponse> for AdminUserResponse {
            fn from(value: super::AdminUserResponse) -> Self {
                Self {
                    auth_provider: Ok(value.auth_provider),
                    created_at: Ok(value.created_at),
                    display_name: Ok(value.display_name),
                    email: Ok(value.email),
                    id: Ok(value.id),
                    is_active: Ok(value.is_active),
                    is_admin: Ok(value.is_admin),
                    last_login_at: Ok(value.last_login_at),
                    must_change_password: Ok(value.must_change_password),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AdvancedSearchResponse {
            facets: ::std::result::Result<super::FacetsResponse, ::std::string::String>,
            items: ::std::result::Result<
                ::std::vec::Vec<super::SearchResultItem>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::PaginationInfo, ::std::string::String>,
        }
        impl ::std::default::Default for AdvancedSearchResponse {
            fn default() -> Self {
                Self {
                    facets: Err("no value supplied for facets".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl AdvancedSearchResponse {
            pub fn facets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FacetsResponse>,
                T::Error: ::std::fmt::Display,
            {
                self.facets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for facets: {e}"));
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SearchResultItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginationInfo>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AdvancedSearchResponse> for super::AdvancedSearchResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AdvancedSearchResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    facets: value.facets?,
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::AdvancedSearchResponse> for AdvancedSearchResponse {
            fn from(value: super::AdvancedSearchResponse) -> Self {
                Self {
                    facets: Ok(value.facets),
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AlertState {
            consecutive_failures: ::std::result::Result<i32, ::std::string::String>,
            current_status: ::std::result::Result<::std::string::String, ::std::string::String>,
            last_alert_sent_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            service_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            suppressed_until: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AlertState {
            fn default() -> Self {
                Self {
                    consecutive_failures: Err(
                        "no value supplied for consecutive_failures".to_string()
                    ),
                    current_status: Err("no value supplied for current_status".to_string()),
                    last_alert_sent_at: Ok(Default::default()),
                    service_name: Err("no value supplied for service_name".to_string()),
                    suppressed_until: Ok(Default::default()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl AlertState {
            pub fn consecutive_failures<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.consecutive_failures = value.try_into().map_err(|e| {
                    format!("error converting supplied value for consecutive_failures: {e}")
                });
                self
            }
            pub fn current_status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.current_status = value.try_into().map_err(|e| {
                    format!("error converting supplied value for current_status: {e}")
                });
                self
            }
            pub fn last_alert_sent_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_alert_sent_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_alert_sent_at: {e}")
                });
                self
            }
            pub fn service_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.service_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service_name: {e}"));
                self
            }
            pub fn suppressed_until<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.suppressed_until = value.try_into().map_err(|e| {
                    format!("error converting supplied value for suppressed_until: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AlertState> for super::AlertState {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AlertState,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    consecutive_failures: value.consecutive_failures?,
                    current_status: value.current_status?,
                    last_alert_sent_at: value.last_alert_sent_at?,
                    service_name: value.service_name?,
                    suppressed_until: value.suppressed_until?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::AlertState> for AlertState {
            fn from(value: super::AlertState) -> Self {
                Self {
                    consecutive_failures: Ok(value.consecutive_failures),
                    current_status: Ok(value.current_status),
                    last_alert_sent_at: Ok(value.last_alert_sent_at),
                    service_name: Ok(value.service_name),
                    suppressed_until: Ok(value.suppressed_until),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AnnouncePeerRequest {
            api_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            endpoint_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for AnnouncePeerRequest {
            fn default() -> Self {
                Self {
                    api_key: Err("no value supplied for api_key".to_string()),
                    endpoint_url: Err("no value supplied for endpoint_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    peer_id: Err("no value supplied for peer_id".to_string()),
                }
            }
        }
        impl AnnouncePeerRequest {
            pub fn api_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.api_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for api_key: {e}"));
                self
            }
            pub fn endpoint_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.peer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AnnouncePeerRequest> for super::AnnouncePeerRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AnnouncePeerRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    api_key: value.api_key?,
                    endpoint_url: value.endpoint_url?,
                    name: value.name?,
                    peer_id: value.peer_id?,
                })
            }
        }
        impl ::std::convert::From<super::AnnouncePeerRequest> for AnnouncePeerRequest {
            fn from(value: super::AnnouncePeerRequest) -> Self {
                Self {
                    api_key: Ok(value.api_key),
                    endpoint_url: Ok(value.endpoint_url),
                    name: Ok(value.name),
                    peer_id: Ok(value.peer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApiTokenCreatedResponse {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            token: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ApiTokenCreatedResponse {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl ApiTokenCreatedResponse {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ApiTokenCreatedResponse> for super::ApiTokenCreatedResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApiTokenCreatedResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::ApiTokenCreatedResponse> for ApiTokenCreatedResponse {
            fn from(value: super::ApiTokenCreatedResponse) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApiTokenListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::ApiTokenResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ApiTokenListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl ApiTokenListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ApiTokenResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ApiTokenListResponse> for super::ApiTokenListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApiTokenListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::ApiTokenListResponse> for ApiTokenListResponse {
            fn from(value: super::ApiTokenListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApiTokenResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            expires_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_used_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            scopes: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            token_prefix: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ApiTokenResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    expires_at: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    last_used_at: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    scopes: Err("no value supplied for scopes".to_string()),
                    token_prefix: Err("no value supplied for token_prefix".to_string()),
                }
            }
        }
        impl ApiTokenResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn expires_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.expires_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for expires_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn last_used_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_used_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_used_at: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn scopes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.scopes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scopes: {e}"));
                self
            }
            pub fn token_prefix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.token_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token_prefix: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ApiTokenResponse> for super::ApiTokenResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApiTokenResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    expires_at: value.expires_at?,
                    id: value.id?,
                    last_used_at: value.last_used_at?,
                    name: value.name?,
                    scopes: value.scopes?,
                    token_prefix: value.token_prefix?,
                })
            }
        }
        impl ::std::convert::From<super::ApiTokenResponse> for ApiTokenResponse {
            fn from(value: super::ApiTokenResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    expires_at: Ok(value.expires_at),
                    id: Ok(value.id),
                    last_used_at: Ok(value.last_used_at),
                    name: Ok(value.name),
                    scopes: Ok(value.scopes),
                    token_prefix: Ok(value.token_prefix),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApprovalHistoryQuery {
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            source_repository: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ApprovalHistoryQuery {
            fn default() -> Self {
                Self {
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    source_repository: Ok(Default::default()),
                    status: Ok(Default::default()),
                }
            }
        }
        impl ApprovalHistoryQuery {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn source_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repository: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ApprovalHistoryQuery> for super::ApprovalHistoryQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApprovalHistoryQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    per_page: value.per_page?,
                    source_repository: value.source_repository?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::ApprovalHistoryQuery> for ApprovalHistoryQuery {
            fn from(value: super::ApprovalHistoryQuery) -> Self {
                Self {
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    source_repository: Ok(value.source_repository),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApprovalListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::ApprovalResponse>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for ApprovalListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl ApprovalListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ApprovalResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ApprovalListResponse> for super::ApprovalListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApprovalListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::ApprovalListResponse> for ApprovalListResponse {
            fn from(value: super::ApprovalListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApprovalRequest {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            skip_policy_check:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            source_repository: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_repository: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ApprovalRequest {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    notes: Ok(Default::default()),
                    skip_policy_check: Ok(Default::default()),
                    source_repository: Err("no value supplied for source_repository".to_string()),
                    target_repository: Err("no value supplied for target_repository".to_string()),
                }
            }
        }
        impl ApprovalRequest {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
            pub fn skip_policy_check<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.skip_policy_check = value.try_into().map_err(|e| {
                    format!("error converting supplied value for skip_policy_check: {e}")
                });
                self
            }
            pub fn source_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repository: {e}")
                });
                self
            }
            pub fn target_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repository: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ApprovalRequest> for super::ApprovalRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApprovalRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    notes: value.notes?,
                    skip_policy_check: value.skip_policy_check?,
                    source_repository: value.source_repository?,
                    target_repository: value.target_repository?,
                })
            }
        }
        impl ::std::convert::From<super::ApprovalRequest> for ApprovalRequest {
            fn from(value: super::ApprovalRequest) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    notes: Ok(value.notes),
                    skip_policy_check: Ok(value.skip_policy_check),
                    source_repository: Ok(value.source_repository),
                    target_repository: Ok(value.target_repository),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApprovalResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            policy_result: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            requested_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            requested_by: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            review_notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            reviewed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            reviewed_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            source_repository: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_repository: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ApprovalResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    notes: Ok(Default::default()),
                    policy_result: Ok(Default::default()),
                    requested_at: Err("no value supplied for requested_at".to_string()),
                    requested_by: Err("no value supplied for requested_by".to_string()),
                    review_notes: Ok(Default::default()),
                    reviewed_at: Ok(Default::default()),
                    reviewed_by: Ok(Default::default()),
                    source_repository: Err("no value supplied for source_repository".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    target_repository: Err("no value supplied for target_repository".to_string()),
                }
            }
        }
        impl ApprovalResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
            pub fn policy_result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.policy_result = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_result: {e}"));
                self
            }
            pub fn requested_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.requested_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for requested_at: {e}"));
                self
            }
            pub fn requested_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.requested_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for requested_by: {e}"));
                self
            }
            pub fn review_notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.review_notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for review_notes: {e}"));
                self
            }
            pub fn reviewed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.reviewed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reviewed_at: {e}"));
                self
            }
            pub fn reviewed_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.reviewed_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reviewed_by: {e}"));
                self
            }
            pub fn source_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repository: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn target_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repository: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ApprovalResponse> for super::ApprovalResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApprovalResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    id: value.id?,
                    notes: value.notes?,
                    policy_result: value.policy_result?,
                    requested_at: value.requested_at?,
                    requested_by: value.requested_by?,
                    review_notes: value.review_notes?,
                    reviewed_at: value.reviewed_at?,
                    reviewed_by: value.reviewed_by?,
                    source_repository: value.source_repository?,
                    status: value.status?,
                    target_repository: value.target_repository?,
                })
            }
        }
        impl ::std::convert::From<super::ApprovalResponse> for ApprovalResponse {
            fn from(value: super::ApprovalResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    id: Ok(value.id),
                    notes: Ok(value.notes),
                    policy_result: Ok(value.policy_result),
                    requested_at: Ok(value.requested_at),
                    requested_by: Ok(value.requested_by),
                    review_notes: Ok(value.review_notes),
                    reviewed_at: Ok(value.reviewed_at),
                    reviewed_by: Ok(value.reviewed_by),
                    source_repository: Ok(value.source_repository),
                    status: Ok(value.status),
                    target_repository: Ok(value.target_repository),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactEvalEntry {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            passed: ::std::result::Result<bool, ::std::string::String>,
            violations: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ArtifactEvalEntry {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    passed: Err("no value supplied for passed".to_string()),
                    violations: Err("no value supplied for violations".to_string()),
                }
            }
        }
        impl ArtifactEvalEntry {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for passed: {e}"));
                self
            }
            pub fn violations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.violations = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for violations: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactEvalEntry> for super::ArtifactEvalEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactEvalEntry,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    passed: value.passed?,
                    violations: value.violations?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactEvalEntry> for ArtifactEvalEntry {
            fn from(value: super::ArtifactEvalEntry) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    passed: Ok(value.passed),
                    violations: Ok(value.violations),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactFilterSchema {
            exclude_paths: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            include_paths: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            max_age_days: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_size_bytes:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for ArtifactFilterSchema {
            fn default() -> Self {
                Self {
                    exclude_paths: Ok(Default::default()),
                    include_paths: Ok(Default::default()),
                    max_age_days: Ok(Default::default()),
                    max_size_bytes: Ok(Default::default()),
                }
            }
        }
        impl ArtifactFilterSchema {
            pub fn exclude_paths<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.exclude_paths = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for exclude_paths: {e}"));
                self
            }
            pub fn include_paths<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.include_paths = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for include_paths: {e}"));
                self
            }
            pub fn max_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_age_days = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max_age_days: {e}"));
                self
            }
            pub fn max_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_size_bytes: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactFilterSchema> for super::ArtifactFilterSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactFilterSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    exclude_paths: value.exclude_paths?,
                    include_paths: value.include_paths?,
                    max_age_days: value.max_age_days?,
                    max_size_bytes: value.max_size_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactFilterSchema> for ArtifactFilterSchema {
            fn from(value: super::ArtifactFilterSchema) -> Self {
                Self {
                    exclude_paths: Ok(value.exclude_paths),
                    include_paths: Ok(value.include_paths),
                    max_age_days: Ok(value.max_age_days),
                    max_size_bytes: Ok(value.max_size_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactHealthResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            checks:
                ::std::result::Result<::std::vec::Vec<super::CheckSummary>, ::std::string::String>,
            checks_passed: ::std::result::Result<i32, ::std::string::String>,
            checks_total: ::std::result::Result<i32, ::std::string::String>,
            critical_issues: ::std::result::Result<i32, ::std::string::String>,
            health_grade: ::std::result::Result<::std::string::String, ::std::string::String>,
            health_score: ::std::result::Result<i32, ::std::string::String>,
            last_checked_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            license_score: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            metadata_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            quality_score: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            security_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            total_issues: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for ArtifactHealthResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    checks: Err("no value supplied for checks".to_string()),
                    checks_passed: Err("no value supplied for checks_passed".to_string()),
                    checks_total: Err("no value supplied for checks_total".to_string()),
                    critical_issues: Err("no value supplied for critical_issues".to_string()),
                    health_grade: Err("no value supplied for health_grade".to_string()),
                    health_score: Err("no value supplied for health_score".to_string()),
                    last_checked_at: Ok(Default::default()),
                    license_score: Ok(Default::default()),
                    metadata_score: Ok(Default::default()),
                    quality_score: Ok(Default::default()),
                    security_score: Ok(Default::default()),
                    total_issues: Err("no value supplied for total_issues".to_string()),
                }
            }
        }
        impl ArtifactHealthResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn checks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CheckSummary>>,
                T::Error: ::std::fmt::Display,
            {
                self.checks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checks: {e}"));
                self
            }
            pub fn checks_passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.checks_passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checks_passed: {e}"));
                self
            }
            pub fn checks_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.checks_total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checks_total: {e}"));
                self
            }
            pub fn critical_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.critical_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for critical_issues: {e}")
                });
                self
            }
            pub fn health_grade<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.health_grade = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for health_grade: {e}"));
                self
            }
            pub fn health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.health_score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for health_score: {e}"));
                self
            }
            pub fn last_checked_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_checked_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_checked_at: {e}")
                });
                self
            }
            pub fn license_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.license_score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for license_score: {e}"));
                self
            }
            pub fn metadata_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.metadata_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for metadata_score: {e}")
                });
                self
            }
            pub fn quality_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.quality_score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for quality_score: {e}"));
                self
            }
            pub fn security_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.security_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for security_score: {e}")
                });
                self
            }
            pub fn total_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_issues = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_issues: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactHealthResponse> for super::ArtifactHealthResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactHealthResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    checks: value.checks?,
                    checks_passed: value.checks_passed?,
                    checks_total: value.checks_total?,
                    critical_issues: value.critical_issues?,
                    health_grade: value.health_grade?,
                    health_score: value.health_score?,
                    last_checked_at: value.last_checked_at?,
                    license_score: value.license_score?,
                    metadata_score: value.metadata_score?,
                    quality_score: value.quality_score?,
                    security_score: value.security_score?,
                    total_issues: value.total_issues?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactHealthResponse> for ArtifactHealthResponse {
            fn from(value: super::ArtifactHealthResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    checks: Ok(value.checks),
                    checks_passed: Ok(value.checks_passed),
                    checks_total: Ok(value.checks_total),
                    critical_issues: Ok(value.critical_issues),
                    health_grade: Ok(value.health_grade),
                    health_score: Ok(value.health_score),
                    last_checked_at: Ok(value.last_checked_at),
                    license_score: Ok(value.license_score),
                    metadata_score: Ok(value.metadata_score),
                    quality_score: Ok(value.quality_score),
                    security_score: Ok(value.security_score),
                    total_issues: Ok(value.total_issues),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::ArtifactResponse>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for ArtifactListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl ArtifactListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ArtifactResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactListResponse> for super::ArtifactListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactListResponse> for ArtifactListResponse {
            fn from(value: super::ArtifactListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactMetadataResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            metadata: ::std::result::Result<::serde_json::Value, ::std::string::String>,
            properties: ::std::result::Result<::serde_json::Value, ::std::string::String>,
        }
        impl ::std::default::Default for ArtifactMetadataResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    format: Err("no value supplied for format".to_string()),
                    metadata: Err("no value supplied for metadata".to_string()),
                    properties: Err("no value supplied for properties".to_string()),
                }
            }
        }
        impl ArtifactMetadataResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::serde_json::Value>,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn properties<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::serde_json::Value>,
                T::Error: ::std::fmt::Display,
            {
                self.properties = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for properties: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactMetadataResponse> for super::ArtifactMetadataResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactMetadataResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    format: value.format?,
                    metadata: value.metadata?,
                    properties: value.properties?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactMetadataResponse> for ArtifactMetadataResponse {
            fn from(value: super::ArtifactMetadataResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    format: Ok(value.format),
                    metadata: Ok(value.metadata),
                    properties: Ok(value.properties),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactResponse {
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            content_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            metadata: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ArtifactResponse {
            fn default() -> Self {
                Self {
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    content_type: Err("no value supplied for content_type".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    metadata: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl ArtifactResponse {
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn content_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.content_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content_type: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactResponse> for super::ArtifactResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_sha256: value.checksum_sha256?,
                    content_type: value.content_type?,
                    created_at: value.created_at?,
                    download_count: value.download_count?,
                    id: value.id?,
                    metadata: value.metadata?,
                    name: value.name?,
                    path: value.path?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactResponse> for ArtifactResponse {
            fn from(value: super::ArtifactResponse) -> Self {
                Self {
                    checksum_sha256: Ok(value.checksum_sha256),
                    content_type: Ok(value.content_type),
                    created_at: Ok(value.created_at),
                    download_count: Ok(value.download_count),
                    id: Ok(value.id),
                    metadata: Ok(value.metadata),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ArtifactStatsResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            first_downloaded: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            last_downloaded: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ArtifactStatsResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    first_downloaded: Ok(Default::default()),
                    last_downloaded: Ok(Default::default()),
                }
            }
        }
        impl ArtifactStatsResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn first_downloaded<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.first_downloaded = value.try_into().map_err(|e| {
                    format!("error converting supplied value for first_downloaded: {e}")
                });
                self
            }
            pub fn last_downloaded<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_downloaded = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_downloaded: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ArtifactStatsResponse> for super::ArtifactStatsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ArtifactStatsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    download_count: value.download_count?,
                    first_downloaded: value.first_downloaded?,
                    last_downloaded: value.last_downloaded?,
                })
            }
        }
        impl ::std::convert::From<super::ArtifactStatsResponse> for ArtifactStatsResponse {
            fn from(value: super::ArtifactStatsResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    download_count: Ok(value.download_count),
                    first_downloaded: Ok(value.first_downloaded),
                    last_downloaded: Ok(value.last_downloaded),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AssessmentResult {
            blockers: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            estimated_duration_seconds: ::std::result::Result<i64, ::std::string::String>,
            groups_count: ::std::result::Result<i64, ::std::string::String>,
            job_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            permissions_count: ::std::result::Result<i64, ::std::string::String>,
            repositories: ::std::result::Result<
                ::std::vec::Vec<super::RepositoryAssessment>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            total_artifacts: ::std::result::Result<i64, ::std::string::String>,
            total_size_bytes: ::std::result::Result<i64, ::std::string::String>,
            users_count: ::std::result::Result<i64, ::std::string::String>,
            warnings: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AssessmentResult {
            fn default() -> Self {
                Self {
                    blockers: Err("no value supplied for blockers".to_string()),
                    estimated_duration_seconds: Err(
                        "no value supplied for estimated_duration_seconds".to_string(),
                    ),
                    groups_count: Err("no value supplied for groups_count".to_string()),
                    job_id: Err("no value supplied for job_id".to_string()),
                    permissions_count: Err("no value supplied for permissions_count".to_string()),
                    repositories: Err("no value supplied for repositories".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    total_artifacts: Err("no value supplied for total_artifacts".to_string()),
                    total_size_bytes: Err("no value supplied for total_size_bytes".to_string()),
                    users_count: Err("no value supplied for users_count".to_string()),
                    warnings: Err("no value supplied for warnings".to_string()),
                }
            }
        }
        impl AssessmentResult {
            pub fn blockers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.blockers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for blockers: {e}"));
                self
            }
            pub fn estimated_duration_seconds<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.estimated_duration_seconds = value.try_into().map_err(|e| {
                    format!("error converting supplied value for estimated_duration_seconds: {e}")
                });
                self
            }
            pub fn groups_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.groups_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for groups_count: {e}"));
                self
            }
            pub fn job_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.job_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_id: {e}"));
                self
            }
            pub fn permissions_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.permissions_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for permissions_count: {e}")
                });
                self
            }
            pub fn repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::RepositoryAssessment>>,
                T::Error: ::std::fmt::Display,
            {
                self.repositories = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repositories: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn total_artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_artifacts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_artifacts: {e}")
                });
                self
            }
            pub fn total_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_size_bytes: {e}")
                });
                self
            }
            pub fn users_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.users_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for users_count: {e}"));
                self
            }
            pub fn warnings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.warnings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for warnings: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AssessmentResult> for super::AssessmentResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AssessmentResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    blockers: value.blockers?,
                    estimated_duration_seconds: value.estimated_duration_seconds?,
                    groups_count: value.groups_count?,
                    job_id: value.job_id?,
                    permissions_count: value.permissions_count?,
                    repositories: value.repositories?,
                    status: value.status?,
                    total_artifacts: value.total_artifacts?,
                    total_size_bytes: value.total_size_bytes?,
                    users_count: value.users_count?,
                    warnings: value.warnings?,
                })
            }
        }
        impl ::std::convert::From<super::AssessmentResult> for AssessmentResult {
            fn from(value: super::AssessmentResult) -> Self {
                Self {
                    blockers: Ok(value.blockers),
                    estimated_duration_seconds: Ok(value.estimated_duration_seconds),
                    groups_count: Ok(value.groups_count),
                    job_id: Ok(value.job_id),
                    permissions_count: Ok(value.permissions_count),
                    repositories: Ok(value.repositories),
                    status: Ok(value.status),
                    total_artifacts: Ok(value.total_artifacts),
                    total_size_bytes: Ok(value.total_size_bytes),
                    users_count: Ok(value.users_count),
                    warnings: Ok(value.warnings),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AssignRepoRequest {
            replication_mode: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            replication_schedule: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            sync_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for AssignRepoRequest {
            fn default() -> Self {
                Self {
                    replication_mode: Ok(Default::default()),
                    replication_schedule: Ok(Default::default()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    sync_enabled: Ok(Default::default()),
                }
            }
        }
        impl AssignRepoRequest {
            pub fn replication_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.replication_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for replication_mode: {e}")
                });
                self
            }
            pub fn replication_schedule<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.replication_schedule = value.try_into().map_err(|e| {
                    format!("error converting supplied value for replication_schedule: {e}")
                });
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn sync_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sync_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sync_enabled: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AssignRepoRequest> for super::AssignRepoRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AssignRepoRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    replication_mode: value.replication_mode?,
                    replication_schedule: value.replication_schedule?,
                    repository_id: value.repository_id?,
                    sync_enabled: value.sync_enabled?,
                })
            }
        }
        impl ::std::convert::From<super::AssignRepoRequest> for AssignRepoRequest {
            fn from(value: super::AssignRepoRequest) -> Self {
                Self {
                    replication_mode: Ok(value.replication_mode),
                    replication_schedule: Ok(value.replication_schedule),
                    repository_id: Ok(value.repository_id),
                    sync_enabled: Ok(value.sync_enabled),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AssignRoleRequest {
            role_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for AssignRoleRequest {
            fn default() -> Self {
                Self {
                    role_id: Err("no value supplied for role_id".to_string()),
                }
            }
        }
        impl AssignRoleRequest {
            pub fn role_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.role_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<AssignRoleRequest> for super::AssignRoleRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AssignRoleRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_id: value.role_id?,
                })
            }
        }
        impl ::std::convert::From<super::AssignRoleRequest> for AssignRoleRequest {
            fn from(value: super::AssignRoleRequest) -> Self {
                Self {
                    role_id: Ok(value.role_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BackupListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::BackupResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for BackupListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl BackupListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BackupResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BackupListResponse> for super::BackupListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BackupListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::BackupListResponse> for BackupListResponse {
            fn from(value: super::BackupListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BackupResponse {
            artifact_count: ::std::result::Result<i64, ::std::string::String>,
            completed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            created_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            error_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            storage_path: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for BackupResponse {
            fn default() -> Self {
                Self {
                    artifact_count: Err("no value supplied for artifact_count".to_string()),
                    completed_at: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    created_by: Ok(Default::default()),
                    error_message: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    storage_path: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl BackupResponse {
            pub fn artifact_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_count: {e}")
                });
                self
            }
            pub fn completed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.completed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for completed_at: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn created_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_by: {e}"));
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_message: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn storage_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage_path: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BackupResponse> for super::BackupResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BackupResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_count: value.artifact_count?,
                    completed_at: value.completed_at?,
                    created_at: value.created_at?,
                    created_by: value.created_by?,
                    error_message: value.error_message?,
                    id: value.id?,
                    size_bytes: value.size_bytes?,
                    started_at: value.started_at?,
                    status: value.status?,
                    storage_path: value.storage_path?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::BackupResponse> for BackupResponse {
            fn from(value: super::BackupResponse) -> Self {
                Self {
                    artifact_count: Ok(value.artifact_count),
                    completed_at: Ok(value.completed_at),
                    created_at: Ok(value.created_at),
                    created_by: Ok(value.created_by),
                    error_message: Ok(value.error_message),
                    id: Ok(value.id),
                    size_bytes: Ok(value.size_bytes),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    storage_path: Ok(value.storage_path),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildArtifact {
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for BuildArtifact {
            fn default() -> Self {
                Self {
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                }
            }
        }
        impl BuildArtifact {
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildArtifact> for super::BuildArtifact {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildArtifact,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_sha256: value.checksum_sha256?,
                    name: value.name?,
                    path: value.path?,
                    size_bytes: value.size_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::BuildArtifact> for BuildArtifact {
            fn from(value: super::BuildArtifact) -> Self {
                Self {
                    checksum_sha256: Ok(value.checksum_sha256),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    size_bytes: Ok(value.size_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildArtifactDiff {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            new_checksum: ::std::result::Result<::std::string::String, ::std::string::String>,
            new_size_bytes: ::std::result::Result<i64, ::std::string::String>,
            old_checksum: ::std::result::Result<::std::string::String, ::std::string::String>,
            old_size_bytes: ::std::result::Result<i64, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for BuildArtifactDiff {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    new_checksum: Err("no value supplied for new_checksum".to_string()),
                    new_size_bytes: Err("no value supplied for new_size_bytes".to_string()),
                    old_checksum: Err("no value supplied for old_checksum".to_string()),
                    old_size_bytes: Err("no value supplied for old_size_bytes".to_string()),
                    path: Err("no value supplied for path".to_string()),
                }
            }
        }
        impl BuildArtifactDiff {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn new_checksum<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.new_checksum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for new_checksum: {e}"));
                self
            }
            pub fn new_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.new_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for new_size_bytes: {e}")
                });
                self
            }
            pub fn old_checksum<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.old_checksum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for old_checksum: {e}"));
                self
            }
            pub fn old_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.old_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for old_size_bytes: {e}")
                });
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildArtifactDiff> for super::BuildArtifactDiff {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildArtifactDiff,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    new_checksum: value.new_checksum?,
                    new_size_bytes: value.new_size_bytes?,
                    old_checksum: value.old_checksum?,
                    old_size_bytes: value.old_size_bytes?,
                    path: value.path?,
                })
            }
        }
        impl ::std::convert::From<super::BuildArtifactDiff> for BuildArtifactDiff {
            fn from(value: super::BuildArtifactDiff) -> Self {
                Self {
                    name: Ok(value.name),
                    new_checksum: Ok(value.new_checksum),
                    new_size_bytes: Ok(value.new_size_bytes),
                    old_checksum: Ok(value.old_checksum),
                    old_size_bytes: Ok(value.old_size_bytes),
                    path: Ok(value.path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildArtifactInputPayload {
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            module_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for BuildArtifactInputPayload {
            fn default() -> Self {
                Self {
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    module_name: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                }
            }
        }
        impl BuildArtifactInputPayload {
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn module_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.module_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for module_name: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildArtifactInputPayload> for super::BuildArtifactInputPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildArtifactInputPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_sha256: value.checksum_sha256?,
                    module_name: value.module_name?,
                    name: value.name?,
                    path: value.path?,
                    size_bytes: value.size_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::BuildArtifactInputPayload> for BuildArtifactInputPayload {
            fn from(value: super::BuildArtifactInputPayload) -> Self {
                Self {
                    checksum_sha256: Ok(value.checksum_sha256),
                    module_name: Ok(value.module_name),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    size_bytes: Ok(value.size_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildArtifactResponse {
            build_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            module_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for BuildArtifactResponse {
            fn default() -> Self {
                Self {
                    build_id: Err("no value supplied for build_id".to_string()),
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    module_name: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                }
            }
        }
        impl BuildArtifactResponse {
            pub fn build_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.build_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_id: {e}"));
                self
            }
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn module_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.module_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for module_name: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildArtifactResponse> for super::BuildArtifactResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildArtifactResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    build_id: value.build_id?,
                    checksum_sha256: value.checksum_sha256?,
                    created_at: value.created_at?,
                    id: value.id?,
                    module_name: value.module_name?,
                    name: value.name?,
                    path: value.path?,
                    size_bytes: value.size_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::BuildArtifactResponse> for BuildArtifactResponse {
            fn from(value: super::BuildArtifactResponse) -> Self {
                Self {
                    build_id: Ok(value.build_id),
                    checksum_sha256: Ok(value.checksum_sha256),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    module_name: Ok(value.module_name),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    size_bytes: Ok(value.size_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildDiffQuery {
            build_a: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            build_b: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for BuildDiffQuery {
            fn default() -> Self {
                Self {
                    build_a: Err("no value supplied for build_a".to_string()),
                    build_b: Err("no value supplied for build_b".to_string()),
                }
            }
        }
        impl BuildDiffQuery {
            pub fn build_a<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.build_a = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_a: {e}"));
                self
            }
            pub fn build_b<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.build_b = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_b: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildDiffQuery> for super::BuildDiffQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildDiffQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    build_a: value.build_a?,
                    build_b: value.build_b?,
                })
            }
        }
        impl ::std::convert::From<super::BuildDiffQuery> for BuildDiffQuery {
            fn from(value: super::BuildDiffQuery) -> Self {
                Self {
                    build_a: Ok(value.build_a),
                    build_b: Ok(value.build_b),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildDiffResponse {
            added:
                ::std::result::Result<::std::vec::Vec<super::BuildArtifact>, ::std::string::String>,
            build_a: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            build_b: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            modified: ::std::result::Result<
                ::std::vec::Vec<super::BuildArtifactDiff>,
                ::std::string::String,
            >,
            removed:
                ::std::result::Result<::std::vec::Vec<super::BuildArtifact>, ::std::string::String>,
        }
        impl ::std::default::Default for BuildDiffResponse {
            fn default() -> Self {
                Self {
                    added: Err("no value supplied for added".to_string()),
                    build_a: Err("no value supplied for build_a".to_string()),
                    build_b: Err("no value supplied for build_b".to_string()),
                    modified: Err("no value supplied for modified".to_string()),
                    removed: Err("no value supplied for removed".to_string()),
                }
            }
        }
        impl BuildDiffResponse {
            pub fn added<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildArtifact>>,
                T::Error: ::std::fmt::Display,
            {
                self.added = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for added: {e}"));
                self
            }
            pub fn build_a<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.build_a = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_a: {e}"));
                self
            }
            pub fn build_b<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.build_b = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_b: {e}"));
                self
            }
            pub fn modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildArtifactDiff>>,
                T::Error: ::std::fmt::Display,
            {
                self.modified = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for modified: {e}"));
                self
            }
            pub fn removed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildArtifact>>,
                T::Error: ::std::fmt::Display,
            {
                self.removed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for removed: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildDiffResponse> for super::BuildDiffResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildDiffResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    added: value.added?,
                    build_a: value.build_a?,
                    build_b: value.build_b?,
                    modified: value.modified?,
                    removed: value.removed?,
                })
            }
        }
        impl ::std::convert::From<super::BuildDiffResponse> for BuildDiffResponse {
            fn from(value: super::BuildDiffResponse) -> Self {
                Self {
                    added: Ok(value.added),
                    build_a: Ok(value.build_a),
                    build_b: Ok(value.build_b),
                    modified: Ok(value.modified),
                    removed: Ok(value.removed),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildListResponse {
            items:
                ::std::result::Result<::std::vec::Vec<super::BuildResponse>, ::std::string::String>,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for BuildListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl BuildListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildListResponse> for super::BuildListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::BuildListResponse> for BuildListResponse {
            fn from(value: super::BuildListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildModule {
            artifacts:
                ::std::result::Result<::std::vec::Vec<super::BuildArtifact>, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for BuildModule {
            fn default() -> Self {
                Self {
                    artifacts: Err("no value supplied for artifacts".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl BuildModule {
            pub fn artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BuildArtifact>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifacts: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildModule> for super::BuildModule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildModule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts: value.artifacts?,
                    id: value.id?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::BuildModule> for BuildModule {
            fn from(value: super::BuildModule) -> Self {
                Self {
                    artifacts: Ok(value.artifacts),
                    id: Ok(value.id),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildResponse {
            agent: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            artifact_count:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            duration_ms: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            finished_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            metadata: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            modules: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::BuildModule>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            number: ::std::result::Result<i32, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vcs_branch: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            vcs_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            vcs_revision: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            vcs_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for BuildResponse {
            fn default() -> Self {
                Self {
                    agent: Ok(Default::default()),
                    artifact_count: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    duration_ms: Ok(Default::default()),
                    finished_at: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    metadata: Ok(Default::default()),
                    modules: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    number: Err("no value supplied for number".to_string()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                    vcs_branch: Ok(Default::default()),
                    vcs_message: Ok(Default::default()),
                    vcs_revision: Ok(Default::default()),
                    vcs_url: Ok(Default::default()),
                }
            }
        }
        impl BuildResponse {
            pub fn agent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.agent = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for agent: {e}"));
                self
            }
            pub fn artifact_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_count: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn duration_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.duration_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for duration_ms: {e}"));
                self
            }
            pub fn finished_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.finished_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for finished_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn modules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<super::BuildModule>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.modules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for modules: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.number = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for number: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
            pub fn vcs_branch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_branch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_branch: {e}"));
                self
            }
            pub fn vcs_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_message: {e}"));
                self
            }
            pub fn vcs_revision<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_revision = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_revision: {e}"));
                self
            }
            pub fn vcs_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildResponse> for super::BuildResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    agent: value.agent?,
                    artifact_count: value.artifact_count?,
                    created_at: value.created_at?,
                    duration_ms: value.duration_ms?,
                    finished_at: value.finished_at?,
                    id: value.id?,
                    metadata: value.metadata?,
                    modules: value.modules?,
                    name: value.name?,
                    number: value.number?,
                    started_at: value.started_at?,
                    status: value.status?,
                    updated_at: value.updated_at?,
                    vcs_branch: value.vcs_branch?,
                    vcs_message: value.vcs_message?,
                    vcs_revision: value.vcs_revision?,
                    vcs_url: value.vcs_url?,
                })
            }
        }
        impl ::std::convert::From<super::BuildResponse> for BuildResponse {
            fn from(value: super::BuildResponse) -> Self {
                Self {
                    agent: Ok(value.agent),
                    artifact_count: Ok(value.artifact_count),
                    created_at: Ok(value.created_at),
                    duration_ms: Ok(value.duration_ms),
                    finished_at: Ok(value.finished_at),
                    id: Ok(value.id),
                    metadata: Ok(value.metadata),
                    modules: Ok(value.modules),
                    name: Ok(value.name),
                    number: Ok(value.number),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    updated_at: Ok(value.updated_at),
                    vcs_branch: Ok(value.vcs_branch),
                    vcs_message: Ok(value.vcs_message),
                    vcs_revision: Ok(value.vcs_revision),
                    vcs_url: Ok(value.vcs_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BuildRow {
            agent: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            artifact_count:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            build_number: ::std::result::Result<i32, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            duration_ms: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            finished_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for BuildRow {
            fn default() -> Self {
                Self {
                    agent: Ok(Default::default()),
                    artifact_count: Ok(Default::default()),
                    build_number: Err("no value supplied for build_number".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    duration_ms: Ok(Default::default()),
                    finished_at: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl BuildRow {
            pub fn agent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.agent = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for agent: {e}"));
                self
            }
            pub fn artifact_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_count: {e}")
                });
                self
            }
            pub fn build_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.build_number = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_number: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn duration_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.duration_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for duration_ms: {e}"));
                self
            }
            pub fn finished_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.finished_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for finished_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BuildRow> for super::BuildRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BuildRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    agent: value.agent?,
                    artifact_count: value.artifact_count?,
                    build_number: value.build_number?,
                    created_at: value.created_at?,
                    duration_ms: value.duration_ms?,
                    finished_at: value.finished_at?,
                    id: value.id?,
                    name: value.name?,
                    started_at: value.started_at?,
                    status: value.status?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::BuildRow> for BuildRow {
            fn from(value: super::BuildRow) -> Self {
                Self {
                    agent: Ok(value.agent),
                    artifact_count: Ok(value.artifact_count),
                    build_number: Ok(value.build_number),
                    created_at: Ok(value.created_at),
                    duration_ms: Ok(value.duration_ms),
                    finished_at: Ok(value.finished_at),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BulkEvaluationResponse {
            failed: ::std::result::Result<u64, ::std::string::String>,
            passed: ::std::result::Result<u64, ::std::string::String>,
            results: ::std::result::Result<
                ::std::vec::Vec<super::ArtifactEvalEntry>,
                ::std::string::String,
            >,
            rule_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            rule_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            total_artifacts: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for BulkEvaluationResponse {
            fn default() -> Self {
                Self {
                    failed: Err("no value supplied for failed".to_string()),
                    passed: Err("no value supplied for passed".to_string()),
                    results: Err("no value supplied for results".to_string()),
                    rule_id: Err("no value supplied for rule_id".to_string()),
                    rule_name: Err("no value supplied for rule_name".to_string()),
                    total_artifacts: Err("no value supplied for total_artifacts".to_string()),
                }
            }
        }
        impl BulkEvaluationResponse {
            pub fn failed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.failed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for failed: {e}"));
                self
            }
            pub fn passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for passed: {e}"));
                self
            }
            pub fn results<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ArtifactEvalEntry>>,
                T::Error: ::std::fmt::Display,
            {
                self.results = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for results: {e}"));
                self
            }
            pub fn rule_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rule_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule_id: {e}"));
                self
            }
            pub fn rule_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.rule_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule_name: {e}"));
                self
            }
            pub fn total_artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_artifacts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_artifacts: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<BulkEvaluationResponse> for super::BulkEvaluationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BulkEvaluationResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    failed: value.failed?,
                    passed: value.passed?,
                    results: value.results?,
                    rule_id: value.rule_id?,
                    rule_name: value.rule_name?,
                    total_artifacts: value.total_artifacts?,
                })
            }
        }
        impl ::std::convert::From<super::BulkEvaluationResponse> for BulkEvaluationResponse {
            fn from(value: super::BulkEvaluationResponse) -> Self {
                Self {
                    failed: Ok(value.failed),
                    passed: Ok(value.passed),
                    results: Ok(value.results),
                    rule_id: Ok(value.rule_id),
                    rule_name: Ok(value.rule_name),
                    total_artifacts: Ok(value.total_artifacts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BulkPromoteRequest {
            artifact_ids:
                ::std::result::Result<::std::vec::Vec<::uuid::Uuid>, ::std::string::String>,
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            skip_policy_check:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            target_repository: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for BulkPromoteRequest {
            fn default() -> Self {
                Self {
                    artifact_ids: Err("no value supplied for artifact_ids".to_string()),
                    notes: Ok(Default::default()),
                    skip_policy_check: Ok(Default::default()),
                    target_repository: Err("no value supplied for target_repository".to_string()),
                }
            }
        }
        impl BulkPromoteRequest {
            pub fn artifact_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_ids: {e}"));
                self
            }
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
            pub fn skip_policy_check<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.skip_policy_check = value.try_into().map_err(|e| {
                    format!("error converting supplied value for skip_policy_check: {e}")
                });
                self
            }
            pub fn target_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repository: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<BulkPromoteRequest> for super::BulkPromoteRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BulkPromoteRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_ids: value.artifact_ids?,
                    notes: value.notes?,
                    skip_policy_check: value.skip_policy_check?,
                    target_repository: value.target_repository?,
                })
            }
        }
        impl ::std::convert::From<super::BulkPromoteRequest> for BulkPromoteRequest {
            fn from(value: super::BulkPromoteRequest) -> Self {
                Self {
                    artifact_ids: Ok(value.artifact_ids),
                    notes: Ok(value.notes),
                    skip_policy_check: Ok(value.skip_policy_check),
                    target_repository: Ok(value.target_repository),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BulkPromotionResponse {
            failed: ::std::result::Result<u64, ::std::string::String>,
            promoted: ::std::result::Result<u64, ::std::string::String>,
            results: ::std::result::Result<
                ::std::vec::Vec<super::PromotionResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for BulkPromotionResponse {
            fn default() -> Self {
                Self {
                    failed: Err("no value supplied for failed".to_string()),
                    promoted: Err("no value supplied for promoted".to_string()),
                    results: Err("no value supplied for results".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl BulkPromotionResponse {
            pub fn failed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.failed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for failed: {e}"));
                self
            }
            pub fn promoted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.promoted = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for promoted: {e}"));
                self
            }
            pub fn results<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PromotionResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.results = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for results: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<BulkPromotionResponse> for super::BulkPromotionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BulkPromotionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    failed: value.failed?,
                    promoted: value.promoted?,
                    results: value.results?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::BulkPromotionResponse> for BulkPromotionResponse {
            fn from(value: super::BulkPromotionResponse) -> Self {
                Self {
                    failed: Ok(value.failed),
                    promoted: Ok(value.promoted),
                    results: Ok(value.results),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ChangePasswordRequest {
            current_password: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            new_password: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ChangePasswordRequest {
            fn default() -> Self {
                Self {
                    current_password: Ok(Default::default()),
                    new_password: Err("no value supplied for new_password".to_string()),
                }
            }
        }
        impl ChangePasswordRequest {
            pub fn current_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.current_password = value.try_into().map_err(|e| {
                    format!("error converting supplied value for current_password: {e}")
                });
                self
            }
            pub fn new_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.new_password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for new_password: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ChangePasswordRequest> for super::ChangePasswordRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ChangePasswordRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_password: value.current_password?,
                    new_password: value.new_password?,
                })
            }
        }
        impl ::std::convert::From<super::ChangePasswordRequest> for ChangePasswordRequest {
            fn from(value: super::ChangePasswordRequest) -> Self {
                Self {
                    current_password: Ok(value.current_password),
                    new_password: Ok(value.new_password),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CheckLicenseComplianceRequest {
            licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for CheckLicenseComplianceRequest {
            fn default() -> Self {
                Self {
                    licenses: Err("no value supplied for licenses".to_string()),
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl CheckLicenseComplianceRequest {
            pub fn licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.licenses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for licenses: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CheckLicenseComplianceRequest>
            for super::CheckLicenseComplianceRequest
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CheckLicenseComplianceRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    licenses: value.licenses?,
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::CheckLicenseComplianceRequest> for CheckLicenseComplianceRequest {
            fn from(value: super::CheckLicenseComplianceRequest) -> Self {
                Self {
                    licenses: Ok(value.licenses),
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CheckResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            check_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            checker_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            completed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            critical_count: ::std::result::Result<i32, ::std::string::String>,
            details: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            error_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            high_count: ::std::result::Result<i32, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            info_count: ::std::result::Result<i32, ::std::string::String>,
            issues_count: ::std::result::Result<i32, ::std::string::String>,
            low_count: ::std::result::Result<i32, ::std::string::String>,
            medium_count: ::std::result::Result<i32, ::std::string::String>,
            passed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            score: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CheckResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    check_type: Err("no value supplied for check_type".to_string()),
                    checker_version: Ok(Default::default()),
                    completed_at: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    critical_count: Err("no value supplied for critical_count".to_string()),
                    details: Ok(Default::default()),
                    error_message: Ok(Default::default()),
                    high_count: Err("no value supplied for high_count".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    info_count: Err("no value supplied for info_count".to_string()),
                    issues_count: Err("no value supplied for issues_count".to_string()),
                    low_count: Err("no value supplied for low_count".to_string()),
                    medium_count: Err("no value supplied for medium_count".to_string()),
                    passed: Ok(Default::default()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    score: Ok(Default::default()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl CheckResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn check_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.check_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for check_type: {e}"));
                self
            }
            pub fn checker_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.checker_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checker_version: {e}")
                });
                self
            }
            pub fn completed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.completed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for completed_at: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn critical_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.critical_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for critical_count: {e}")
                });
                self
            }
            pub fn details<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.details = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for details: {e}"));
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_message: {e}"));
                self
            }
            pub fn high_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.high_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high_count: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn info_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.info_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for info_count: {e}"));
                self
            }
            pub fn issues_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.issues_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issues_count: {e}"));
                self
            }
            pub fn low_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.low_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low_count: {e}"));
                self
            }
            pub fn medium_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.medium_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for medium_count: {e}"));
                self
            }
            pub fn passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for passed: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for score: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CheckResponse> for super::CheckResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CheckResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    check_type: value.check_type?,
                    checker_version: value.checker_version?,
                    completed_at: value.completed_at?,
                    created_at: value.created_at?,
                    critical_count: value.critical_count?,
                    details: value.details?,
                    error_message: value.error_message?,
                    high_count: value.high_count?,
                    id: value.id?,
                    info_count: value.info_count?,
                    issues_count: value.issues_count?,
                    low_count: value.low_count?,
                    medium_count: value.medium_count?,
                    passed: value.passed?,
                    repository_id: value.repository_id?,
                    score: value.score?,
                    started_at: value.started_at?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::CheckResponse> for CheckResponse {
            fn from(value: super::CheckResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    check_type: Ok(value.check_type),
                    checker_version: Ok(value.checker_version),
                    completed_at: Ok(value.completed_at),
                    created_at: Ok(value.created_at),
                    critical_count: Ok(value.critical_count),
                    details: Ok(value.details),
                    error_message: Ok(value.error_message),
                    high_count: Ok(value.high_count),
                    id: Ok(value.id),
                    info_count: Ok(value.info_count),
                    issues_count: Ok(value.issues_count),
                    low_count: Ok(value.low_count),
                    medium_count: Ok(value.medium_count),
                    passed: Ok(value.passed),
                    repository_id: Ok(value.repository_id),
                    score: Ok(value.score),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CheckStatus {
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CheckStatus {
            fn default() -> Self {
                Self {
                    message: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl CheckStatus {
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CheckStatus> for super::CheckStatus {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CheckStatus,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    message: value.message?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::CheckStatus> for CheckStatus {
            fn from(value: super::CheckStatus) -> Self {
                Self {
                    message: Ok(value.message),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CheckSummary {
            check_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            completed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            issues_count: ::std::result::Result<i32, ::std::string::String>,
            passed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            score: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CheckSummary {
            fn default() -> Self {
                Self {
                    check_type: Err("no value supplied for check_type".to_string()),
                    completed_at: Ok(Default::default()),
                    issues_count: Err("no value supplied for issues_count".to_string()),
                    passed: Ok(Default::default()),
                    score: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl CheckSummary {
            pub fn check_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.check_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for check_type: {e}"));
                self
            }
            pub fn completed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.completed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for completed_at: {e}"));
                self
            }
            pub fn issues_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.issues_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issues_count: {e}"));
                self
            }
            pub fn passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for passed: {e}"));
                self
            }
            pub fn score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for score: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CheckSummary> for super::CheckSummary {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CheckSummary,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    check_type: value.check_type?,
                    completed_at: value.completed_at?,
                    issues_count: value.issues_count?,
                    passed: value.passed?,
                    score: value.score?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::CheckSummary> for CheckSummary {
            fn from(value: super::CheckSummary) -> Self {
                Self {
                    check_type: Ok(value.check_type),
                    completed_at: Ok(value.completed_at),
                    issues_count: Ok(value.issues_count),
                    passed: Ok(value.passed),
                    score: Ok(value.score),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ChecksumArtifact {
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            content_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ChecksumArtifact {
            fn default() -> Self {
                Self {
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    content_type: Err("no value supplied for content_type".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl ChecksumArtifact {
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn content_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.content_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content_type: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ChecksumArtifact> for super::ChecksumArtifact {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ChecksumArtifact,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_sha256: value.checksum_sha256?,
                    content_type: value.content_type?,
                    created_at: value.created_at?,
                    download_count: value.download_count?,
                    id: value.id?,
                    name: value.name?,
                    path: value.path?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::ChecksumArtifact> for ChecksumArtifact {
            fn from(value: super::ChecksumArtifact) -> Self {
                Self {
                    checksum_sha256: Ok(value.checksum_sha256),
                    content_type: Ok(value.content_type),
                    created_at: Ok(value.created_at),
                    download_count: Ok(value.download_count),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ChecksumSearchResponse {
            artifacts: ::std::result::Result<
                ::std::vec::Vec<super::ChecksumArtifact>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ChecksumSearchResponse {
            fn default() -> Self {
                Self {
                    artifacts: Err("no value supplied for artifacts".to_string()),
                }
            }
        }
        impl ChecksumSearchResponse {
            pub fn artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ChecksumArtifact>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifacts: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ChecksumSearchResponse> for super::ChecksumSearchResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ChecksumSearchResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts: value.artifacts?,
                })
            }
        }
        impl ::std::convert::From<super::ChecksumSearchResponse> for ChecksumSearchResponse {
            fn from(value: super::ChecksumSearchResponse) -> Self {
                Self {
                    artifacts: Ok(value.artifacts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ChunkAvailabilityResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            available_chunks: ::std::result::Result<i32, ::std::string::String>,
            chunk_bitmap: ::std::result::Result<::std::vec::Vec<i32>, ::std::string::String>,
            peer_instance_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            total_chunks: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for ChunkAvailabilityResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    available_chunks: Err("no value supplied for available_chunks".to_string()),
                    chunk_bitmap: Err("no value supplied for chunk_bitmap".to_string()),
                    peer_instance_id: Err("no value supplied for peer_instance_id".to_string()),
                    total_chunks: Err("no value supplied for total_chunks".to_string()),
                }
            }
        }
        impl ChunkAvailabilityResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn available_chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.available_chunks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for available_chunks: {e}")
                });
                self
            }
            pub fn chunk_bitmap<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.chunk_bitmap = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunk_bitmap: {e}"));
                self
            }
            pub fn peer_instance_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.peer_instance_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for peer_instance_id: {e}")
                });
                self
            }
            pub fn total_chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_chunks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_chunks: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ChunkAvailabilityResponse> for super::ChunkAvailabilityResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ChunkAvailabilityResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    available_chunks: value.available_chunks?,
                    chunk_bitmap: value.chunk_bitmap?,
                    peer_instance_id: value.peer_instance_id?,
                    total_chunks: value.total_chunks?,
                })
            }
        }
        impl ::std::convert::From<super::ChunkAvailabilityResponse> for ChunkAvailabilityResponse {
            fn from(value: super::ChunkAvailabilityResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    available_chunks: Ok(value.available_chunks),
                    chunk_bitmap: Ok(value.chunk_bitmap),
                    peer_instance_id: Ok(value.peer_instance_id),
                    total_chunks: Ok(value.total_chunks),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ChunkEntry {
            byte_length: ::std::result::Result<i32, ::std::string::String>,
            byte_offset: ::std::result::Result<i64, ::std::string::String>,
            checksum: ::std::result::Result<::std::string::String, ::std::string::String>,
            chunk_index: ::std::result::Result<i32, ::std::string::String>,
            source_peer_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ChunkEntry {
            fn default() -> Self {
                Self {
                    byte_length: Err("no value supplied for byte_length".to_string()),
                    byte_offset: Err("no value supplied for byte_offset".to_string()),
                    checksum: Err("no value supplied for checksum".to_string()),
                    chunk_index: Err("no value supplied for chunk_index".to_string()),
                    source_peer_id: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl ChunkEntry {
            pub fn byte_length<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.byte_length = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for byte_length: {e}"));
                self
            }
            pub fn byte_offset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.byte_offset = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for byte_offset: {e}"));
                self
            }
            pub fn checksum<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checksum: {e}"));
                self
            }
            pub fn chunk_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.chunk_index = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunk_index: {e}"));
                self
            }
            pub fn source_peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_peer_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_peer_id: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ChunkEntry> for super::ChunkEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ChunkEntry,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    byte_length: value.byte_length?,
                    byte_offset: value.byte_offset?,
                    checksum: value.checksum?,
                    chunk_index: value.chunk_index?,
                    source_peer_id: value.source_peer_id?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::ChunkEntry> for ChunkEntry {
            fn from(value: super::ChunkEntry) -> Self {
                Self {
                    byte_length: Ok(value.byte_length),
                    byte_offset: Ok(value.byte_offset),
                    checksum: Ok(value.checksum),
                    chunk_index: Ok(value.chunk_index),
                    source_peer_id: Ok(value.source_peer_id),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ChunkManifestResponse {
            chunks:
                ::std::result::Result<::std::vec::Vec<super::ChunkEntry>, ::std::string::String>,
            session_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for ChunkManifestResponse {
            fn default() -> Self {
                Self {
                    chunks: Err("no value supplied for chunks".to_string()),
                    session_id: Err("no value supplied for session_id".to_string()),
                }
            }
        }
        impl ChunkManifestResponse {
            pub fn chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ChunkEntry>>,
                T::Error: ::std::fmt::Display,
            {
                self.chunks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunks: {e}"));
                self
            }
            pub fn session_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.session_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for session_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ChunkManifestResponse> for super::ChunkManifestResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ChunkManifestResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chunks: value.chunks?,
                    session_id: value.session_id?,
                })
            }
        }
        impl ::std::convert::From<super::ChunkManifestResponse> for ChunkManifestResponse {
            fn from(value: super::ChunkManifestResponse) -> Self {
                Self {
                    chunks: Ok(value.chunks),
                    session_id: Ok(value.session_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CleanupRequest {
            cleanup_audit_logs:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            cleanup_old_backups:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            cleanup_stale_peers:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for CleanupRequest {
            fn default() -> Self {
                Self {
                    cleanup_audit_logs: Ok(Default::default()),
                    cleanup_old_backups: Ok(Default::default()),
                    cleanup_stale_peers: Ok(Default::default()),
                }
            }
        }
        impl CleanupRequest {
            pub fn cleanup_audit_logs<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.cleanup_audit_logs = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cleanup_audit_logs: {e}")
                });
                self
            }
            pub fn cleanup_old_backups<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.cleanup_old_backups = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cleanup_old_backups: {e}")
                });
                self
            }
            pub fn cleanup_stale_peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.cleanup_stale_peers = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cleanup_stale_peers: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CleanupRequest> for super::CleanupRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CleanupRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cleanup_audit_logs: value.cleanup_audit_logs?,
                    cleanup_old_backups: value.cleanup_old_backups?,
                    cleanup_stale_peers: value.cleanup_stale_peers?,
                })
            }
        }
        impl ::std::convert::From<super::CleanupRequest> for CleanupRequest {
            fn from(value: super::CleanupRequest) -> Self {
                Self {
                    cleanup_audit_logs: Ok(value.cleanup_audit_logs),
                    cleanup_old_backups: Ok(value.cleanup_old_backups),
                    cleanup_stale_peers: Ok(value.cleanup_stale_peers),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CleanupResponse {
            audit_logs_deleted: ::std::result::Result<i64, ::std::string::String>,
            backups_deleted: ::std::result::Result<i64, ::std::string::String>,
            peers_marked_offline: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for CleanupResponse {
            fn default() -> Self {
                Self {
                    audit_logs_deleted: Err("no value supplied for audit_logs_deleted".to_string()),
                    backups_deleted: Err("no value supplied for backups_deleted".to_string()),
                    peers_marked_offline: Err(
                        "no value supplied for peers_marked_offline".to_string()
                    ),
                }
            }
        }
        impl CleanupResponse {
            pub fn audit_logs_deleted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.audit_logs_deleted = value.try_into().map_err(|e| {
                    format!("error converting supplied value for audit_logs_deleted: {e}")
                });
                self
            }
            pub fn backups_deleted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.backups_deleted = value.try_into().map_err(|e| {
                    format!("error converting supplied value for backups_deleted: {e}")
                });
                self
            }
            pub fn peers_marked_offline<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.peers_marked_offline = value.try_into().map_err(|e| {
                    format!("error converting supplied value for peers_marked_offline: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CleanupResponse> for super::CleanupResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CleanupResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    audit_logs_deleted: value.audit_logs_deleted?,
                    backups_deleted: value.backups_deleted?,
                    peers_marked_offline: value.peers_marked_offline?,
                })
            }
        }
        impl ::std::convert::From<super::CleanupResponse> for CleanupResponse {
            fn from(value: super::CleanupResponse) -> Self {
                Self {
                    audit_logs_deleted: Ok(value.audit_logs_deleted),
                    backups_deleted: Ok(value.backups_deleted),
                    peers_marked_offline: Ok(value.peers_marked_offline),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CompleteChunkBody {
            checksum: ::std::result::Result<::std::string::String, ::std::string::String>,
            source_peer_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for CompleteChunkBody {
            fn default() -> Self {
                Self {
                    checksum: Err("no value supplied for checksum".to_string()),
                    source_peer_id: Ok(Default::default()),
                }
            }
        }
        impl CompleteChunkBody {
            pub fn checksum<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checksum: {e}"));
                self
            }
            pub fn source_peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_peer_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_peer_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CompleteChunkBody> for super::CompleteChunkBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CompleteChunkBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum: value.checksum?,
                    source_peer_id: value.source_peer_id?,
                })
            }
        }
        impl ::std::convert::From<super::CompleteChunkBody> for CompleteChunkBody {
            fn from(value: super::CompleteChunkBody) -> Self {
                Self {
                    checksum: Ok(value.checksum),
                    source_peer_id: Ok(value.source_peer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ComponentResponse {
            author: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            component_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            cpe: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            md5: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            purl: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sbom_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            sha1: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sha256: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            supplier: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ComponentResponse {
            fn default() -> Self {
                Self {
                    author: Ok(Default::default()),
                    component_type: Ok(Default::default()),
                    cpe: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    licenses: Err("no value supplied for licenses".to_string()),
                    md5: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    purl: Ok(Default::default()),
                    sbom_id: Err("no value supplied for sbom_id".to_string()),
                    sha1: Ok(Default::default()),
                    sha256: Ok(Default::default()),
                    supplier: Ok(Default::default()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl ComponentResponse {
            pub fn author<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.author = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for author: {e}"));
                self
            }
            pub fn component_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.component_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_type: {e}")
                });
                self
            }
            pub fn cpe<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cpe = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cpe: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.licenses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for licenses: {e}"));
                self
            }
            pub fn md5<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.md5 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for md5: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn purl<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.purl = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for purl: {e}"));
                self
            }
            pub fn sbom_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.sbom_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sbom_id: {e}"));
                self
            }
            pub fn sha1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sha1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sha1: {e}"));
                self
            }
            pub fn sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sha256 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sha256: {e}"));
                self
            }
            pub fn supplier<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.supplier = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for supplier: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ComponentResponse> for super::ComponentResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    author: value.author?,
                    component_type: value.component_type?,
                    cpe: value.cpe?,
                    id: value.id?,
                    licenses: value.licenses?,
                    md5: value.md5?,
                    name: value.name?,
                    purl: value.purl?,
                    sbom_id: value.sbom_id?,
                    sha1: value.sha1?,
                    sha256: value.sha256?,
                    supplier: value.supplier?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::ComponentResponse> for ComponentResponse {
            fn from(value: super::ComponentResponse) -> Self {
                Self {
                    author: Ok(value.author),
                    component_type: Ok(value.component_type),
                    cpe: Ok(value.cpe),
                    id: Ok(value.id),
                    licenses: Ok(value.licenses),
                    md5: Ok(value.md5),
                    name: Ok(value.name),
                    purl: Ok(value.purl),
                    sbom_id: Ok(value.sbom_id),
                    sha1: Ok(value.sha1),
                    sha256: Ok(value.sha256),
                    supplier: Ok(value.supplier),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ConnectionCredentials {
            password: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ConnectionCredentials {
            fn default() -> Self {
                Self {
                    password: Ok(Default::default()),
                    token: Ok(Default::default()),
                    username: Ok(Default::default()),
                }
            }
        }
        impl ConnectionCredentials {
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {e}"));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {e}"));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ConnectionCredentials> for super::ConnectionCredentials {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ConnectionCredentials,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    password: value.password?,
                    token: value.token?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::ConnectionCredentials> for ConnectionCredentials {
            fn from(value: super::ConnectionCredentials) -> Self {
                Self {
                    password: Ok(value.password),
                    token: Ok(value.token),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ConnectionResponse {
            auth_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            source_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
            verified_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ConnectionResponse {
            fn default() -> Self {
                Self {
                    auth_type: Err("no value supplied for auth_type".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source_type: Err("no value supplied for source_type".to_string()),
                    url: Err("no value supplied for url".to_string()),
                    verified_at: Ok(Default::default()),
                }
            }
        }
        impl ConnectionResponse {
            pub fn auth_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.auth_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auth_type: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn source_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_type: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ConnectionResponse> for super::ConnectionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ConnectionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auth_type: value.auth_type?,
                    created_at: value.created_at?,
                    id: value.id?,
                    name: value.name?,
                    source_type: value.source_type?,
                    url: value.url?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::ConnectionResponse> for ConnectionResponse {
            fn from(value: super::ConnectionResponse) -> Self {
                Self {
                    auth_type: Ok(value.auth_type),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    source_type: Ok(value.source_type),
                    url: Ok(value.url),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ConnectionTestResult {
            artifactory_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            license_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            success: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for ConnectionTestResult {
            fn default() -> Self {
                Self {
                    artifactory_version: Ok(Default::default()),
                    license_type: Ok(Default::default()),
                    message: Err("no value supplied for message".to_string()),
                    success: Err("no value supplied for success".to_string()),
                }
            }
        }
        impl ConnectionTestResult {
            pub fn artifactory_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifactory_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifactory_version: {e}")
                });
                self
            }
            pub fn license_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.license_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for license_type: {e}"));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn success<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.success = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for success: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ConnectionTestResult> for super::ConnectionTestResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ConnectionTestResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifactory_version: value.artifactory_version?,
                    license_type: value.license_type?,
                    message: value.message?,
                    success: value.success?,
                })
            }
        }
        impl ::std::convert::From<super::ConnectionTestResult> for ConnectionTestResult {
            fn from(value: super::ConnectionTestResult) -> Self {
                Self {
                    artifactory_version: Ok(value.artifactory_version),
                    license_type: Ok(value.license_type),
                    message: Ok(value.message),
                    success: Ok(value.success),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ConvertSbomRequest {
            target_format: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ConvertSbomRequest {
            fn default() -> Self {
                Self {
                    target_format: Err("no value supplied for target_format".to_string()),
                }
            }
        }
        impl ConvertSbomRequest {
            pub fn target_format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_format: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ConvertSbomRequest> for super::ConvertSbomRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ConvertSbomRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    target_format: value.target_format?,
                })
            }
        }
        impl ::std::convert::From<super::ConvertSbomRequest> for ConvertSbomRequest {
            fn from(value: super::ConvertSbomRequest) -> Self {
                Self {
                    target_format: Ok(value.target_format),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CrashListResponse {
            items:
                ::std::result::Result<::std::vec::Vec<super::CrashReport>, ::std::string::String>,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for CrashListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl CrashListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CrashReport>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CrashListResponse> for super::CrashListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CrashListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::CrashListResponse> for CrashListResponse {
            fn from(value: super::CrashListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CrashReport {
            app_version: ::std::result::Result<::std::string::String, ::std::string::String>,
            component: ::std::result::Result<::std::string::String, ::std::string::String>,
            context: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            error_message: ::std::result::Result<::std::string::String, ::std::string::String>,
            error_signature: ::std::result::Result<::std::string::String, ::std::string::String>,
            error_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            first_seen_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_seen_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            occurrence_count: ::std::result::Result<i32, ::std::string::String>,
            os_info: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            stack_trace: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            submission_error: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            submitted: ::std::result::Result<bool, ::std::string::String>,
            submitted_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            uptime_seconds:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for CrashReport {
            fn default() -> Self {
                Self {
                    app_version: Err("no value supplied for app_version".to_string()),
                    component: Err("no value supplied for component".to_string()),
                    context: Err("no value supplied for context".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    error_message: Err("no value supplied for error_message".to_string()),
                    error_signature: Err("no value supplied for error_signature".to_string()),
                    error_type: Err("no value supplied for error_type".to_string()),
                    first_seen_at: Err("no value supplied for first_seen_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    last_seen_at: Err("no value supplied for last_seen_at".to_string()),
                    occurrence_count: Err("no value supplied for occurrence_count".to_string()),
                    os_info: Ok(Default::default()),
                    severity: Err("no value supplied for severity".to_string()),
                    stack_trace: Ok(Default::default()),
                    submission_error: Ok(Default::default()),
                    submitted: Err("no value supplied for submitted".to_string()),
                    submitted_at: Ok(Default::default()),
                    uptime_seconds: Ok(Default::default()),
                }
            }
        }
        impl CrashReport {
            pub fn app_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.app_version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for app_version: {e}"));
                self
            }
            pub fn component<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.component = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for component: {e}"));
                self
            }
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for context: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_message: {e}"));
                self
            }
            pub fn error_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.error_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for error_signature: {e}")
                });
                self
            }
            pub fn error_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.error_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_type: {e}"));
                self
            }
            pub fn first_seen_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_seen_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first_seen_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn last_seen_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_seen_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_seen_at: {e}"));
                self
            }
            pub fn occurrence_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.occurrence_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for occurrence_count: {e}")
                });
                self
            }
            pub fn os_info<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.os_info = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for os_info: {e}"));
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
            pub fn stack_trace<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.stack_trace = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for stack_trace: {e}"));
                self
            }
            pub fn submission_error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.submission_error = value.try_into().map_err(|e| {
                    format!("error converting supplied value for submission_error: {e}")
                });
                self
            }
            pub fn submitted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.submitted = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for submitted: {e}"));
                self
            }
            pub fn submitted_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.submitted_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for submitted_at: {e}"));
                self
            }
            pub fn uptime_seconds<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.uptime_seconds = value.try_into().map_err(|e| {
                    format!("error converting supplied value for uptime_seconds: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CrashReport> for super::CrashReport {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CrashReport,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    app_version: value.app_version?,
                    component: value.component?,
                    context: value.context?,
                    created_at: value.created_at?,
                    error_message: value.error_message?,
                    error_signature: value.error_signature?,
                    error_type: value.error_type?,
                    first_seen_at: value.first_seen_at?,
                    id: value.id?,
                    last_seen_at: value.last_seen_at?,
                    occurrence_count: value.occurrence_count?,
                    os_info: value.os_info?,
                    severity: value.severity?,
                    stack_trace: value.stack_trace?,
                    submission_error: value.submission_error?,
                    submitted: value.submitted?,
                    submitted_at: value.submitted_at?,
                    uptime_seconds: value.uptime_seconds?,
                })
            }
        }
        impl ::std::convert::From<super::CrashReport> for CrashReport {
            fn from(value: super::CrashReport) -> Self {
                Self {
                    app_version: Ok(value.app_version),
                    component: Ok(value.component),
                    context: Ok(value.context),
                    created_at: Ok(value.created_at),
                    error_message: Ok(value.error_message),
                    error_signature: Ok(value.error_signature),
                    error_type: Ok(value.error_type),
                    first_seen_at: Ok(value.first_seen_at),
                    id: Ok(value.id),
                    last_seen_at: Ok(value.last_seen_at),
                    occurrence_count: Ok(value.occurrence_count),
                    os_info: Ok(value.os_info),
                    severity: Ok(value.severity),
                    stack_trace: Ok(value.stack_trace),
                    submission_error: Ok(value.submission_error),
                    submitted: Ok(value.submitted),
                    submitted_at: Ok(value.submitted_at),
                    uptime_seconds: Ok(value.uptime_seconds),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateApiTokenRequest {
            expires_in_days:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            scopes: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateApiTokenRequest {
            fn default() -> Self {
                Self {
                    expires_in_days: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    scopes: Err("no value supplied for scopes".to_string()),
                }
            }
        }
        impl CreateApiTokenRequest {
            pub fn expires_in_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.expires_in_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for expires_in_days: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn scopes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.scopes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scopes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateApiTokenRequest> for super::CreateApiTokenRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateApiTokenRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    expires_in_days: value.expires_in_days?,
                    name: value.name?,
                    scopes: value.scopes?,
                })
            }
        }
        impl ::std::convert::From<super::CreateApiTokenRequest> for CreateApiTokenRequest {
            fn from(value: super::CreateApiTokenRequest) -> Self {
                Self {
                    expires_in_days: Ok(value.expires_in_days),
                    name: Ok(value.name),
                    scopes: Ok(value.scopes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateApiTokenResponse {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            token: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateApiTokenResponse {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl CreateApiTokenResponse {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateApiTokenResponse> for super::CreateApiTokenResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateApiTokenResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::CreateApiTokenResponse> for CreateApiTokenResponse {
            fn from(value: super::CreateApiTokenResponse) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateBackupRequest {
            repository_ids: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::uuid::Uuid>>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateBackupRequest {
            fn default() -> Self {
                Self {
                    repository_ids: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl CreateBackupRequest {
            pub fn repository_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::vec::Vec<::uuid::Uuid>>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_ids = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_ids: {e}")
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateBackupRequest> for super::CreateBackupRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateBackupRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    repository_ids: value.repository_ids?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::CreateBackupRequest> for CreateBackupRequest {
            fn from(value: super::CreateBackupRequest) -> Self {
                Self {
                    repository_ids: Ok(value.repository_ids),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateBuildRequest {
            agent: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            build_number: ::std::result::Result<i32, ::std::string::String>,
            metadata: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            vcs_branch: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            vcs_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            vcs_revision: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            vcs_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateBuildRequest {
            fn default() -> Self {
                Self {
                    agent: Ok(Default::default()),
                    build_number: Err("no value supplied for build_number".to_string()),
                    metadata: Err("no value supplied for metadata".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    started_at: Ok(Default::default()),
                    vcs_branch: Ok(Default::default()),
                    vcs_message: Ok(Default::default()),
                    vcs_revision: Ok(Default::default()),
                    vcs_url: Ok(Default::default()),
                }
            }
        }
        impl CreateBuildRequest {
            pub fn agent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.agent = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for agent: {e}"));
                self
            }
            pub fn build_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.build_number = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for build_number: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn vcs_branch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_branch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_branch: {e}"));
                self
            }
            pub fn vcs_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_message: {e}"));
                self
            }
            pub fn vcs_revision<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_revision = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_revision: {e}"));
                self
            }
            pub fn vcs_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vcs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vcs_url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateBuildRequest> for super::CreateBuildRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateBuildRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    agent: value.agent?,
                    build_number: value.build_number?,
                    metadata: value.metadata?,
                    name: value.name?,
                    started_at: value.started_at?,
                    vcs_branch: value.vcs_branch?,
                    vcs_message: value.vcs_message?,
                    vcs_revision: value.vcs_revision?,
                    vcs_url: value.vcs_url?,
                })
            }
        }
        impl ::std::convert::From<super::CreateBuildRequest> for CreateBuildRequest {
            fn from(value: super::CreateBuildRequest) -> Self {
                Self {
                    agent: Ok(value.agent),
                    build_number: Ok(value.build_number),
                    metadata: Ok(value.metadata),
                    name: Ok(value.name),
                    started_at: Ok(value.started_at),
                    vcs_branch: Ok(value.vcs_branch),
                    vcs_message: Ok(value.vcs_message),
                    vcs_revision: Ok(value.vcs_revision),
                    vcs_url: Ok(value.vcs_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateConnectionRequest {
            auth_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            credentials: ::std::result::Result<super::ConnectionCredentials, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            source_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateConnectionRequest {
            fn default() -> Self {
                Self {
                    auth_type: Err("no value supplied for auth_type".to_string()),
                    credentials: Err("no value supplied for credentials".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source_type: Ok(Default::default()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl CreateConnectionRequest {
            pub fn auth_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.auth_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auth_type: {e}"));
                self
            }
            pub fn credentials<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConnectionCredentials>,
                T::Error: ::std::fmt::Display,
            {
                self.credentials = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for credentials: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn source_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_type: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateConnectionRequest> for super::CreateConnectionRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateConnectionRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auth_type: value.auth_type?,
                    credentials: value.credentials?,
                    name: value.name?,
                    source_type: value.source_type?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::CreateConnectionRequest> for CreateConnectionRequest {
            fn from(value: super::CreateConnectionRequest) -> Self {
                Self {
                    auth_type: Ok(value.auth_type),
                    credentials: Ok(value.credentials),
                    name: Ok(value.name),
                    source_type: Ok(value.source_type),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateGateRequest {
            action: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enforce_on_download:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            enforce_on_promotion:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            max_critical_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_high_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_medium_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_health_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_metadata_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_quality_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_security_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            required_checks: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateGateRequest {
            fn default() -> Self {
                Self {
                    action: Ok(Default::default()),
                    description: Ok(Default::default()),
                    enforce_on_download: Ok(Default::default()),
                    enforce_on_promotion: Ok(Default::default()),
                    max_critical_issues: Ok(Default::default()),
                    max_high_issues: Ok(Default::default()),
                    max_medium_issues: Ok(Default::default()),
                    min_health_score: Ok(Default::default()),
                    min_metadata_score: Ok(Default::default()),
                    min_quality_score: Ok(Default::default()),
                    min_security_score: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    required_checks: Ok(Default::default()),
                }
            }
        }
        impl CreateGateRequest {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enforce_on_download<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_on_download = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enforce_on_download: {e}")
                });
                self
            }
            pub fn enforce_on_promotion<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_on_promotion = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enforce_on_promotion: {e}")
                });
                self
            }
            pub fn max_critical_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_critical_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_critical_issues: {e}")
                });
                self
            }
            pub fn max_high_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_high_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_high_issues: {e}")
                });
                self
            }
            pub fn max_medium_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_medium_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_medium_issues: {e}")
                });
                self
            }
            pub fn min_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_health_score: {e}")
                });
                self
            }
            pub fn min_metadata_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_metadata_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_metadata_score: {e}")
                });
                self
            }
            pub fn min_quality_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_quality_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_quality_score: {e}")
                });
                self
            }
            pub fn min_security_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_security_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_security_score: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn required_checks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.required_checks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for required_checks: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateGateRequest> for super::CreateGateRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateGateRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    enforce_on_download: value.enforce_on_download?,
                    enforce_on_promotion: value.enforce_on_promotion?,
                    max_critical_issues: value.max_critical_issues?,
                    max_high_issues: value.max_high_issues?,
                    max_medium_issues: value.max_medium_issues?,
                    min_health_score: value.min_health_score?,
                    min_metadata_score: value.min_metadata_score?,
                    min_quality_score: value.min_quality_score?,
                    min_security_score: value.min_security_score?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    required_checks: value.required_checks?,
                })
            }
        }
        impl ::std::convert::From<super::CreateGateRequest> for CreateGateRequest {
            fn from(value: super::CreateGateRequest) -> Self {
                Self {
                    action: Ok(value.action),
                    description: Ok(value.description),
                    enforce_on_download: Ok(value.enforce_on_download),
                    enforce_on_promotion: Ok(value.enforce_on_promotion),
                    max_critical_issues: Ok(value.max_critical_issues),
                    max_high_issues: Ok(value.max_high_issues),
                    max_medium_issues: Ok(value.max_medium_issues),
                    min_health_score: Ok(value.min_health_score),
                    min_metadata_score: Ok(value.min_metadata_score),
                    min_quality_score: Ok(value.min_quality_score),
                    min_security_score: Ok(value.min_security_score),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    required_checks: Ok(value.required_checks),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateGroupRequest {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateGroupRequest {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl CreateGroupRequest {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateGroupRequest> for super::CreateGroupRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateGroupRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::CreateGroupRequest> for CreateGroupRequest {
            fn from(value: super::CreateGroupRequest) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateInstanceRequest {
            api_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateInstanceRequest {
            fn default() -> Self {
                Self {
                    api_key: Err("no value supplied for api_key".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl CreateInstanceRequest {
            pub fn api_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.api_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for api_key: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateInstanceRequest> for super::CreateInstanceRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateInstanceRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    api_key: value.api_key?,
                    name: value.name?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::CreateInstanceRequest> for CreateInstanceRequest {
            fn from(value: super::CreateInstanceRequest) -> Self {
                Self {
                    api_key: Ok(value.api_key),
                    name: Ok(value.name),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateKeyPayload {
            algorithm: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            key_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            uid_email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            uid_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateKeyPayload {
            fn default() -> Self {
                Self {
                    algorithm: Ok(Default::default()),
                    key_type: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    uid_email: Ok(Default::default()),
                    uid_name: Ok(Default::default()),
                }
            }
        }
        impl CreateKeyPayload {
            pub fn algorithm<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.algorithm = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for algorithm: {e}"));
                self
            }
            pub fn key_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.key_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key_type: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn uid_email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.uid_email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid_email: {e}"));
                self
            }
            pub fn uid_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.uid_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid_name: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateKeyPayload> for super::CreateKeyPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateKeyPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    algorithm: value.algorithm?,
                    key_type: value.key_type?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    uid_email: value.uid_email?,
                    uid_name: value.uid_name?,
                })
            }
        }
        impl ::std::convert::From<super::CreateKeyPayload> for CreateKeyPayload {
            fn from(value: super::CreateKeyPayload) -> Self {
                Self {
                    algorithm: Ok(value.algorithm),
                    key_type: Ok(value.key_type),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    uid_email: Ok(value.uid_email),
                    uid_name: Ok(value.uid_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateLdapConfigRequest {
            admin_group_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bind_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bind_password: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            display_name_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            group_base_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            group_filter: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            groups_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            priority: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            server_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            use_starttls: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            user_base_dn: ::std::result::Result<::std::string::String, ::std::string::String>,
            user_filter: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            username_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateLdapConfigRequest {
            fn default() -> Self {
                Self {
                    admin_group_dn: Ok(Default::default()),
                    bind_dn: Ok(Default::default()),
                    bind_password: Ok(Default::default()),
                    display_name_attribute: Ok(Default::default()),
                    email_attribute: Ok(Default::default()),
                    group_base_dn: Ok(Default::default()),
                    group_filter: Ok(Default::default()),
                    groups_attribute: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Ok(Default::default()),
                    server_url: Err("no value supplied for server_url".to_string()),
                    use_starttls: Ok(Default::default()),
                    user_base_dn: Err("no value supplied for user_base_dn".to_string()),
                    user_filter: Ok(Default::default()),
                    username_attribute: Ok(Default::default()),
                }
            }
        }
        impl CreateLdapConfigRequest {
            pub fn admin_group_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group_dn = value.try_into().map_err(|e| {
                    format!("error converting supplied value for admin_group_dn: {e}")
                });
                self
            }
            pub fn bind_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bind_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bind_dn: {e}"));
                self
            }
            pub fn bind_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bind_password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bind_password: {e}"));
                self
            }
            pub fn display_name_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name_attribute: {e}")
                });
                self
            }
            pub fn email_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for email_attribute: {e}")
                });
                self
            }
            pub fn group_base_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_base_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group_base_dn: {e}"));
                self
            }
            pub fn group_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group_filter: {e}"));
                self
            }
            pub fn groups_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.groups_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for groups_attribute: {e}")
                });
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn server_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.server_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for server_url: {e}"));
                self
            }
            pub fn use_starttls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.use_starttls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for use_starttls: {e}"));
                self
            }
            pub fn user_base_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_base_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_base_dn: {e}"));
                self
            }
            pub fn user_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.user_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_filter: {e}"));
                self
            }
            pub fn username_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for username_attribute: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateLdapConfigRequest> for super::CreateLdapConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateLdapConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group_dn: value.admin_group_dn?,
                    bind_dn: value.bind_dn?,
                    bind_password: value.bind_password?,
                    display_name_attribute: value.display_name_attribute?,
                    email_attribute: value.email_attribute?,
                    group_base_dn: value.group_base_dn?,
                    group_filter: value.group_filter?,
                    groups_attribute: value.groups_attribute?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    priority: value.priority?,
                    server_url: value.server_url?,
                    use_starttls: value.use_starttls?,
                    user_base_dn: value.user_base_dn?,
                    user_filter: value.user_filter?,
                    username_attribute: value.username_attribute?,
                })
            }
        }
        impl ::std::convert::From<super::CreateLdapConfigRequest> for CreateLdapConfigRequest {
            fn from(value: super::CreateLdapConfigRequest) -> Self {
                Self {
                    admin_group_dn: Ok(value.admin_group_dn),
                    bind_dn: Ok(value.bind_dn),
                    bind_password: Ok(value.bind_password),
                    display_name_attribute: Ok(value.display_name_attribute),
                    email_attribute: Ok(value.email_attribute),
                    group_base_dn: Ok(value.group_base_dn),
                    group_filter: Ok(value.group_filter),
                    groups_attribute: Ok(value.groups_attribute),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    server_url: Ok(value.server_url),
                    use_starttls: Ok(value.use_starttls),
                    user_base_dn: Ok(value.user_base_dn),
                    user_filter: Ok(value.user_filter),
                    username_attribute: Ok(value.username_attribute),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateMigrationRequest {
            config: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            job_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            source_connection_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for CreateMigrationRequest {
            fn default() -> Self {
                Self {
                    config: Err("no value supplied for config".to_string()),
                    job_type: Ok(Default::default()),
                    source_connection_id: Err(
                        "no value supplied for source_connection_id".to_string()
                    ),
                }
            }
        }
        impl CreateMigrationRequest {
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
            pub fn job_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.job_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_type: {e}"));
                self
            }
            pub fn source_connection_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.source_connection_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_connection_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateMigrationRequest> for super::CreateMigrationRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateMigrationRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    config: value.config?,
                    job_type: value.job_type?,
                    source_connection_id: value.source_connection_id?,
                })
            }
        }
        impl ::std::convert::From<super::CreateMigrationRequest> for CreateMigrationRequest {
            fn from(value: super::CreateMigrationRequest) -> Self {
                Self {
                    config: Ok(value.config),
                    job_type: Ok(value.job_type),
                    source_connection_id: Ok(value.source_connection_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateOidcConfigRequest {
            attribute_mapping: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            auto_create_users:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            client_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            client_secret: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            issuer_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            scopes: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateOidcConfigRequest {
            fn default() -> Self {
                Self {
                    attribute_mapping: Ok(Default::default()),
                    auto_create_users: Ok(Default::default()),
                    client_id: Err("no value supplied for client_id".to_string()),
                    client_secret: Err("no value supplied for client_secret".to_string()),
                    is_enabled: Ok(Default::default()),
                    issuer_url: Err("no value supplied for issuer_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    scopes: Ok(Default::default()),
                }
            }
        }
        impl CreateOidcConfigRequest {
            pub fn attribute_mapping<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.attribute_mapping = value.try_into().map_err(|e| {
                    format!("error converting supplied value for attribute_mapping: {e}")
                });
                self
            }
            pub fn auto_create_users<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_create_users = value.try_into().map_err(|e| {
                    format!("error converting supplied value for auto_create_users: {e}")
                });
                self
            }
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {e}"));
                self
            }
            pub fn client_secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.client_secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_secret: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn issuer_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.issuer_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issuer_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn scopes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.scopes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scopes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateOidcConfigRequest> for super::CreateOidcConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateOidcConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    attribute_mapping: value.attribute_mapping?,
                    auto_create_users: value.auto_create_users?,
                    client_id: value.client_id?,
                    client_secret: value.client_secret?,
                    is_enabled: value.is_enabled?,
                    issuer_url: value.issuer_url?,
                    name: value.name?,
                    scopes: value.scopes?,
                })
            }
        }
        impl ::std::convert::From<super::CreateOidcConfigRequest> for CreateOidcConfigRequest {
            fn from(value: super::CreateOidcConfigRequest) -> Self {
                Self {
                    attribute_mapping: Ok(value.attribute_mapping),
                    auto_create_users: Ok(value.auto_create_users),
                    client_id: Ok(value.client_id),
                    client_secret: Ok(value.client_secret),
                    is_enabled: Ok(value.is_enabled),
                    issuer_url: Ok(value.issuer_url),
                    name: Ok(value.name),
                    scopes: Ok(value.scopes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreatePermissionRequest {
            actions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            principal_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target_type: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreatePermissionRequest {
            fn default() -> Self {
                Self {
                    actions: Err("no value supplied for actions".to_string()),
                    principal_id: Err("no value supplied for principal_id".to_string()),
                    principal_type: Err("no value supplied for principal_type".to_string()),
                    target_id: Err("no value supplied for target_id".to_string()),
                    target_type: Err("no value supplied for target_type".to_string()),
                }
            }
        }
        impl CreatePermissionRequest {
            pub fn actions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.actions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for actions: {e}"));
                self
            }
            pub fn principal_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for principal_id: {e}"));
                self
            }
            pub fn principal_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for principal_type: {e}")
                });
                self
            }
            pub fn target_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_id: {e}"));
                self
            }
            pub fn target_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_type: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreatePermissionRequest> for super::CreatePermissionRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreatePermissionRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    actions: value.actions?,
                    principal_id: value.principal_id?,
                    principal_type: value.principal_type?,
                    target_id: value.target_id?,
                    target_type: value.target_type?,
                })
            }
        }
        impl ::std::convert::From<super::CreatePermissionRequest> for CreatePermissionRequest {
            fn from(value: super::CreatePermissionRequest) -> Self {
                Self {
                    actions: Ok(value.actions),
                    principal_id: Ok(value.principal_id),
                    principal_type: Ok(value.principal_type),
                    target_id: Ok(value.target_id),
                    target_type: Ok(value.target_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreatePolicyRequest {
            block_on_fail: ::std::result::Result<bool, ::std::string::String>,
            block_unscanned: ::std::result::Result<bool, ::std::string::String>,
            max_artifact_age_days:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            min_staging_hours:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            require_signature:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for CreatePolicyRequest {
            fn default() -> Self {
                Self {
                    block_on_fail: Err("no value supplied for block_on_fail".to_string()),
                    block_unscanned: Err("no value supplied for block_unscanned".to_string()),
                    max_artifact_age_days: Ok(Default::default()),
                    max_severity: Err("no value supplied for max_severity".to_string()),
                    min_staging_hours: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    require_signature: Ok(Default::default()),
                }
            }
        }
        impl CreatePolicyRequest {
            pub fn block_on_fail<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_on_fail = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_on_fail: {e}"));
                self
            }
            pub fn block_unscanned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_unscanned = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_unscanned: {e}")
                });
                self
            }
            pub fn max_artifact_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_artifact_age_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_artifact_age_days: {e}")
                });
                self
            }
            pub fn max_severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.max_severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max_severity: {e}"));
                self
            }
            pub fn min_staging_hours<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_staging_hours = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_staging_hours: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn require_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signature: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreatePolicyRequest> for super::CreatePolicyRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreatePolicyRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_on_fail: value.block_on_fail?,
                    block_unscanned: value.block_unscanned?,
                    max_artifact_age_days: value.max_artifact_age_days?,
                    max_severity: value.max_severity?,
                    min_staging_hours: value.min_staging_hours?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    require_signature: value.require_signature?,
                })
            }
        }
        impl ::std::convert::From<super::CreatePolicyRequest> for CreatePolicyRequest {
            fn from(value: super::CreatePolicyRequest) -> Self {
                Self {
                    block_on_fail: Ok(value.block_on_fail),
                    block_unscanned: Ok(value.block_unscanned),
                    max_artifact_age_days: Ok(value.max_artifact_age_days),
                    max_severity: Ok(value.max_severity),
                    min_staging_hours: Ok(value.min_staging_hours),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    require_signature: Ok(value.require_signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateRepositoryRequest {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_public: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            quota_bytes: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            repo_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            upstream_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateRepositoryRequest {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    format: Err("no value supplied for format".to_string()),
                    is_public: Ok(Default::default()),
                    key: Err("no value supplied for key".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    quota_bytes: Ok(Default::default()),
                    repo_type: Err("no value supplied for repo_type".to_string()),
                    upstream_url: Ok(Default::default()),
                }
            }
        }
        impl CreateRepositoryRequest {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn is_public<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_public = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_public: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn quota_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.quota_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for quota_bytes: {e}"));
                self
            }
            pub fn repo_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repo_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repo_type: {e}"));
                self
            }
            pub fn upstream_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.upstream_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for upstream_url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateRepositoryRequest> for super::CreateRepositoryRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateRepositoryRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    format: value.format?,
                    is_public: value.is_public?,
                    key: value.key?,
                    name: value.name?,
                    quota_bytes: value.quota_bytes?,
                    repo_type: value.repo_type?,
                    upstream_url: value.upstream_url?,
                })
            }
        }
        impl ::std::convert::From<super::CreateRepositoryRequest> for CreateRepositoryRequest {
            fn from(value: super::CreateRepositoryRequest) -> Self {
                Self {
                    description: Ok(value.description),
                    format: Ok(value.format),
                    is_public: Ok(value.is_public),
                    key: Ok(value.key),
                    name: Ok(value.name),
                    quota_bytes: Ok(value.quota_bytes),
                    repo_type: Ok(value.repo_type),
                    upstream_url: Ok(value.upstream_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateRuleRequest {
            allowed_licenses: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
            auto_promote: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            max_artifact_age_days:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_cve_severity: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            min_health_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_staging_hours:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            require_signature:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            source_repo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target_repo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for CreateRuleRequest {
            fn default() -> Self {
                Self {
                    allowed_licenses: Ok(Default::default()),
                    auto_promote: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    max_artifact_age_days: Ok(Default::default()),
                    max_cve_severity: Ok(Default::default()),
                    min_health_score: Ok(Default::default()),
                    min_staging_hours: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    require_signature: Ok(Default::default()),
                    source_repo_id: Err("no value supplied for source_repo_id".to_string()),
                    target_repo_id: Err("no value supplied for target_repo_id".to_string()),
                }
            }
        }
        impl CreateRuleRequest {
            pub fn allowed_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_licenses: {e}")
                });
                self
            }
            pub fn auto_promote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_promote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auto_promote: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_artifact_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_artifact_age_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_artifact_age_days: {e}")
                });
                self
            }
            pub fn max_cve_severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_cve_severity = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_cve_severity: {e}")
                });
                self
            }
            pub fn min_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_health_score: {e}")
                });
                self
            }
            pub fn min_staging_hours<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_staging_hours = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_staging_hours: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn require_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signature: {e}")
                });
                self
            }
            pub fn source_repo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repo_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repo_id: {e}")
                });
                self
            }
            pub fn target_repo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repo_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repo_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateRuleRequest> for super::CreateRuleRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateRuleRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowed_licenses: value.allowed_licenses?,
                    auto_promote: value.auto_promote?,
                    is_enabled: value.is_enabled?,
                    max_artifact_age_days: value.max_artifact_age_days?,
                    max_cve_severity: value.max_cve_severity?,
                    min_health_score: value.min_health_score?,
                    min_staging_hours: value.min_staging_hours?,
                    name: value.name?,
                    require_signature: value.require_signature?,
                    source_repo_id: value.source_repo_id?,
                    target_repo_id: value.target_repo_id?,
                })
            }
        }
        impl ::std::convert::From<super::CreateRuleRequest> for CreateRuleRequest {
            fn from(value: super::CreateRuleRequest) -> Self {
                Self {
                    allowed_licenses: Ok(value.allowed_licenses),
                    auto_promote: Ok(value.auto_promote),
                    is_enabled: Ok(value.is_enabled),
                    max_artifact_age_days: Ok(value.max_artifact_age_days),
                    max_cve_severity: Ok(value.max_cve_severity),
                    min_health_score: Ok(value.min_health_score),
                    min_staging_hours: Ok(value.min_staging_hours),
                    name: Ok(value.name),
                    require_signature: Ok(value.require_signature),
                    source_repo_id: Ok(value.source_repo_id),
                    target_repo_id: Ok(value.target_repo_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSamlConfigRequest {
            admin_group: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            attribute_mapping: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            certificate: ::std::result::Result<::std::string::String, ::std::string::String>,
            entity_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            name_id_format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            require_signed_assertions:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            sign_requests:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            slo_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sp_entity_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sso_url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateSamlConfigRequest {
            fn default() -> Self {
                Self {
                    admin_group: Ok(Default::default()),
                    attribute_mapping: Ok(Default::default()),
                    certificate: Err("no value supplied for certificate".to_string()),
                    entity_id: Err("no value supplied for entity_id".to_string()),
                    is_enabled: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    name_id_format: Ok(Default::default()),
                    require_signed_assertions: Ok(Default::default()),
                    sign_requests: Ok(Default::default()),
                    slo_url: Ok(Default::default()),
                    sp_entity_id: Ok(Default::default()),
                    sso_url: Err("no value supplied for sso_url".to_string()),
                }
            }
        }
        impl CreateSamlConfigRequest {
            pub fn admin_group<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for admin_group: {e}"));
                self
            }
            pub fn attribute_mapping<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.attribute_mapping = value.try_into().map_err(|e| {
                    format!("error converting supplied value for attribute_mapping: {e}")
                });
                self
            }
            pub fn certificate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.certificate = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for certificate: {e}"));
                self
            }
            pub fn entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.entity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for entity_id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn name_id_format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name_id_format = value.try_into().map_err(|e| {
                    format!("error converting supplied value for name_id_format: {e}")
                });
                self
            }
            pub fn require_signed_assertions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signed_assertions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signed_assertions: {e}")
                });
                self
            }
            pub fn sign_requests<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_requests = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_requests: {e}"));
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {e}"));
                self
            }
            pub fn sp_entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sp_entity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sp_entity_id: {e}"));
                self
            }
            pub fn sso_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sso_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sso_url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSamlConfigRequest> for super::CreateSamlConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSamlConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group: value.admin_group?,
                    attribute_mapping: value.attribute_mapping?,
                    certificate: value.certificate?,
                    entity_id: value.entity_id?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    name_id_format: value.name_id_format?,
                    require_signed_assertions: value.require_signed_assertions?,
                    sign_requests: value.sign_requests?,
                    slo_url: value.slo_url?,
                    sp_entity_id: value.sp_entity_id?,
                    sso_url: value.sso_url?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSamlConfigRequest> for CreateSamlConfigRequest {
            fn from(value: super::CreateSamlConfigRequest) -> Self {
                Self {
                    admin_group: Ok(value.admin_group),
                    attribute_mapping: Ok(value.attribute_mapping),
                    certificate: Ok(value.certificate),
                    entity_id: Ok(value.entity_id),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    name_id_format: Ok(value.name_id_format),
                    require_signed_assertions: Ok(value.require_signed_assertions),
                    sign_requests: Ok(value.sign_requests),
                    slo_url: Ok(value.slo_url),
                    sp_entity_id: Ok(value.sp_entity_id),
                    sso_url: Ok(value.sso_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSyncPolicyPayload {
            artifact_filter: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            precedence: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            priority: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            replication_mode: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repo_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSyncPolicyPayload {
            fn default() -> Self {
                Self {
                    artifact_filter: Ok(Default::default()),
                    description: Ok(Default::default()),
                    enabled: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    peer_selector: Ok(Default::default()),
                    precedence: Ok(Default::default()),
                    priority: Ok(Default::default()),
                    replication_mode: Ok(Default::default()),
                    repo_selector: Ok(Default::default()),
                }
            }
        }
        impl CreateSyncPolicyPayload {
            pub fn artifact_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_filter = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_filter: {e}")
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.peer_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_selector: {e}"));
                self
            }
            pub fn precedence<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.precedence = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for precedence: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn replication_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.replication_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for replication_mode: {e}")
                });
                self
            }
            pub fn repo_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.repo_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repo_selector: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSyncPolicyPayload> for super::CreateSyncPolicyPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSyncPolicyPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_filter: value.artifact_filter?,
                    description: value.description?,
                    enabled: value.enabled?,
                    name: value.name?,
                    peer_selector: value.peer_selector?,
                    precedence: value.precedence?,
                    priority: value.priority?,
                    replication_mode: value.replication_mode?,
                    repo_selector: value.repo_selector?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSyncPolicyPayload> for CreateSyncPolicyPayload {
            fn from(value: super::CreateSyncPolicyPayload) -> Self {
                Self {
                    artifact_filter: Ok(value.artifact_filter),
                    description: Ok(value.description),
                    enabled: Ok(value.enabled),
                    name: Ok(value.name),
                    peer_selector: Ok(value.peer_selector),
                    precedence: Ok(value.precedence),
                    priority: Ok(value.priority),
                    replication_mode: Ok(value.replication_mode),
                    repo_selector: Ok(value.repo_selector),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateTicketRequest {
            purpose: ::std::result::Result<::std::string::String, ::std::string::String>,
            resource_path: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateTicketRequest {
            fn default() -> Self {
                Self {
                    purpose: Err("no value supplied for purpose".to_string()),
                    resource_path: Ok(Default::default()),
                }
            }
        }
        impl CreateTicketRequest {
            pub fn purpose<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purpose = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for purpose: {e}"));
                self
            }
            pub fn resource_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.resource_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for resource_path: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateTicketRequest> for super::CreateTicketRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateTicketRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    purpose: value.purpose?,
                    resource_path: value.resource_path?,
                })
            }
        }
        impl ::std::convert::From<super::CreateTicketRequest> for CreateTicketRequest {
            fn from(value: super::CreateTicketRequest) -> Self {
                Self {
                    purpose: Ok(value.purpose),
                    resource_path: Ok(value.resource_path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserRequest {
            display_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_admin: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            password: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            username: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateUserRequest {
            fn default() -> Self {
                Self {
                    display_name: Ok(Default::default()),
                    email: Err("no value supplied for email".to_string()),
                    is_admin: Ok(Default::default()),
                    password: Ok(Default::default()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl CreateUserRequest {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {e}"));
                self
            }
            pub fn is_admin<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_admin = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_admin: {e}"));
                self
            }
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {e}"));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserRequest> for super::CreateUserRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    email: value.email?,
                    is_admin: value.is_admin?,
                    password: value.password?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserRequest> for CreateUserRequest {
            fn from(value: super::CreateUserRequest) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    email: Ok(value.email),
                    is_admin: Ok(value.is_admin),
                    password: Ok(value.password),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserResponse {
            generated_password: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            user: ::std::result::Result<super::AdminUserResponse, ::std::string::String>,
        }
        impl ::std::default::Default for CreateUserResponse {
            fn default() -> Self {
                Self {
                    generated_password: Ok(Default::default()),
                    user: Err("no value supplied for user".to_string()),
                }
            }
        }
        impl CreateUserResponse {
            pub fn generated_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.generated_password = value.try_into().map_err(|e| {
                    format!("error converting supplied value for generated_password: {e}")
                });
                self
            }
            pub fn user<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AdminUserResponse>,
                T::Error: ::std::fmt::Display,
            {
                self.user = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserResponse> for super::CreateUserResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    generated_password: value.generated_password?,
                    user: value.user?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserResponse> for CreateUserResponse {
            fn from(value: super::CreateUserResponse) -> Self {
                Self {
                    generated_password: Ok(value.generated_password),
                    user: Ok(value.user),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateWebhookRequest {
            events: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            headers: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            secret: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateWebhookRequest {
            fn default() -> Self {
                Self {
                    events: Err("no value supplied for events".to_string()),
                    headers: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    secret: Ok(Default::default()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl CreateWebhookRequest {
            pub fn events<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.events = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for events: {e}"));
                self
            }
            pub fn headers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.headers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for headers: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateWebhookRequest> for super::CreateWebhookRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateWebhookRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    events: value.events?,
                    headers: value.headers?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    secret: value.secret?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::CreateWebhookRequest> for CreateWebhookRequest {
            fn from(value: super::CreateWebhookRequest) -> Self {
                Self {
                    events: Ok(value.events),
                    headers: Ok(value.headers),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    secret: Ok(value.secret),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreatedGroupRow {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreatedGroupRow {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl CreatedGroupRow {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreatedGroupRow> for super::CreatedGroupRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreatedGroupRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::CreatedGroupRow> for CreatedGroupRow {
            fn from(value: super::CreatedGroupRow) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreatedPermissionRow {
            actions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreatedPermissionRow {
            fn default() -> Self {
                Self {
                    actions: Err("no value supplied for actions".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    principal_id: Err("no value supplied for principal_id".to_string()),
                    principal_type: Err("no value supplied for principal_type".to_string()),
                    target_id: Err("no value supplied for target_id".to_string()),
                    target_type: Err("no value supplied for target_type".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl CreatedPermissionRow {
            pub fn actions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.actions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for actions: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn principal_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for principal_id: {e}"));
                self
            }
            pub fn principal_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for principal_type: {e}")
                });
                self
            }
            pub fn target_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_id: {e}"));
                self
            }
            pub fn target_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_type: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CreatedPermissionRow> for super::CreatedPermissionRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreatedPermissionRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    actions: value.actions?,
                    created_at: value.created_at?,
                    id: value.id?,
                    principal_id: value.principal_id?,
                    principal_type: value.principal_type?,
                    target_id: value.target_id?,
                    target_type: value.target_type?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::CreatedPermissionRow> for CreatedPermissionRow {
            fn from(value: super::CreatedPermissionRow) -> Self {
                Self {
                    actions: Ok(value.actions),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    principal_id: Ok(value.principal_id),
                    principal_type: Ok(value.principal_type),
                    target_id: Ok(value.target_id),
                    target_type: Ok(value.target_type),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CveHistoryEntry {
            acknowledged_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            acknowledged_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            acknowledged_reason: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            affected_component: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            affected_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            component_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            cve_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            cve_published_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            cvss_score: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            first_detected_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            fixed_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_detected_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sbom_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            scan_result_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            severity: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CveHistoryEntry {
            fn default() -> Self {
                Self {
                    acknowledged_at: Ok(Default::default()),
                    acknowledged_by: Ok(Default::default()),
                    acknowledged_reason: Ok(Default::default()),
                    affected_component: Ok(Default::default()),
                    affected_version: Ok(Default::default()),
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    component_id: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    cve_id: Err("no value supplied for cve_id".to_string()),
                    cve_published_at: Ok(Default::default()),
                    cvss_score: Ok(Default::default()),
                    first_detected_at: Err("no value supplied for first_detected_at".to_string()),
                    fixed_version: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    last_detected_at: Err("no value supplied for last_detected_at".to_string()),
                    sbom_id: Ok(Default::default()),
                    scan_result_id: Ok(Default::default()),
                    severity: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl CveHistoryEntry {
            pub fn acknowledged_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_at: {e}")
                });
                self
            }
            pub fn acknowledged_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_by = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_by: {e}")
                });
                self
            }
            pub fn acknowledged_reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_reason = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_reason: {e}")
                });
                self
            }
            pub fn affected_component<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.affected_component = value.try_into().map_err(|e| {
                    format!("error converting supplied value for affected_component: {e}")
                });
                self
            }
            pub fn affected_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.affected_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for affected_version: {e}")
                });
                self
            }
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn component_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.component_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for component_id: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn cve_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.cve_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cve_id: {e}"));
                self
            }
            pub fn cve_published_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.cve_published_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cve_published_at: {e}")
                });
                self
            }
            pub fn cvss_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.cvss_score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cvss_score: {e}"));
                self
            }
            pub fn first_detected_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_detected_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for first_detected_at: {e}")
                });
                self
            }
            pub fn fixed_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.fixed_version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fixed_version: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn last_detected_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_detected_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_detected_at: {e}")
                });
                self
            }
            pub fn sbom_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.sbom_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sbom_id: {e}"));
                self
            }
            pub fn scan_result_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_result_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for scan_result_id: {e}")
                });
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CveHistoryEntry> for super::CveHistoryEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CveHistoryEntry,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acknowledged_at: value.acknowledged_at?,
                    acknowledged_by: value.acknowledged_by?,
                    acknowledged_reason: value.acknowledged_reason?,
                    affected_component: value.affected_component?,
                    affected_version: value.affected_version?,
                    artifact_id: value.artifact_id?,
                    component_id: value.component_id?,
                    created_at: value.created_at?,
                    cve_id: value.cve_id?,
                    cve_published_at: value.cve_published_at?,
                    cvss_score: value.cvss_score?,
                    first_detected_at: value.first_detected_at?,
                    fixed_version: value.fixed_version?,
                    id: value.id?,
                    last_detected_at: value.last_detected_at?,
                    sbom_id: value.sbom_id?,
                    scan_result_id: value.scan_result_id?,
                    severity: value.severity?,
                    status: value.status?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::CveHistoryEntry> for CveHistoryEntry {
            fn from(value: super::CveHistoryEntry) -> Self {
                Self {
                    acknowledged_at: Ok(value.acknowledged_at),
                    acknowledged_by: Ok(value.acknowledged_by),
                    acknowledged_reason: Ok(value.acknowledged_reason),
                    affected_component: Ok(value.affected_component),
                    affected_version: Ok(value.affected_version),
                    artifact_id: Ok(value.artifact_id),
                    component_id: Ok(value.component_id),
                    created_at: Ok(value.created_at),
                    cve_id: Ok(value.cve_id),
                    cve_published_at: Ok(value.cve_published_at),
                    cvss_score: Ok(value.cvss_score),
                    first_detected_at: Ok(value.first_detected_at),
                    fixed_version: Ok(value.fixed_version),
                    id: Ok(value.id),
                    last_detected_at: Ok(value.last_detected_at),
                    sbom_id: Ok(value.sbom_id),
                    scan_result_id: Ok(value.scan_result_id),
                    severity: Ok(value.severity),
                    status: Ok(value.status),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CveTimelineEntry {
            affected_component: ::std::result::Result<::std::string::String, ::std::string::String>,
            cve_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            cve_published_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            days_exposed: ::std::result::Result<i64, ::std::string::String>,
            first_detected_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<super::CveStatus, ::std::string::String>,
        }
        impl ::std::default::Default for CveTimelineEntry {
            fn default() -> Self {
                Self {
                    affected_component: Err("no value supplied for affected_component".to_string()),
                    cve_id: Err("no value supplied for cve_id".to_string()),
                    cve_published_at: Ok(Default::default()),
                    days_exposed: Err("no value supplied for days_exposed".to_string()),
                    first_detected_at: Err("no value supplied for first_detected_at".to_string()),
                    severity: Err("no value supplied for severity".to_string()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl CveTimelineEntry {
            pub fn affected_component<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.affected_component = value.try_into().map_err(|e| {
                    format!("error converting supplied value for affected_component: {e}")
                });
                self
            }
            pub fn cve_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.cve_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cve_id: {e}"));
                self
            }
            pub fn cve_published_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.cve_published_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cve_published_at: {e}")
                });
                self
            }
            pub fn days_exposed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.days_exposed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for days_exposed: {e}"));
                self
            }
            pub fn first_detected_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_detected_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for first_detected_at: {e}")
                });
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CveStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CveTimelineEntry> for super::CveTimelineEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CveTimelineEntry,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    affected_component: value.affected_component?,
                    cve_id: value.cve_id?,
                    cve_published_at: value.cve_published_at?,
                    days_exposed: value.days_exposed?,
                    first_detected_at: value.first_detected_at?,
                    severity: value.severity?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::CveTimelineEntry> for CveTimelineEntry {
            fn from(value: super::CveTimelineEntry) -> Self {
                Self {
                    affected_component: Ok(value.affected_component),
                    cve_id: Ok(value.cve_id),
                    cve_published_at: Ok(value.cve_published_at),
                    days_exposed: Ok(value.days_exposed),
                    first_detected_at: Ok(value.first_detected_at),
                    severity: Ok(value.severity),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CveTrends {
            acknowledged_cves: ::std::result::Result<i64, ::std::string::String>,
            avg_days_to_fix:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            critical_count: ::std::result::Result<i64, ::std::string::String>,
            fixed_cves: ::std::result::Result<i64, ::std::string::String>,
            high_count: ::std::result::Result<i64, ::std::string::String>,
            low_count: ::std::result::Result<i64, ::std::string::String>,
            medium_count: ::std::result::Result<i64, ::std::string::String>,
            open_cves: ::std::result::Result<i64, ::std::string::String>,
            timeline: ::std::result::Result<
                ::std::vec::Vec<super::CveTimelineEntry>,
                ::std::string::String,
            >,
            total_cves: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for CveTrends {
            fn default() -> Self {
                Self {
                    acknowledged_cves: Err("no value supplied for acknowledged_cves".to_string()),
                    avg_days_to_fix: Ok(Default::default()),
                    critical_count: Err("no value supplied for critical_count".to_string()),
                    fixed_cves: Err("no value supplied for fixed_cves".to_string()),
                    high_count: Err("no value supplied for high_count".to_string()),
                    low_count: Err("no value supplied for low_count".to_string()),
                    medium_count: Err("no value supplied for medium_count".to_string()),
                    open_cves: Err("no value supplied for open_cves".to_string()),
                    timeline: Err("no value supplied for timeline".to_string()),
                    total_cves: Err("no value supplied for total_cves".to_string()),
                }
            }
        }
        impl CveTrends {
            pub fn acknowledged_cves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_cves = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_cves: {e}")
                });
                self
            }
            pub fn avg_days_to_fix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.avg_days_to_fix = value.try_into().map_err(|e| {
                    format!("error converting supplied value for avg_days_to_fix: {e}")
                });
                self
            }
            pub fn critical_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.critical_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for critical_count: {e}")
                });
                self
            }
            pub fn fixed_cves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.fixed_cves = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fixed_cves: {e}"));
                self
            }
            pub fn high_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.high_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high_count: {e}"));
                self
            }
            pub fn low_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.low_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low_count: {e}"));
                self
            }
            pub fn medium_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.medium_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for medium_count: {e}"));
                self
            }
            pub fn open_cves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.open_cves = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for open_cves: {e}"));
                self
            }
            pub fn timeline<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CveTimelineEntry>>,
                T::Error: ::std::fmt::Display,
            {
                self.timeline = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for timeline: {e}"));
                self
            }
            pub fn total_cves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_cves = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_cves: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CveTrends> for super::CveTrends {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CveTrends,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acknowledged_cves: value.acknowledged_cves?,
                    avg_days_to_fix: value.avg_days_to_fix?,
                    critical_count: value.critical_count?,
                    fixed_cves: value.fixed_cves?,
                    high_count: value.high_count?,
                    low_count: value.low_count?,
                    medium_count: value.medium_count?,
                    open_cves: value.open_cves?,
                    timeline: value.timeline?,
                    total_cves: value.total_cves?,
                })
            }
        }
        impl ::std::convert::From<super::CveTrends> for CveTrends {
            fn from(value: super::CveTrends) -> Self {
                Self {
                    acknowledged_cves: Ok(value.acknowledged_cves),
                    avg_days_to_fix: Ok(value.avg_days_to_fix),
                    critical_count: Ok(value.critical_count),
                    fixed_cves: Ok(value.fixed_cves),
                    high_count: Ok(value.high_count),
                    low_count: Ok(value.low_count),
                    medium_count: Ok(value.medium_count),
                    open_cves: Ok(value.open_cves),
                    timeline: Ok(value.timeline),
                    total_cves: Ok(value.total_cves),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DashboardResponse {
            critical_findings: ::std::result::Result<i64, ::std::string::String>,
            high_findings: ::std::result::Result<i64, ::std::string::String>,
            policy_violations_blocked: ::std::result::Result<i64, ::std::string::String>,
            repos_grade_a: ::std::result::Result<i64, ::std::string::String>,
            repos_grade_f: ::std::result::Result<i64, ::std::string::String>,
            repos_with_scanning: ::std::result::Result<i64, ::std::string::String>,
            total_findings: ::std::result::Result<i64, ::std::string::String>,
            total_scans: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for DashboardResponse {
            fn default() -> Self {
                Self {
                    critical_findings: Err("no value supplied for critical_findings".to_string()),
                    high_findings: Err("no value supplied for high_findings".to_string()),
                    policy_violations_blocked: Err(
                        "no value supplied for policy_violations_blocked".to_string(),
                    ),
                    repos_grade_a: Err("no value supplied for repos_grade_a".to_string()),
                    repos_grade_f: Err("no value supplied for repos_grade_f".to_string()),
                    repos_with_scanning: Err(
                        "no value supplied for repos_with_scanning".to_string()
                    ),
                    total_findings: Err("no value supplied for total_findings".to_string()),
                    total_scans: Err("no value supplied for total_scans".to_string()),
                }
            }
        }
        impl DashboardResponse {
            pub fn critical_findings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.critical_findings = value.try_into().map_err(|e| {
                    format!("error converting supplied value for critical_findings: {e}")
                });
                self
            }
            pub fn high_findings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.high_findings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high_findings: {e}"));
                self
            }
            pub fn policy_violations_blocked<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_blocked = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_blocked: {e}")
                });
                self
            }
            pub fn repos_grade_a<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_a = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_a: {e}"));
                self
            }
            pub fn repos_grade_f<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_f = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_f: {e}"));
                self
            }
            pub fn repos_with_scanning<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_with_scanning = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repos_with_scanning: {e}")
                });
                self
            }
            pub fn total_findings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_findings = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_findings: {e}")
                });
                self
            }
            pub fn total_scans<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_scans = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_scans: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DashboardResponse> for super::DashboardResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DashboardResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    critical_findings: value.critical_findings?,
                    high_findings: value.high_findings?,
                    policy_violations_blocked: value.policy_violations_blocked?,
                    repos_grade_a: value.repos_grade_a?,
                    repos_grade_f: value.repos_grade_f?,
                    repos_with_scanning: value.repos_with_scanning?,
                    total_findings: value.total_findings?,
                    total_scans: value.total_scans?,
                })
            }
        }
        impl ::std::convert::From<super::DashboardResponse> for DashboardResponse {
            fn from(value: super::DashboardResponse) -> Self {
                Self {
                    critical_findings: Ok(value.critical_findings),
                    high_findings: Ok(value.high_findings),
                    policy_violations_blocked: Ok(value.policy_violations_blocked),
                    repos_grade_a: Ok(value.repos_grade_a),
                    repos_grade_f: Ok(value.repos_grade_f),
                    repos_with_scanning: Ok(value.repos_with_scanning),
                    total_findings: Ok(value.total_findings),
                    total_scans: Ok(value.total_scans),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DateRangeQuery {
            from: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            to: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DateRangeQuery {
            fn default() -> Self {
                Self {
                    from: Ok(Default::default()),
                    to: Ok(Default::default()),
                }
            }
        }
        impl DateRangeQuery {
            pub fn from<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.from = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from: {e}"));
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DateRangeQuery> for super::DateRangeQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DateRangeQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    from: value.from?,
                    to: value.to?,
                })
            }
        }
        impl ::std::convert::From<super::DateRangeQuery> for DateRangeQuery {
            fn from(value: super::DateRangeQuery) -> Self {
                Self {
                    from: Ok(value.from),
                    to: Ok(value.to),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DbPoolStats {
            active_connections: ::std::result::Result<i32, ::std::string::String>,
            idle_connections: ::std::result::Result<i32, ::std::string::String>,
            max_connections: ::std::result::Result<i32, ::std::string::String>,
            size: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for DbPoolStats {
            fn default() -> Self {
                Self {
                    active_connections: Err("no value supplied for active_connections".to_string()),
                    idle_connections: Err("no value supplied for idle_connections".to_string()),
                    max_connections: Err("no value supplied for max_connections".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }
        impl DbPoolStats {
            pub fn active_connections<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.active_connections = value.try_into().map_err(|e| {
                    format!("error converting supplied value for active_connections: {e}")
                });
                self
            }
            pub fn idle_connections<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.idle_connections = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idle_connections: {e}")
                });
                self
            }
            pub fn max_connections<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.max_connections = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_connections: {e}")
                });
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DbPoolStats> for super::DbPoolStats {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DbPoolStats,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    active_connections: value.active_connections?,
                    idle_connections: value.idle_connections?,
                    max_connections: value.max_connections?,
                    size: value.size?,
                })
            }
        }
        impl ::std::convert::From<super::DbPoolStats> for DbPoolStats {
            fn from(value: super::DbPoolStats) -> Self {
                Self {
                    active_connections: Ok(value.active_connections),
                    idle_connections: Ok(value.idle_connections),
                    max_connections: Ok(value.max_connections),
                    size: Ok(value.size),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DeliveryListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::DeliveryResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for DeliveryListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl DeliveryListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::DeliveryResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DeliveryListResponse> for super::DeliveryListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeliveryListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::DeliveryListResponse> for DeliveryListResponse {
            fn from(value: super::DeliveryListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DeliveryResponse {
            attempts: ::std::result::Result<i32, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            delivered_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            event: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            payload: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            response_body: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            response_status:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            success: ::std::result::Result<bool, ::std::string::String>,
            webhook_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for DeliveryResponse {
            fn default() -> Self {
                Self {
                    attempts: Err("no value supplied for attempts".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    delivered_at: Ok(Default::default()),
                    event: Err("no value supplied for event".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    payload: Err("no value supplied for payload".to_string()),
                    response_body: Ok(Default::default()),
                    response_status: Ok(Default::default()),
                    success: Err("no value supplied for success".to_string()),
                    webhook_id: Err("no value supplied for webhook_id".to_string()),
                }
            }
        }
        impl DeliveryResponse {
            pub fn attempts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.attempts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for attempts: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn delivered_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.delivered_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delivered_at: {e}"));
                self
            }
            pub fn event<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.event = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for event: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {e}"));
                self
            }
            pub fn response_body<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.response_body = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for response_body: {e}"));
                self
            }
            pub fn response_status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.response_status = value.try_into().map_err(|e| {
                    format!("error converting supplied value for response_status: {e}")
                });
                self
            }
            pub fn success<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.success = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for success: {e}"));
                self
            }
            pub fn webhook_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.webhook_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for webhook_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DeliveryResponse> for super::DeliveryResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeliveryResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    attempts: value.attempts?,
                    created_at: value.created_at?,
                    delivered_at: value.delivered_at?,
                    event: value.event?,
                    id: value.id?,
                    payload: value.payload?,
                    response_body: value.response_body?,
                    response_status: value.response_status?,
                    success: value.success?,
                    webhook_id: value.webhook_id?,
                })
            }
        }
        impl ::std::convert::From<super::DeliveryResponse> for DeliveryResponse {
            fn from(value: super::DeliveryResponse) -> Self {
                Self {
                    attempts: Ok(value.attempts),
                    created_at: Ok(value.created_at),
                    delivered_at: Ok(value.delivered_at),
                    event: Ok(value.event),
                    id: Ok(value.id),
                    payload: Ok(value.payload),
                    response_body: Ok(value.response_body),
                    response_status: Ok(value.response_status),
                    success: Ok(value.success),
                    webhook_id: Ok(value.webhook_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DiscoverablePeerResponse {
            endpoint_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            region: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DiscoverablePeerResponse {
            fn default() -> Self {
                Self {
                    endpoint_url: Err("no value supplied for endpoint_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    peer_id: Err("no value supplied for peer_id".to_string()),
                    region: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl DiscoverablePeerResponse {
            pub fn endpoint_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.peer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_id: {e}"));
                self
            }
            pub fn region<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.region = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for region: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DiscoverablePeerResponse> for super::DiscoverablePeerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DiscoverablePeerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    endpoint_url: value.endpoint_url?,
                    name: value.name?,
                    peer_id: value.peer_id?,
                    region: value.region?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::DiscoverablePeerResponse> for DiscoverablePeerResponse {
            fn from(value: super::DiscoverablePeerResponse) -> Self {
                Self {
                    endpoint_url: Ok(value.endpoint_url),
                    name: Ok(value.name),
                    peer_id: Ok(value.peer_id),
                    region: Ok(value.region),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DownloadTrend {
            date: ::std::result::Result<::chrono::naive::NaiveDate, ::std::string::String>,
            download_count: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for DownloadTrend {
            fn default() -> Self {
                Self {
                    date: Err("no value supplied for date".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                }
            }
        }
        impl DownloadTrend {
            pub fn date<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::naive::NaiveDate>,
                T::Error: ::std::fmt::Display,
            {
                self.date = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for date: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<DownloadTrend> for super::DownloadTrend {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DownloadTrend,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    date: value.date?,
                    download_count: value.download_count?,
                })
            }
        }
        impl ::std::convert::From<super::DownloadTrend> for DownloadTrend {
            fn from(value: super::DownloadTrend) -> Self {
                Self {
                    date: Ok(value.date),
                    download_count: Ok(value.download_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtAnalysis {
            details: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_suppressed: ::std::result::Result<bool, ::std::string::String>,
            justification: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            response: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            state: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DtAnalysis {
            fn default() -> Self {
                Self {
                    details: Ok(Default::default()),
                    is_suppressed: Err("no value supplied for is_suppressed".to_string()),
                    justification: Ok(Default::default()),
                    response: Ok(Default::default()),
                    state: Ok(Default::default()),
                }
            }
        }
        impl DtAnalysis {
            pub fn details<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.details = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for details: {e}"));
                self
            }
            pub fn is_suppressed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_suppressed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_suppressed: {e}"));
                self
            }
            pub fn justification<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.justification = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for justification: {e}"));
                self
            }
            pub fn response<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.response = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for response: {e}"));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtAnalysis> for super::DtAnalysis {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtAnalysis,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    details: value.details?,
                    is_suppressed: value.is_suppressed?,
                    justification: value.justification?,
                    response: value.response?,
                    state: value.state?,
                })
            }
        }
        impl ::std::convert::From<super::DtAnalysis> for DtAnalysis {
            fn from(value: super::DtAnalysis) -> Self {
                Self {
                    details: Ok(value.details),
                    is_suppressed: Ok(value.is_suppressed),
                    justification: Ok(value.justification),
                    response: Ok(value.response),
                    state: Ok(value.state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtAnalysisResponse {
            analysis_details: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            analysis_justification: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            analysis_state: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_suppressed: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for DtAnalysisResponse {
            fn default() -> Self {
                Self {
                    analysis_details: Ok(Default::default()),
                    analysis_justification: Ok(Default::default()),
                    analysis_state: Err("no value supplied for analysis_state".to_string()),
                    is_suppressed: Err("no value supplied for is_suppressed".to_string()),
                }
            }
        }
        impl DtAnalysisResponse {
            pub fn analysis_details<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.analysis_details = value.try_into().map_err(|e| {
                    format!("error converting supplied value for analysis_details: {e}")
                });
                self
            }
            pub fn analysis_justification<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.analysis_justification = value.try_into().map_err(|e| {
                    format!("error converting supplied value for analysis_justification: {e}")
                });
                self
            }
            pub fn analysis_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.analysis_state = value.try_into().map_err(|e| {
                    format!("error converting supplied value for analysis_state: {e}")
                });
                self
            }
            pub fn is_suppressed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_suppressed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_suppressed: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtAnalysisResponse> for super::DtAnalysisResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtAnalysisResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    analysis_details: value.analysis_details?,
                    analysis_justification: value.analysis_justification?,
                    analysis_state: value.analysis_state?,
                    is_suppressed: value.is_suppressed?,
                })
            }
        }
        impl ::std::convert::From<super::DtAnalysisResponse> for DtAnalysisResponse {
            fn from(value: super::DtAnalysisResponse) -> Self {
                Self {
                    analysis_details: Ok(value.analysis_details),
                    analysis_justification: Ok(value.analysis_justification),
                    analysis_state: Ok(value.analysis_state),
                    is_suppressed: Ok(value.is_suppressed),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtAttribution {
            analyzer_identity: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            attributed_on: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for DtAttribution {
            fn default() -> Self {
                Self {
                    analyzer_identity: Ok(Default::default()),
                    attributed_on: Ok(Default::default()),
                }
            }
        }
        impl DtAttribution {
            pub fn analyzer_identity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.analyzer_identity = value.try_into().map_err(|e| {
                    format!("error converting supplied value for analyzer_identity: {e}")
                });
                self
            }
            pub fn attributed_on<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.attributed_on = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for attributed_on: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtAttribution> for super::DtAttribution {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtAttribution,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    analyzer_identity: value.analyzer_identity?,
                    attributed_on: value.attributed_on?,
                })
            }
        }
        impl ::std::convert::From<super::DtAttribution> for DtAttribution {
            fn from(value: super::DtAttribution) -> Self {
                Self {
                    analyzer_identity: Ok(value.analyzer_identity),
                    attributed_on: Ok(value.attributed_on),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtComponent {
            group: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            purl: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DtComponent {
            fn default() -> Self {
                Self {
                    group: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    purl: Ok(Default::default()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl DtComponent {
            pub fn group<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn purl<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.purl = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for purl: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtComponent> for super::DtComponent {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtComponent,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    group: value.group?,
                    name: value.name?,
                    purl: value.purl?,
                    uuid: value.uuid?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::DtComponent> for DtComponent {
            fn from(value: super::DtComponent) -> Self {
                Self {
                    group: Ok(value.group),
                    name: Ok(value.name),
                    purl: Ok(value.purl),
                    uuid: Ok(value.uuid),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtComponentFull {
            cpe: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            group: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_internal: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            purl: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            resolved_license: ::std::result::Result<
                ::std::option::Option<super::DtLicense>,
                ::std::string::String,
            >,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DtComponentFull {
            fn default() -> Self {
                Self {
                    cpe: Ok(Default::default()),
                    group: Ok(Default::default()),
                    is_internal: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    purl: Ok(Default::default()),
                    resolved_license: Ok(Default::default()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl DtComponentFull {
            pub fn cpe<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cpe = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cpe: {e}"));
                self
            }
            pub fn group<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group: {e}"));
                self
            }
            pub fn is_internal<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_internal = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_internal: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn purl<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.purl = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for purl: {e}"));
                self
            }
            pub fn resolved_license<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DtLicense>>,
                T::Error: ::std::fmt::Display,
            {
                self.resolved_license = value.try_into().map_err(|e| {
                    format!("error converting supplied value for resolved_license: {e}")
                });
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtComponentFull> for super::DtComponentFull {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtComponentFull,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpe: value.cpe?,
                    group: value.group?,
                    is_internal: value.is_internal?,
                    name: value.name?,
                    purl: value.purl?,
                    resolved_license: value.resolved_license?,
                    uuid: value.uuid?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::DtComponentFull> for DtComponentFull {
            fn from(value: super::DtComponentFull) -> Self {
                Self {
                    cpe: Ok(value.cpe),
                    group: Ok(value.group),
                    is_internal: Ok(value.is_internal),
                    name: Ok(value.name),
                    purl: Ok(value.purl),
                    resolved_license: Ok(value.resolved_license),
                    uuid: Ok(value.uuid),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtCwe {
            cwe_id: ::std::result::Result<i32, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtCwe {
            fn default() -> Self {
                Self {
                    cwe_id: Err("no value supplied for cwe_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl DtCwe {
            pub fn cwe_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.cwe_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cwe_id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtCwe> for super::DtCwe {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtCwe,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cwe_id: value.cwe_id?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::DtCwe> for DtCwe {
            fn from(value: super::DtCwe) -> Self {
                Self {
                    cwe_id: Ok(value.cwe_id),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtFinding {
            analysis: ::std::result::Result<
                ::std::option::Option<super::DtAnalysis>,
                ::std::string::String,
            >,
            attribution: ::std::result::Result<
                ::std::option::Option<super::DtAttribution>,
                ::std::string::String,
            >,
            component: ::std::result::Result<super::DtComponent, ::std::string::String>,
            vulnerability: ::std::result::Result<super::DtVulnerability, ::std::string::String>,
        }
        impl ::std::default::Default for DtFinding {
            fn default() -> Self {
                Self {
                    analysis: Ok(Default::default()),
                    attribution: Ok(Default::default()),
                    component: Err("no value supplied for component".to_string()),
                    vulnerability: Err("no value supplied for vulnerability".to_string()),
                }
            }
        }
        impl DtFinding {
            pub fn analysis<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DtAnalysis>>,
                T::Error: ::std::fmt::Display,
            {
                self.analysis = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for analysis: {e}"));
                self
            }
            pub fn attribution<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DtAttribution>>,
                T::Error: ::std::fmt::Display,
            {
                self.attribution = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for attribution: {e}"));
                self
            }
            pub fn component<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DtComponent>,
                T::Error: ::std::fmt::Display,
            {
                self.component = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for component: {e}"));
                self
            }
            pub fn vulnerability<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DtVulnerability>,
                T::Error: ::std::fmt::Display,
            {
                self.vulnerability = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vulnerability: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtFinding> for super::DtFinding {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtFinding,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    analysis: value.analysis?,
                    attribution: value.attribution?,
                    component: value.component?,
                    vulnerability: value.vulnerability?,
                })
            }
        }
        impl ::std::convert::From<super::DtFinding> for DtFinding {
            fn from(value: super::DtFinding) -> Self {
                Self {
                    analysis: Ok(value.analysis),
                    attribution: Ok(value.attribution),
                    component: Ok(value.component),
                    vulnerability: Ok(value.vulnerability),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtLicense {
            license_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            uuid: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DtLicense {
            fn default() -> Self {
                Self {
                    license_id: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    uuid: Ok(Default::default()),
                }
            }
        }
        impl DtLicense {
            pub fn license_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.license_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for license_id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtLicense> for super::DtLicense {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtLicense,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    license_id: value.license_id?,
                    name: value.name?,
                    uuid: value.uuid?,
                })
            }
        }
        impl ::std::convert::From<super::DtLicense> for DtLicense {
            fn from(value: super::DtLicense) -> Self {
                Self {
                    license_id: Ok(value.license_id),
                    name: Ok(value.name),
                    uuid: Ok(value.uuid),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtPolicy {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            violation_state: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtPolicy {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    violation_state: Err("no value supplied for violation_state".to_string()),
                }
            }
        }
        impl DtPolicy {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn violation_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.violation_state = value.try_into().map_err(|e| {
                    format!("error converting supplied value for violation_state: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<DtPolicy> for super::DtPolicy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtPolicy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    uuid: value.uuid?,
                    violation_state: value.violation_state?,
                })
            }
        }
        impl ::std::convert::From<super::DtPolicy> for DtPolicy {
            fn from(value: super::DtPolicy) -> Self {
                Self {
                    name: Ok(value.name),
                    uuid: Ok(value.uuid),
                    violation_state: Ok(value.violation_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtPolicyCondition {
            operator: ::std::result::Result<::std::string::String, ::std::string::String>,
            policy: ::std::result::Result<super::DtPolicy, ::std::string::String>,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtPolicyCondition {
            fn default() -> Self {
                Self {
                    operator: Err("no value supplied for operator".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl DtPolicyCondition {
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {e}"));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DtPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {e}"));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtPolicyCondition> for super::DtPolicyCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtPolicyCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    operator: value.operator?,
                    policy: value.policy?,
                    subject: value.subject?,
                    uuid: value.uuid?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::DtPolicyCondition> for DtPolicyCondition {
            fn from(value: super::DtPolicyCondition) -> Self {
                Self {
                    operator: Ok(value.operator),
                    policy: Ok(value.policy),
                    subject: Ok(value.subject),
                    uuid: Ok(value.uuid),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtPolicyConditionFull {
            operator: ::std::result::Result<::std::string::String, ::std::string::String>,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtPolicyConditionFull {
            fn default() -> Self {
                Self {
                    operator: Err("no value supplied for operator".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl DtPolicyConditionFull {
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {e}"));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtPolicyConditionFull> for super::DtPolicyConditionFull {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtPolicyConditionFull,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    operator: value.operator?,
                    subject: value.subject?,
                    uuid: value.uuid?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::DtPolicyConditionFull> for DtPolicyConditionFull {
            fn from(value: super::DtPolicyConditionFull) -> Self {
                Self {
                    operator: Ok(value.operator),
                    subject: Ok(value.subject),
                    uuid: Ok(value.uuid),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtPolicyFull {
            include_children:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            policy_conditions: ::std::result::Result<
                ::std::vec::Vec<super::DtPolicyConditionFull>,
                ::std::string::String,
            >,
            projects:
                ::std::result::Result<::std::vec::Vec<super::DtProject>, ::std::string::String>,
            tags: ::std::result::Result<
                ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
                ::std::string::String,
            >,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            violation_state: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtPolicyFull {
            fn default() -> Self {
                Self {
                    include_children: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    policy_conditions: Err("no value supplied for policy_conditions".to_string()),
                    projects: Err("no value supplied for projects".to_string()),
                    tags: Err("no value supplied for tags".to_string()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    violation_state: Err("no value supplied for violation_state".to_string()),
                }
            }
        }
        impl DtPolicyFull {
            pub fn include_children<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.include_children = value.try_into().map_err(|e| {
                    format!("error converting supplied value for include_children: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn policy_conditions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::DtPolicyConditionFull>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_conditions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_conditions: {e}")
                });
                self
            }
            pub fn projects<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::DtProject>>,
                T::Error: ::std::fmt::Display,
            {
                self.projects = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for projects: {e}"));
                self
            }
            pub fn tags<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::vec::Vec<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.tags = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tags: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn violation_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.violation_state = value.try_into().map_err(|e| {
                    format!("error converting supplied value for violation_state: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<DtPolicyFull> for super::DtPolicyFull {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtPolicyFull,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    include_children: value.include_children?,
                    name: value.name?,
                    policy_conditions: value.policy_conditions?,
                    projects: value.projects?,
                    tags: value.tags?,
                    uuid: value.uuid?,
                    violation_state: value.violation_state?,
                })
            }
        }
        impl ::std::convert::From<super::DtPolicyFull> for DtPolicyFull {
            fn from(value: super::DtPolicyFull) -> Self {
                Self {
                    include_children: Ok(value.include_children),
                    name: Ok(value.name),
                    policy_conditions: Ok(value.policy_conditions),
                    projects: Ok(value.projects),
                    tags: Ok(value.tags),
                    uuid: Ok(value.uuid),
                    violation_state: Ok(value.violation_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtPolicyViolation {
            component: ::std::result::Result<super::DtComponent, ::std::string::String>,
            policy_condition:
                ::std::result::Result<super::DtPolicyCondition, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtPolicyViolation {
            fn default() -> Self {
                Self {
                    component: Err("no value supplied for component".to_string()),
                    policy_condition: Err("no value supplied for policy_condition".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    uuid: Err("no value supplied for uuid".to_string()),
                }
            }
        }
        impl DtPolicyViolation {
            pub fn component<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DtComponent>,
                T::Error: ::std::fmt::Display,
            {
                self.component = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for component: {e}"));
                self
            }
            pub fn policy_condition<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DtPolicyCondition>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_condition = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_condition: {e}")
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtPolicyViolation> for super::DtPolicyViolation {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtPolicyViolation,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    component: value.component?,
                    policy_condition: value.policy_condition?,
                    type_: value.type_?,
                    uuid: value.uuid?,
                })
            }
        }
        impl ::std::convert::From<super::DtPolicyViolation> for DtPolicyViolation {
            fn from(value: super::DtPolicyViolation) -> Self {
                Self {
                    component: Ok(value.component),
                    policy_condition: Ok(value.policy_condition),
                    type_: Ok(value.type_),
                    uuid: Ok(value.uuid),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtPortfolioMetrics {
            critical: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            findings_audited:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            findings_total:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            findings_unaudited:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            high: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            inherited_risk_score:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            low: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            medium: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_fail:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_info:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_total:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_warn:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            projects: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            suppressions: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            unassigned: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            vulnerabilities:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for DtPortfolioMetrics {
            fn default() -> Self {
                Self {
                    critical: Ok(Default::default()),
                    findings_audited: Ok(Default::default()),
                    findings_total: Ok(Default::default()),
                    findings_unaudited: Ok(Default::default()),
                    high: Ok(Default::default()),
                    inherited_risk_score: Ok(Default::default()),
                    low: Ok(Default::default()),
                    medium: Ok(Default::default()),
                    policy_violations_fail: Ok(Default::default()),
                    policy_violations_info: Ok(Default::default()),
                    policy_violations_total: Ok(Default::default()),
                    policy_violations_warn: Ok(Default::default()),
                    projects: Ok(Default::default()),
                    suppressions: Ok(Default::default()),
                    unassigned: Ok(Default::default()),
                    vulnerabilities: Ok(Default::default()),
                }
            }
        }
        impl DtPortfolioMetrics {
            pub fn critical<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.critical = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for critical: {e}"));
                self
            }
            pub fn findings_audited<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_audited = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_audited: {e}")
                });
                self
            }
            pub fn findings_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_total: {e}")
                });
                self
            }
            pub fn findings_unaudited<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_unaudited = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_unaudited: {e}")
                });
                self
            }
            pub fn high<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.high = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high: {e}"));
                self
            }
            pub fn inherited_risk_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.inherited_risk_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for inherited_risk_score: {e}")
                });
                self
            }
            pub fn low<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.low = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low: {e}"));
                self
            }
            pub fn medium<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.medium = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for medium: {e}"));
                self
            }
            pub fn policy_violations_fail<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_fail = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_fail: {e}")
                });
                self
            }
            pub fn policy_violations_info<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_info = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_info: {e}")
                });
                self
            }
            pub fn policy_violations_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_total: {e}")
                });
                self
            }
            pub fn policy_violations_warn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_warn = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_warn: {e}")
                });
                self
            }
            pub fn projects<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.projects = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for projects: {e}"));
                self
            }
            pub fn suppressions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.suppressions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for suppressions: {e}"));
                self
            }
            pub fn unassigned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.unassigned = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for unassigned: {e}"));
                self
            }
            pub fn vulnerabilities<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.vulnerabilities = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vulnerabilities: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<DtPortfolioMetrics> for super::DtPortfolioMetrics {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtPortfolioMetrics,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    critical: value.critical?,
                    findings_audited: value.findings_audited?,
                    findings_total: value.findings_total?,
                    findings_unaudited: value.findings_unaudited?,
                    high: value.high?,
                    inherited_risk_score: value.inherited_risk_score?,
                    low: value.low?,
                    medium: value.medium?,
                    policy_violations_fail: value.policy_violations_fail?,
                    policy_violations_info: value.policy_violations_info?,
                    policy_violations_total: value.policy_violations_total?,
                    policy_violations_warn: value.policy_violations_warn?,
                    projects: value.projects?,
                    suppressions: value.suppressions?,
                    unassigned: value.unassigned?,
                    vulnerabilities: value.vulnerabilities?,
                })
            }
        }
        impl ::std::convert::From<super::DtPortfolioMetrics> for DtPortfolioMetrics {
            fn from(value: super::DtPortfolioMetrics) -> Self {
                Self {
                    critical: Ok(value.critical),
                    findings_audited: Ok(value.findings_audited),
                    findings_total: Ok(value.findings_total),
                    findings_unaudited: Ok(value.findings_unaudited),
                    high: Ok(value.high),
                    inherited_risk_score: Ok(value.inherited_risk_score),
                    low: Ok(value.low),
                    medium: Ok(value.medium),
                    policy_violations_fail: Ok(value.policy_violations_fail),
                    policy_violations_info: Ok(value.policy_violations_info),
                    policy_violations_total: Ok(value.policy_violations_total),
                    policy_violations_warn: Ok(value.policy_violations_warn),
                    projects: Ok(value.projects),
                    suppressions: Ok(value.suppressions),
                    unassigned: Ok(value.unassigned),
                    vulnerabilities: Ok(value.vulnerabilities),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtProject {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            last_bom_import:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            last_bom_import_format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DtProject {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    last_bom_import: Ok(Default::default()),
                    last_bom_import_format: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl DtProject {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn last_bom_import<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_bom_import = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_bom_import: {e}")
                });
                self
            }
            pub fn last_bom_import_format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_bom_import_format = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_bom_import_format: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtProject> for super::DtProject {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtProject,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    last_bom_import: value.last_bom_import?,
                    last_bom_import_format: value.last_bom_import_format?,
                    name: value.name?,
                    uuid: value.uuid?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::DtProject> for DtProject {
            fn from(value: super::DtProject) -> Self {
                Self {
                    description: Ok(value.description),
                    last_bom_import: Ok(value.last_bom_import),
                    last_bom_import_format: Ok(value.last_bom_import_format),
                    name: Ok(value.name),
                    uuid: Ok(value.uuid),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtProjectMetrics {
            critical: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            findings_audited:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            findings_total:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            findings_unaudited:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            first_occurrence:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            high: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            inherited_risk_score:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            last_occurrence:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            low: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            medium: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_fail:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_info:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_total:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            policy_violations_warn:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            suppressions: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            unassigned: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            vulnerabilities:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for DtProjectMetrics {
            fn default() -> Self {
                Self {
                    critical: Ok(Default::default()),
                    findings_audited: Ok(Default::default()),
                    findings_total: Ok(Default::default()),
                    findings_unaudited: Ok(Default::default()),
                    first_occurrence: Ok(Default::default()),
                    high: Ok(Default::default()),
                    inherited_risk_score: Ok(Default::default()),
                    last_occurrence: Ok(Default::default()),
                    low: Ok(Default::default()),
                    medium: Ok(Default::default()),
                    policy_violations_fail: Ok(Default::default()),
                    policy_violations_info: Ok(Default::default()),
                    policy_violations_total: Ok(Default::default()),
                    policy_violations_warn: Ok(Default::default()),
                    suppressions: Ok(Default::default()),
                    unassigned: Ok(Default::default()),
                    vulnerabilities: Ok(Default::default()),
                }
            }
        }
        impl DtProjectMetrics {
            pub fn critical<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.critical = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for critical: {e}"));
                self
            }
            pub fn findings_audited<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_audited = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_audited: {e}")
                });
                self
            }
            pub fn findings_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_total: {e}")
                });
                self
            }
            pub fn findings_unaudited<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_unaudited = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_unaudited: {e}")
                });
                self
            }
            pub fn first_occurrence<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_occurrence = value.try_into().map_err(|e| {
                    format!("error converting supplied value for first_occurrence: {e}")
                });
                self
            }
            pub fn high<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.high = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high: {e}"));
                self
            }
            pub fn inherited_risk_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.inherited_risk_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for inherited_risk_score: {e}")
                });
                self
            }
            pub fn last_occurrence<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_occurrence = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_occurrence: {e}")
                });
                self
            }
            pub fn low<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.low = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low: {e}"));
                self
            }
            pub fn medium<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.medium = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for medium: {e}"));
                self
            }
            pub fn policy_violations_fail<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_fail = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_fail: {e}")
                });
                self
            }
            pub fn policy_violations_info<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_info = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_info: {e}")
                });
                self
            }
            pub fn policy_violations_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_total: {e}")
                });
                self
            }
            pub fn policy_violations_warn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations_warn = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations_warn: {e}")
                });
                self
            }
            pub fn suppressions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.suppressions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for suppressions: {e}"));
                self
            }
            pub fn unassigned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.unassigned = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for unassigned: {e}"));
                self
            }
            pub fn vulnerabilities<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.vulnerabilities = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vulnerabilities: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<DtProjectMetrics> for super::DtProjectMetrics {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtProjectMetrics,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    critical: value.critical?,
                    findings_audited: value.findings_audited?,
                    findings_total: value.findings_total?,
                    findings_unaudited: value.findings_unaudited?,
                    first_occurrence: value.first_occurrence?,
                    high: value.high?,
                    inherited_risk_score: value.inherited_risk_score?,
                    last_occurrence: value.last_occurrence?,
                    low: value.low?,
                    medium: value.medium?,
                    policy_violations_fail: value.policy_violations_fail?,
                    policy_violations_info: value.policy_violations_info?,
                    policy_violations_total: value.policy_violations_total?,
                    policy_violations_warn: value.policy_violations_warn?,
                    suppressions: value.suppressions?,
                    unassigned: value.unassigned?,
                    vulnerabilities: value.vulnerabilities?,
                })
            }
        }
        impl ::std::convert::From<super::DtProjectMetrics> for DtProjectMetrics {
            fn from(value: super::DtProjectMetrics) -> Self {
                Self {
                    critical: Ok(value.critical),
                    findings_audited: Ok(value.findings_audited),
                    findings_total: Ok(value.findings_total),
                    findings_unaudited: Ok(value.findings_unaudited),
                    first_occurrence: Ok(value.first_occurrence),
                    high: Ok(value.high),
                    inherited_risk_score: Ok(value.inherited_risk_score),
                    last_occurrence: Ok(value.last_occurrence),
                    low: Ok(value.low),
                    medium: Ok(value.medium),
                    policy_violations_fail: Ok(value.policy_violations_fail),
                    policy_violations_info: Ok(value.policy_violations_info),
                    policy_violations_total: Ok(value.policy_violations_total),
                    policy_violations_warn: Ok(value.policy_violations_warn),
                    suppressions: Ok(value.suppressions),
                    unassigned: Ok(value.unassigned),
                    vulnerabilities: Ok(value.vulnerabilities),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtStatusResponse {
            enabled: ::std::result::Result<bool, ::std::string::String>,
            healthy: ::std::result::Result<bool, ::std::string::String>,
            url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for DtStatusResponse {
            fn default() -> Self {
                Self {
                    enabled: Err("no value supplied for enabled".to_string()),
                    healthy: Err("no value supplied for healthy".to_string()),
                    url: Ok(Default::default()),
                }
            }
        }
        impl DtStatusResponse {
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn healthy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.healthy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for healthy: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtStatusResponse> for super::DtStatusResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtStatusResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    enabled: value.enabled?,
                    healthy: value.healthy?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::DtStatusResponse> for DtStatusResponse {
            fn from(value: super::DtStatusResponse) -> Self {
                Self {
                    enabled: Ok(value.enabled),
                    healthy: Ok(value.healthy),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DtVulnerability {
            cvss_v3_base_score:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            cwe: ::std::result::Result<::std::option::Option<super::DtCwe>, ::std::string::String>,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            source: ::std::result::Result<::std::string::String, ::std::string::String>,
            title: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            vuln_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DtVulnerability {
            fn default() -> Self {
                Self {
                    cvss_v3_base_score: Ok(Default::default()),
                    cwe: Ok(Default::default()),
                    description: Ok(Default::default()),
                    severity: Err("no value supplied for severity".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    title: Ok(Default::default()),
                    uuid: Err("no value supplied for uuid".to_string()),
                    vuln_id: Err("no value supplied for vuln_id".to_string()),
                }
            }
        }
        impl DtVulnerability {
            pub fn cvss_v3_base_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.cvss_v3_base_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cvss_v3_base_score: {e}")
                });
                self
            }
            pub fn cwe<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DtCwe>>,
                T::Error: ::std::fmt::Display,
            {
                self.cwe = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cwe: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {e}"));
                self
            }
            pub fn title<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.title = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for title: {e}"));
                self
            }
            pub fn uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uuid: {e}"));
                self
            }
            pub fn vuln_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.vuln_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vuln_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<DtVulnerability> for super::DtVulnerability {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DtVulnerability,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cvss_v3_base_score: value.cvss_v3_base_score?,
                    cwe: value.cwe?,
                    description: value.description?,
                    severity: value.severity?,
                    source: value.source?,
                    title: value.title?,
                    uuid: value.uuid?,
                    vuln_id: value.vuln_id?,
                })
            }
        }
        impl ::std::convert::From<super::DtVulnerability> for DtVulnerability {
            fn from(value: super::DtVulnerability) -> Self {
                Self {
                    cvss_v3_base_score: Ok(value.cvss_v3_base_score),
                    cwe: Ok(value.cwe),
                    description: Ok(value.description),
                    severity: Ok(value.severity),
                    source: Ok(value.source),
                    title: Ok(value.title),
                    uuid: Ok(value.uuid),
                    vuln_id: Ok(value.vuln_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ErrorResponse {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ErrorResponse {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl ErrorResponse {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {e}"));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ErrorResponse> for super::ErrorResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ErrorResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::ErrorResponse> for ErrorResponse {
            fn from(value: super::ErrorResponse) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvaluationResultResponse {
            created: ::std::result::Result<u64, ::std::string::String>,
            policies_evaluated: ::std::result::Result<u64, ::std::string::String>,
            removed: ::std::result::Result<u64, ::std::string::String>,
            updated: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for EvaluationResultResponse {
            fn default() -> Self {
                Self {
                    created: Err("no value supplied for created".to_string()),
                    policies_evaluated: Err("no value supplied for policies_evaluated".to_string()),
                    removed: Err("no value supplied for removed".to_string()),
                    updated: Err("no value supplied for updated".to_string()),
                }
            }
        }
        impl EvaluationResultResponse {
            pub fn created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.created = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created: {e}"));
                self
            }
            pub fn policies_evaluated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.policies_evaluated = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policies_evaluated: {e}")
                });
                self
            }
            pub fn removed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.removed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for removed: {e}"));
                self
            }
            pub fn updated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.updated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<EvaluationResultResponse> for super::EvaluationResultResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvaluationResultResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created: value.created?,
                    policies_evaluated: value.policies_evaluated?,
                    removed: value.removed?,
                    updated: value.updated?,
                })
            }
        }
        impl ::std::convert::From<super::EvaluationResultResponse> for EvaluationResultResponse {
            fn from(value: super::EvaluationResultResponse) -> Self {
                Self {
                    created: Ok(value.created),
                    policies_evaluated: Ok(value.policies_evaluated),
                    removed: Ok(value.removed),
                    updated: Ok(value.updated),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EventsQuery {
            limit: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for EventsQuery {
            fn default() -> Self {
                Self {
                    limit: Ok(Default::default()),
                }
            }
        }
        impl EventsQuery {
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for limit: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<EventsQuery> for super::EventsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EventsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    limit: value.limit?,
                })
            }
        }
        impl ::std::convert::From<super::EventsQuery> for EventsQuery {
            fn from(value: super::EventsQuery) -> Self {
                Self {
                    limit: Ok(value.limit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExchangeCodeRequest {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExchangeCodeRequest {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                }
            }
        }
        impl ExchangeCodeRequest {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ExchangeCodeRequest> for super::ExchangeCodeRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExchangeCodeRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { code: value.code? })
            }
        }
        impl ::std::convert::From<super::ExchangeCodeRequest> for ExchangeCodeRequest {
            fn from(value: super::ExchangeCodeRequest) -> Self {
                Self {
                    code: Ok(value.code),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExchangeCodeResponse {
            access_token: ::std::result::Result<::std::string::String, ::std::string::String>,
            refresh_token: ::std::result::Result<::std::string::String, ::std::string::String>,
            token_type: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExchangeCodeResponse {
            fn default() -> Self {
                Self {
                    access_token: Err("no value supplied for access_token".to_string()),
                    refresh_token: Err("no value supplied for refresh_token".to_string()),
                    token_type: Err("no value supplied for token_type".to_string()),
                }
            }
        }
        impl ExchangeCodeResponse {
            pub fn access_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.access_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for access_token: {e}"));
                self
            }
            pub fn refresh_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.refresh_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for refresh_token: {e}"));
                self
            }
            pub fn token_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.token_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token_type: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ExchangeCodeResponse> for super::ExchangeCodeResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExchangeCodeResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    access_token: value.access_token?,
                    refresh_token: value.refresh_token?,
                    token_type: value.token_type?,
                })
            }
        }
        impl ::std::convert::From<super::ExchangeCodeResponse> for ExchangeCodeResponse {
            fn from(value: super::ExchangeCodeResponse) -> Self {
                Self {
                    access_token: Ok(value.access_token),
                    refresh_token: Ok(value.refresh_token),
                    token_type: Ok(value.token_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FacetValue {
            count: ::std::result::Result<i64, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for FacetValue {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl FacetValue {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {e}"));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<FacetValue> for super::FacetValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FacetValue,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::FacetValue> for FacetValue {
            fn from(value: super::FacetValue) -> Self {
                Self {
                    count: Ok(value.count),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FacetsResponse {
            content_types:
                ::std::result::Result<::std::vec::Vec<super::FacetValue>, ::std::string::String>,
            formats:
                ::std::result::Result<::std::vec::Vec<super::FacetValue>, ::std::string::String>,
            repositories:
                ::std::result::Result<::std::vec::Vec<super::FacetValue>, ::std::string::String>,
        }
        impl ::std::default::Default for FacetsResponse {
            fn default() -> Self {
                Self {
                    content_types: Err("no value supplied for content_types".to_string()),
                    formats: Err("no value supplied for formats".to_string()),
                    repositories: Err("no value supplied for repositories".to_string()),
                }
            }
        }
        impl FacetsResponse {
            pub fn content_types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FacetValue>>,
                T::Error: ::std::fmt::Display,
            {
                self.content_types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content_types: {e}"));
                self
            }
            pub fn formats<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FacetValue>>,
                T::Error: ::std::fmt::Display,
            {
                self.formats = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for formats: {e}"));
                self
            }
            pub fn repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FacetValue>>,
                T::Error: ::std::fmt::Display,
            {
                self.repositories = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repositories: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<FacetsResponse> for super::FacetsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FacetsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    content_types: value.content_types?,
                    formats: value.formats?,
                    repositories: value.repositories?,
                })
            }
        }
        impl ::std::convert::From<super::FacetsResponse> for FacetsResponse {
            fn from(value: super::FacetsResponse) -> Self {
                Self {
                    content_types: Ok(value.content_types),
                    formats: Ok(value.formats),
                    repositories: Ok(value.repositories),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FailBody {
            error: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for FailBody {
            fn default() -> Self {
                Self {
                    error: Err("no value supplied for error".to_string()),
                }
            }
        }
        impl FailBody {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<FailBody> for super::FailBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FailBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                })
            }
        }
        impl ::std::convert::From<super::FailBody> for FailBody {
            fn from(value: super::FailBody) -> Self {
                Self {
                    error: Ok(value.error),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FindingListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::FindingResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for FindingListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl FindingListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FindingResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<FindingListResponse> for super::FindingListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FindingListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::FindingListResponse> for FindingListResponse {
            fn from(value: super::FindingListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FindingResponse {
            acknowledged_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            acknowledged_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            acknowledged_reason: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            affected_component: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            affected_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            cve_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            fixed_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_acknowledged: ::std::result::Result<bool, ::std::string::String>,
            scan_result_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            source: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            source_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            title: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for FindingResponse {
            fn default() -> Self {
                Self {
                    acknowledged_at: Ok(Default::default()),
                    acknowledged_by: Ok(Default::default()),
                    acknowledged_reason: Ok(Default::default()),
                    affected_component: Ok(Default::default()),
                    affected_version: Ok(Default::default()),
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    cve_id: Ok(Default::default()),
                    description: Ok(Default::default()),
                    fixed_version: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    is_acknowledged: Err("no value supplied for is_acknowledged".to_string()),
                    scan_result_id: Err("no value supplied for scan_result_id".to_string()),
                    severity: Err("no value supplied for severity".to_string()),
                    source: Ok(Default::default()),
                    source_url: Ok(Default::default()),
                    title: Err("no value supplied for title".to_string()),
                }
            }
        }
        impl FindingResponse {
            pub fn acknowledged_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_at: {e}")
                });
                self
            }
            pub fn acknowledged_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_by = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_by: {e}")
                });
                self
            }
            pub fn acknowledged_reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_reason = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_reason: {e}")
                });
                self
            }
            pub fn affected_component<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.affected_component = value.try_into().map_err(|e| {
                    format!("error converting supplied value for affected_component: {e}")
                });
                self
            }
            pub fn affected_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.affected_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for affected_version: {e}")
                });
                self
            }
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn cve_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cve_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cve_id: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn fixed_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.fixed_version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fixed_version: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_acknowledged<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_acknowledged = value.try_into().map_err(|e| {
                    format!("error converting supplied value for is_acknowledged: {e}")
                });
                self
            }
            pub fn scan_result_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_result_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for scan_result_id: {e}")
                });
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {e}"));
                self
            }
            pub fn source_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_url: {e}"));
                self
            }
            pub fn title<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.title = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for title: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<FindingResponse> for super::FindingResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FindingResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acknowledged_at: value.acknowledged_at?,
                    acknowledged_by: value.acknowledged_by?,
                    acknowledged_reason: value.acknowledged_reason?,
                    affected_component: value.affected_component?,
                    affected_version: value.affected_version?,
                    artifact_id: value.artifact_id?,
                    created_at: value.created_at?,
                    cve_id: value.cve_id?,
                    description: value.description?,
                    fixed_version: value.fixed_version?,
                    id: value.id?,
                    is_acknowledged: value.is_acknowledged?,
                    scan_result_id: value.scan_result_id?,
                    severity: value.severity?,
                    source: value.source?,
                    source_url: value.source_url?,
                    title: value.title?,
                })
            }
        }
        impl ::std::convert::From<super::FindingResponse> for FindingResponse {
            fn from(value: super::FindingResponse) -> Self {
                Self {
                    acknowledged_at: Ok(value.acknowledged_at),
                    acknowledged_by: Ok(value.acknowledged_by),
                    acknowledged_reason: Ok(value.acknowledged_reason),
                    affected_component: Ok(value.affected_component),
                    affected_version: Ok(value.affected_version),
                    artifact_id: Ok(value.artifact_id),
                    created_at: Ok(value.created_at),
                    cve_id: Ok(value.cve_id),
                    description: Ok(value.description),
                    fixed_version: Ok(value.fixed_version),
                    id: Ok(value.id),
                    is_acknowledged: Ok(value.is_acknowledged),
                    scan_result_id: Ok(value.scan_result_id),
                    severity: Ok(value.severity),
                    source: Ok(value.source),
                    source_url: Ok(value.source_url),
                    title: Ok(value.title),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FormatHandlerResponse {
            capabilities: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            display_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            extensions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            format_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            handler_type: ::std::result::Result<super::FormatHandlerType, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            plugin_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
            repository_count:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for FormatHandlerResponse {
            fn default() -> Self {
                Self {
                    capabilities: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    display_name: Err("no value supplied for display_name".to_string()),
                    extensions: Err("no value supplied for extensions".to_string()),
                    format_key: Err("no value supplied for format_key".to_string()),
                    handler_type: Err("no value supplied for handler_type".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    plugin_id: Ok(Default::default()),
                    priority: Err("no value supplied for priority".to_string()),
                    repository_count: Ok(Default::default()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl FormatHandlerResponse {
            pub fn capabilities<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.capabilities = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for capabilities: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn extensions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.extensions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extensions: {e}"));
                self
            }
            pub fn format_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format_key: {e}"));
                self
            }
            pub fn handler_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FormatHandlerType>,
                T::Error: ::std::fmt::Display,
            {
                self.handler_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for handler_type: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn plugin_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.plugin_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for plugin_id: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn repository_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_count: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<FormatHandlerResponse> for super::FormatHandlerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FormatHandlerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    capabilities: value.capabilities?,
                    created_at: value.created_at?,
                    description: value.description?,
                    display_name: value.display_name?,
                    extensions: value.extensions?,
                    format_key: value.format_key?,
                    handler_type: value.handler_type?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    plugin_id: value.plugin_id?,
                    priority: value.priority?,
                    repository_count: value.repository_count?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::FormatHandlerResponse> for FormatHandlerResponse {
            fn from(value: super::FormatHandlerResponse) -> Self {
                Self {
                    capabilities: Ok(value.capabilities),
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    display_name: Ok(value.display_name),
                    extensions: Ok(value.extensions),
                    format_key: Ok(value.format_key),
                    handler_type: Ok(value.handler_type),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    plugin_id: Ok(value.plugin_id),
                    priority: Ok(value.priority),
                    repository_count: Ok(value.repository_count),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GateEvaluationResponse {
            action: ::std::result::Result<::std::string::String, ::std::string::String>,
            component_scores: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            gate_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            health_grade: ::std::result::Result<::std::string::String, ::std::string::String>,
            health_score: ::std::result::Result<i32, ::std::string::String>,
            passed: ::std::result::Result<bool, ::std::string::String>,
            violations: ::std::result::Result<
                ::std::vec::Vec<super::GateViolationResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GateEvaluationResponse {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    component_scores: Err("no value supplied for component_scores".to_string()),
                    gate_name: Err("no value supplied for gate_name".to_string()),
                    health_grade: Err("no value supplied for health_grade".to_string()),
                    health_score: Err("no value supplied for health_score".to_string()),
                    passed: Err("no value supplied for passed".to_string()),
                    violations: Err("no value supplied for violations".to_string()),
                }
            }
        }
        impl GateEvaluationResponse {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {e}"));
                self
            }
            pub fn component_scores<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.component_scores = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_scores: {e}")
                });
                self
            }
            pub fn gate_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.gate_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gate_name: {e}"));
                self
            }
            pub fn health_grade<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.health_grade = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for health_grade: {e}"));
                self
            }
            pub fn health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.health_score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for health_score: {e}"));
                self
            }
            pub fn passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for passed: {e}"));
                self
            }
            pub fn violations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::GateViolationResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.violations = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for violations: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GateEvaluationResponse> for super::GateEvaluationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GateEvaluationResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    component_scores: value.component_scores?,
                    gate_name: value.gate_name?,
                    health_grade: value.health_grade?,
                    health_score: value.health_score?,
                    passed: value.passed?,
                    violations: value.violations?,
                })
            }
        }
        impl ::std::convert::From<super::GateEvaluationResponse> for GateEvaluationResponse {
            fn from(value: super::GateEvaluationResponse) -> Self {
                Self {
                    action: Ok(value.action),
                    component_scores: Ok(value.component_scores),
                    gate_name: Ok(value.gate_name),
                    health_grade: Ok(value.health_grade),
                    health_score: Ok(value.health_score),
                    passed: Ok(value.passed),
                    violations: Ok(value.violations),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GateResponse {
            action: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enforce_on_download: ::std::result::Result<bool, ::std::string::String>,
            enforce_on_promotion: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            max_critical_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_high_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_medium_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_health_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_metadata_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_quality_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_security_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            required_checks: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GateResponse {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    enforce_on_download: Err(
                        "no value supplied for enforce_on_download".to_string()
                    ),
                    enforce_on_promotion: Err(
                        "no value supplied for enforce_on_promotion".to_string()
                    ),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    max_critical_issues: Ok(Default::default()),
                    max_high_issues: Ok(Default::default()),
                    max_medium_issues: Ok(Default::default()),
                    min_health_score: Ok(Default::default()),
                    min_metadata_score: Ok(Default::default()),
                    min_quality_score: Ok(Default::default()),
                    min_security_score: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    required_checks: Err("no value supplied for required_checks".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl GateResponse {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enforce_on_download<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_on_download = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enforce_on_download: {e}")
                });
                self
            }
            pub fn enforce_on_promotion<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_on_promotion = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enforce_on_promotion: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_critical_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_critical_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_critical_issues: {e}")
                });
                self
            }
            pub fn max_high_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_high_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_high_issues: {e}")
                });
                self
            }
            pub fn max_medium_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_medium_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_medium_issues: {e}")
                });
                self
            }
            pub fn min_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_health_score: {e}")
                });
                self
            }
            pub fn min_metadata_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_metadata_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_metadata_score: {e}")
                });
                self
            }
            pub fn min_quality_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_quality_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_quality_score: {e}")
                });
                self
            }
            pub fn min_security_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_security_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_security_score: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn required_checks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.required_checks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for required_checks: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GateResponse> for super::GateResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GateResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    created_at: value.created_at?,
                    description: value.description?,
                    enforce_on_download: value.enforce_on_download?,
                    enforce_on_promotion: value.enforce_on_promotion?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    max_critical_issues: value.max_critical_issues?,
                    max_high_issues: value.max_high_issues?,
                    max_medium_issues: value.max_medium_issues?,
                    min_health_score: value.min_health_score?,
                    min_metadata_score: value.min_metadata_score?,
                    min_quality_score: value.min_quality_score?,
                    min_security_score: value.min_security_score?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    required_checks: value.required_checks?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::GateResponse> for GateResponse {
            fn from(value: super::GateResponse) -> Self {
                Self {
                    action: Ok(value.action),
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    enforce_on_download: Ok(value.enforce_on_download),
                    enforce_on_promotion: Ok(value.enforce_on_promotion),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    max_critical_issues: Ok(value.max_critical_issues),
                    max_high_issues: Ok(value.max_high_issues),
                    max_medium_issues: Ok(value.max_medium_issues),
                    min_health_score: Ok(value.min_health_score),
                    min_metadata_score: Ok(value.min_metadata_score),
                    min_quality_score: Ok(value.min_quality_score),
                    min_security_score: Ok(value.min_security_score),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    required_checks: Ok(value.required_checks),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GateViolationResponse {
            actual: ::std::result::Result<::std::string::String, ::std::string::String>,
            expected: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            rule: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for GateViolationResponse {
            fn default() -> Self {
                Self {
                    actual: Err("no value supplied for actual".to_string()),
                    expected: Err("no value supplied for expected".to_string()),
                    message: Err("no value supplied for message".to_string()),
                    rule: Err("no value supplied for rule".to_string()),
                }
            }
        }
        impl GateViolationResponse {
            pub fn actual<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.actual = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for actual: {e}"));
                self
            }
            pub fn expected<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.expected = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for expected: {e}"));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn rule<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.rule = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GateViolationResponse> for super::GateViolationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GateViolationResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    actual: value.actual?,
                    expected: value.expected?,
                    message: value.message?,
                    rule: value.rule?,
                })
            }
        }
        impl ::std::convert::From<super::GateViolationResponse> for GateViolationResponse {
            fn from(value: super::GateViolationResponse) -> Self {
                Self {
                    actual: Ok(value.actual),
                    expected: Ok(value.expected),
                    message: Ok(value.message),
                    rule: Ok(value.rule),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GenerateSbomRequest {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            force_regenerate:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GenerateSbomRequest {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    force_regenerate: Ok(Default::default()),
                    format: Ok(Default::default()),
                }
            }
        }
        impl GenerateSbomRequest {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn force_regenerate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.force_regenerate = value.try_into().map_err(|e| {
                    format!("error converting supplied value for force_regenerate: {e}")
                });
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GenerateSbomRequest> for super::GenerateSbomRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GenerateSbomRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    force_regenerate: value.force_regenerate?,
                    format: value.format?,
                })
            }
        }
        impl ::std::convert::From<super::GenerateSbomRequest> for GenerateSbomRequest {
            fn from(value: super::GenerateSbomRequest) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    force_regenerate: Ok(value.force_regenerate),
                    format: Ok(value.format),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetCveTrendsQuery {
            days: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for GetCveTrendsQuery {
            fn default() -> Self {
                Self {
                    days: Ok(Default::default()),
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl GetCveTrendsQuery {
            pub fn days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.days = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for days: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GetCveTrendsQuery> for super::GetCveTrendsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetCveTrendsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    days: value.days?,
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::GetCveTrendsQuery> for GetCveTrendsQuery {
            fn from(value: super::GetCveTrendsQuery) -> Self {
                Self {
                    days: Ok(value.days),
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GroupListResponse {
            items:
                ::std::result::Result<::std::vec::Vec<super::GroupResponse>, ::std::string::String>,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for GroupListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl GroupListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::GroupResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GroupListResponse> for super::GroupListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GroupListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::GroupListResponse> for GroupListResponse {
            fn from(value: super::GroupListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GroupResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            member_count: ::std::result::Result<i64, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GroupResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    member_count: Err("no value supplied for member_count".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl GroupResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn member_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.member_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for member_count: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GroupResponse> for super::GroupResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GroupResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    id: value.id?,
                    member_count: value.member_count?,
                    name: value.name?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::GroupResponse> for GroupResponse {
            fn from(value: super::GroupResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    member_count: Ok(value.member_count),
                    name: Ok(value.name),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GroupRow {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            member_count: ::std::result::Result<i64, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GroupRow {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    member_count: Err("no value supplied for member_count".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl GroupRow {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn member_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.member_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for member_count: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<GroupRow> for super::GroupRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GroupRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    id: value.id?,
                    member_count: value.member_count?,
                    name: value.name?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::GroupRow> for GroupRow {
            fn from(value: super::GroupRow) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    member_count: Ok(value.member_count),
                    name: Ok(value.name),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GrowthSummary {
            artifacts_added: ::std::result::Result<i64, ::std::string::String>,
            artifacts_end: ::std::result::Result<i64, ::std::string::String>,
            artifacts_start: ::std::result::Result<i64, ::std::string::String>,
            downloads_in_period: ::std::result::Result<i64, ::std::string::String>,
            period_end: ::std::result::Result<::chrono::naive::NaiveDate, ::std::string::String>,
            period_start: ::std::result::Result<::chrono::naive::NaiveDate, ::std::string::String>,
            storage_bytes_end: ::std::result::Result<i64, ::std::string::String>,
            storage_bytes_start: ::std::result::Result<i64, ::std::string::String>,
            storage_growth_bytes: ::std::result::Result<i64, ::std::string::String>,
            storage_growth_percent: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for GrowthSummary {
            fn default() -> Self {
                Self {
                    artifacts_added: Err("no value supplied for artifacts_added".to_string()),
                    artifacts_end: Err("no value supplied for artifacts_end".to_string()),
                    artifacts_start: Err("no value supplied for artifacts_start".to_string()),
                    downloads_in_period: Err(
                        "no value supplied for downloads_in_period".to_string()
                    ),
                    period_end: Err("no value supplied for period_end".to_string()),
                    period_start: Err("no value supplied for period_start".to_string()),
                    storage_bytes_end: Err("no value supplied for storage_bytes_end".to_string()),
                    storage_bytes_start: Err(
                        "no value supplied for storage_bytes_start".to_string()
                    ),
                    storage_growth_bytes: Err(
                        "no value supplied for storage_growth_bytes".to_string()
                    ),
                    storage_growth_percent: Err(
                        "no value supplied for storage_growth_percent".to_string()
                    ),
                }
            }
        }
        impl GrowthSummary {
            pub fn artifacts_added<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_added = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_added: {e}")
                });
                self
            }
            pub fn artifacts_end<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_end = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifacts_end: {e}"));
                self
            }
            pub fn artifacts_start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_start = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_start: {e}")
                });
                self
            }
            pub fn downloads_in_period<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.downloads_in_period = value.try_into().map_err(|e| {
                    format!("error converting supplied value for downloads_in_period: {e}")
                });
                self
            }
            pub fn period_end<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::naive::NaiveDate>,
                T::Error: ::std::fmt::Display,
            {
                self.period_end = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for period_end: {e}"));
                self
            }
            pub fn period_start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::naive::NaiveDate>,
                T::Error: ::std::fmt::Display,
            {
                self.period_start = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for period_start: {e}"));
                self
            }
            pub fn storage_bytes_end<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_bytes_end = value.try_into().map_err(|e| {
                    format!("error converting supplied value for storage_bytes_end: {e}")
                });
                self
            }
            pub fn storage_bytes_start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_bytes_start = value.try_into().map_err(|e| {
                    format!("error converting supplied value for storage_bytes_start: {e}")
                });
                self
            }
            pub fn storage_growth_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_growth_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for storage_growth_bytes: {e}")
                });
                self
            }
            pub fn storage_growth_percent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_growth_percent = value.try_into().map_err(|e| {
                    format!("error converting supplied value for storage_growth_percent: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<GrowthSummary> for super::GrowthSummary {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GrowthSummary,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_added: value.artifacts_added?,
                    artifacts_end: value.artifacts_end?,
                    artifacts_start: value.artifacts_start?,
                    downloads_in_period: value.downloads_in_period?,
                    period_end: value.period_end?,
                    period_start: value.period_start?,
                    storage_bytes_end: value.storage_bytes_end?,
                    storage_bytes_start: value.storage_bytes_start?,
                    storage_growth_bytes: value.storage_growth_bytes?,
                    storage_growth_percent: value.storage_growth_percent?,
                })
            }
        }
        impl ::std::convert::From<super::GrowthSummary> for GrowthSummary {
            fn from(value: super::GrowthSummary) -> Self {
                Self {
                    artifacts_added: Ok(value.artifacts_added),
                    artifacts_end: Ok(value.artifacts_end),
                    artifacts_start: Ok(value.artifacts_start),
                    downloads_in_period: Ok(value.downloads_in_period),
                    period_end: Ok(value.period_end),
                    period_start: Ok(value.period_start),
                    storage_bytes_end: Ok(value.storage_bytes_end),
                    storage_bytes_start: Ok(value.storage_bytes_start),
                    storage_growth_bytes: Ok(value.storage_growth_bytes),
                    storage_growth_percent: Ok(value.storage_growth_percent),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct HealthChecks {
            database: ::std::result::Result<super::CheckStatus, ::std::string::String>,
            meilisearch: ::std::result::Result<
                ::std::option::Option<super::CheckStatus>,
                ::std::string::String,
            >,
            security_scanner: ::std::result::Result<
                ::std::option::Option<super::CheckStatus>,
                ::std::string::String,
            >,
            storage: ::std::result::Result<super::CheckStatus, ::std::string::String>,
        }
        impl ::std::default::Default for HealthChecks {
            fn default() -> Self {
                Self {
                    database: Err("no value supplied for database".to_string()),
                    meilisearch: Ok(Default::default()),
                    security_scanner: Ok(Default::default()),
                    storage: Err("no value supplied for storage".to_string()),
                }
            }
        }
        impl HealthChecks {
            pub fn database<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CheckStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.database = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for database: {e}"));
                self
            }
            pub fn meilisearch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::CheckStatus>>,
                T::Error: ::std::fmt::Display,
            {
                self.meilisearch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for meilisearch: {e}"));
                self
            }
            pub fn security_scanner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::CheckStatus>>,
                T::Error: ::std::fmt::Display,
            {
                self.security_scanner = value.try_into().map_err(|e| {
                    format!("error converting supplied value for security_scanner: {e}")
                });
                self
            }
            pub fn storage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CheckStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.storage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<HealthChecks> for super::HealthChecks {
            type Error = super::error::ConversionError;
            fn try_from(
                value: HealthChecks,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    database: value.database?,
                    meilisearch: value.meilisearch?,
                    security_scanner: value.security_scanner?,
                    storage: value.storage?,
                })
            }
        }
        impl ::std::convert::From<super::HealthChecks> for HealthChecks {
            fn from(value: super::HealthChecks) -> Self {
                Self {
                    database: Ok(value.database),
                    meilisearch: Ok(value.meilisearch),
                    security_scanner: Ok(value.security_scanner),
                    storage: Ok(value.storage),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct HealthDashboardResponse {
            avg_health_score: ::std::result::Result<i32, ::std::string::String>,
            repos_grade_a: ::std::result::Result<i64, ::std::string::String>,
            repos_grade_b: ::std::result::Result<i64, ::std::string::String>,
            repos_grade_c: ::std::result::Result<i64, ::std::string::String>,
            repos_grade_d: ::std::result::Result<i64, ::std::string::String>,
            repos_grade_f: ::std::result::Result<i64, ::std::string::String>,
            repositories: ::std::result::Result<
                ::std::vec::Vec<super::RepoHealthResponse>,
                ::std::string::String,
            >,
            total_artifacts_evaluated: ::std::result::Result<i64, ::std::string::String>,
            total_repositories: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for HealthDashboardResponse {
            fn default() -> Self {
                Self {
                    avg_health_score: Err("no value supplied for avg_health_score".to_string()),
                    repos_grade_a: Err("no value supplied for repos_grade_a".to_string()),
                    repos_grade_b: Err("no value supplied for repos_grade_b".to_string()),
                    repos_grade_c: Err("no value supplied for repos_grade_c".to_string()),
                    repos_grade_d: Err("no value supplied for repos_grade_d".to_string()),
                    repos_grade_f: Err("no value supplied for repos_grade_f".to_string()),
                    repositories: Err("no value supplied for repositories".to_string()),
                    total_artifacts_evaluated: Err(
                        "no value supplied for total_artifacts_evaluated".to_string(),
                    ),
                    total_repositories: Err("no value supplied for total_repositories".to_string()),
                }
            }
        }
        impl HealthDashboardResponse {
            pub fn avg_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.avg_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for avg_health_score: {e}")
                });
                self
            }
            pub fn repos_grade_a<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_a = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_a: {e}"));
                self
            }
            pub fn repos_grade_b<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_b = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_b: {e}"));
                self
            }
            pub fn repos_grade_c<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_c = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_c: {e}"));
                self
            }
            pub fn repos_grade_d<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_d = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_d: {e}"));
                self
            }
            pub fn repos_grade_f<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repos_grade_f = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repos_grade_f: {e}"));
                self
            }
            pub fn repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::RepoHealthResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.repositories = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repositories: {e}"));
                self
            }
            pub fn total_artifacts_evaluated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_artifacts_evaluated = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_artifacts_evaluated: {e}")
                });
                self
            }
            pub fn total_repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_repositories = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_repositories: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<HealthDashboardResponse> for super::HealthDashboardResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: HealthDashboardResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    avg_health_score: value.avg_health_score?,
                    repos_grade_a: value.repos_grade_a?,
                    repos_grade_b: value.repos_grade_b?,
                    repos_grade_c: value.repos_grade_c?,
                    repos_grade_d: value.repos_grade_d?,
                    repos_grade_f: value.repos_grade_f?,
                    repositories: value.repositories?,
                    total_artifacts_evaluated: value.total_artifacts_evaluated?,
                    total_repositories: value.total_repositories?,
                })
            }
        }
        impl ::std::convert::From<super::HealthDashboardResponse> for HealthDashboardResponse {
            fn from(value: super::HealthDashboardResponse) -> Self {
                Self {
                    avg_health_score: Ok(value.avg_health_score),
                    repos_grade_a: Ok(value.repos_grade_a),
                    repos_grade_b: Ok(value.repos_grade_b),
                    repos_grade_c: Ok(value.repos_grade_c),
                    repos_grade_d: Ok(value.repos_grade_d),
                    repos_grade_f: Ok(value.repos_grade_f),
                    repositories: Ok(value.repositories),
                    total_artifacts_evaluated: Ok(value.total_artifacts_evaluated),
                    total_repositories: Ok(value.total_repositories),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct HealthResponse {
            checks: ::std::result::Result<super::HealthChecks, ::std::string::String>,
            db_pool: ::std::result::Result<
                ::std::option::Option<super::DbPoolStats>,
                ::std::string::String,
            >,
            demo_mode: ::std::result::Result<bool, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for HealthResponse {
            fn default() -> Self {
                Self {
                    checks: Err("no value supplied for checks".to_string()),
                    db_pool: Ok(Default::default()),
                    demo_mode: Err("no value supplied for demo_mode".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl HealthResponse {
            pub fn checks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HealthChecks>,
                T::Error: ::std::fmt::Display,
            {
                self.checks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checks: {e}"));
                self
            }
            pub fn db_pool<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DbPoolStats>>,
                T::Error: ::std::fmt::Display,
            {
                self.db_pool = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for db_pool: {e}"));
                self
            }
            pub fn demo_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.demo_mode = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for demo_mode: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<HealthResponse> for super::HealthResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: HealthResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checks: value.checks?,
                    db_pool: value.db_pool?,
                    demo_mode: value.demo_mode?,
                    status: value.status?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::HealthResponse> for HealthResponse {
            fn from(value: super::HealthResponse) -> Self {
                Self {
                    checks: Ok(value.checks),
                    db_pool: Ok(value.db_pool),
                    demo_mode: Ok(value.demo_mode),
                    status: Ok(value.status),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct HeartbeatRequest {
            cache_used_bytes: ::std::result::Result<i64, ::std::string::String>,
            status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for HeartbeatRequest {
            fn default() -> Self {
                Self {
                    cache_used_bytes: Err("no value supplied for cache_used_bytes".to_string()),
                    status: Ok(Default::default()),
                }
            }
        }
        impl HeartbeatRequest {
            pub fn cache_used_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.cache_used_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cache_used_bytes: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<HeartbeatRequest> for super::HeartbeatRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: HeartbeatRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cache_used_bytes: value.cache_used_bytes?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::HeartbeatRequest> for HeartbeatRequest {
            fn from(value: super::HeartbeatRequest) -> Self {
                Self {
                    cache_used_bytes: Ok(value.cache_used_bytes),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct IdentityResponse {
            api_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            endpoint_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for IdentityResponse {
            fn default() -> Self {
                Self {
                    api_key: Err("no value supplied for api_key".to_string()),
                    endpoint_url: Err("no value supplied for endpoint_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    peer_id: Err("no value supplied for peer_id".to_string()),
                }
            }
        }
        impl IdentityResponse {
            pub fn api_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.api_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for api_key: {e}"));
                self
            }
            pub fn endpoint_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.peer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<IdentityResponse> for super::IdentityResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdentityResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    api_key: value.api_key?,
                    endpoint_url: value.endpoint_url?,
                    name: value.name?,
                    peer_id: value.peer_id?,
                })
            }
        }
        impl ::std::convert::From<super::IdentityResponse> for IdentityResponse {
            fn from(value: super::IdentityResponse) -> Self {
                Self {
                    api_key: Ok(value.api_key),
                    endpoint_url: Ok(value.endpoint_url),
                    name: Ok(value.name),
                    peer_id: Ok(value.peer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InitTransferBody {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            chunk_size: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        }
        impl ::std::default::Default for InitTransferBody {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    chunk_size: Ok(Default::default()),
                }
            }
        }
        impl InitTransferBody {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn chunk_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.chunk_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunk_size: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<InitTransferBody> for super::InitTransferBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InitTransferBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    chunk_size: value.chunk_size?,
                })
            }
        }
        impl ::std::convert::From<super::InitTransferBody> for InitTransferBody {
            fn from(value: super::InitTransferBody) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    chunk_size: Ok(value.chunk_size),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InstallFromGitRequest {
            ref_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for InstallFromGitRequest {
            fn default() -> Self {
                Self {
                    ref_: Ok(Default::default()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl InstallFromGitRequest {
            pub fn ref_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.ref_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ref_: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<InstallFromGitRequest> for super::InstallFromGitRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstallFromGitRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ref_: value.ref_?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::InstallFromGitRequest> for InstallFromGitRequest {
            fn from(value: super::InstallFromGitRequest) -> Self {
                Self {
                    ref_: Ok(value.ref_),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InstallFromLocalRequest {
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for InstallFromLocalRequest {
            fn default() -> Self {
                Self {
                    path: Err("no value supplied for path".to_string()),
                }
            }
        }
        impl InstallFromLocalRequest {
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<InstallFromLocalRequest> for super::InstallFromLocalRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstallFromLocalRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { path: value.path? })
            }
        }
        impl ::std::convert::From<super::InstallFromLocalRequest> for InstallFromLocalRequest {
            fn from(value: super::InstallFromLocalRequest) -> Self {
                Self {
                    path: Ok(value.path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct IssueResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            category: ::std::result::Result<::std::string::String, ::std::string::String>,
            check_result_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_suppressed: ::std::result::Result<bool, ::std::string::String>,
            location: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            suppressed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            suppressed_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            suppressed_reason: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            title: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for IssueResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    category: Err("no value supplied for category".to_string()),
                    check_result_id: Err("no value supplied for check_result_id".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    is_suppressed: Err("no value supplied for is_suppressed".to_string()),
                    location: Ok(Default::default()),
                    severity: Err("no value supplied for severity".to_string()),
                    suppressed_at: Ok(Default::default()),
                    suppressed_by: Ok(Default::default()),
                    suppressed_reason: Ok(Default::default()),
                    title: Err("no value supplied for title".to_string()),
                }
            }
        }
        impl IssueResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn category<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.category = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for category: {e}"));
                self
            }
            pub fn check_result_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.check_result_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for check_result_id: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_suppressed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_suppressed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_suppressed: {e}"));
                self
            }
            pub fn location<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.location = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for location: {e}"));
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
            pub fn suppressed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.suppressed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for suppressed_at: {e}"));
                self
            }
            pub fn suppressed_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.suppressed_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for suppressed_by: {e}"));
                self
            }
            pub fn suppressed_reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.suppressed_reason = value.try_into().map_err(|e| {
                    format!("error converting supplied value for suppressed_reason: {e}")
                });
                self
            }
            pub fn title<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.title = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for title: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<IssueResponse> for super::IssueResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IssueResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    category: value.category?,
                    check_result_id: value.check_result_id?,
                    created_at: value.created_at?,
                    description: value.description?,
                    id: value.id?,
                    is_suppressed: value.is_suppressed?,
                    location: value.location?,
                    severity: value.severity?,
                    suppressed_at: value.suppressed_at?,
                    suppressed_by: value.suppressed_by?,
                    suppressed_reason: value.suppressed_reason?,
                    title: value.title?,
                })
            }
        }
        impl ::std::convert::From<super::IssueResponse> for IssueResponse {
            fn from(value: super::IssueResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    category: Ok(value.category),
                    check_result_id: Ok(value.check_result_id),
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    is_suppressed: Ok(value.is_suppressed),
                    location: Ok(value.location),
                    severity: Ok(value.severity),
                    suppressed_at: Ok(value.suppressed_at),
                    suppressed_by: Ok(value.suppressed_by),
                    suppressed_reason: Ok(value.suppressed_reason),
                    title: Ok(value.title),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct KeyListResponse {
            keys: ::std::result::Result<
                ::std::vec::Vec<super::SigningKeyPublic>,
                ::std::string::String,
            >,
            total: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for KeyListResponse {
            fn default() -> Self {
                Self {
                    keys: Err("no value supplied for keys".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl KeyListResponse {
            pub fn keys<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SigningKeyPublic>>,
                T::Error: ::std::fmt::Display,
            {
                self.keys = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for keys: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<KeyListResponse> for super::KeyListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: KeyListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    keys: value.keys?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::KeyListResponse> for KeyListResponse {
            fn from(value: super::KeyListResponse) -> Self {
                Self {
                    keys: Ok(value.keys),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LabelEntrySchema {
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            value: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LabelEntrySchema {
            fn default() -> Self {
                Self {
                    key: Err("no value supplied for key".to_string()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl LabelEntrySchema {
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LabelEntrySchema> for super::LabelEntrySchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LabelEntrySchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key: value.key?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::LabelEntrySchema> for LabelEntrySchema {
            fn from(value: super::LabelEntrySchema) -> Self {
                Self {
                    key: Ok(value.key),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LabelResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LabelResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl LabelResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LabelResponse> for super::LabelResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LabelResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    key: value.key?,
                    repository_id: value.repository_id?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::LabelResponse> for LabelResponse {
            fn from(value: super::LabelResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    key: Ok(value.key),
                    repository_id: Ok(value.repository_id),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LabelsListResponse {
            items:
                ::std::result::Result<::std::vec::Vec<super::LabelResponse>, ::std::string::String>,
            total: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for LabelsListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl LabelsListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::LabelResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LabelsListResponse> for super::LabelsListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LabelsListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::LabelsListResponse> for LabelsListResponse {
            fn from(value: super::LabelsListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LdapConfigResponse {
            admin_group_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bind_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            display_name_attribute:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            email_attribute: ::std::result::Result<::std::string::String, ::std::string::String>,
            group_base_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            group_filter: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            groups_attribute: ::std::result::Result<::std::string::String, ::std::string::String>,
            has_bind_password: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
            server_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            use_starttls: ::std::result::Result<bool, ::std::string::String>,
            user_base_dn: ::std::result::Result<::std::string::String, ::std::string::String>,
            user_filter: ::std::result::Result<::std::string::String, ::std::string::String>,
            username_attribute: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LdapConfigResponse {
            fn default() -> Self {
                Self {
                    admin_group_dn: Ok(Default::default()),
                    bind_dn: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    display_name_attribute: Err(
                        "no value supplied for display_name_attribute".to_string()
                    ),
                    email_attribute: Err("no value supplied for email_attribute".to_string()),
                    group_base_dn: Ok(Default::default()),
                    group_filter: Ok(Default::default()),
                    groups_attribute: Err("no value supplied for groups_attribute".to_string()),
                    has_bind_password: Err("no value supplied for has_bind_password".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    server_url: Err("no value supplied for server_url".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                    use_starttls: Err("no value supplied for use_starttls".to_string()),
                    user_base_dn: Err("no value supplied for user_base_dn".to_string()),
                    user_filter: Err("no value supplied for user_filter".to_string()),
                    username_attribute: Err("no value supplied for username_attribute".to_string()),
                }
            }
        }
        impl LdapConfigResponse {
            pub fn admin_group_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group_dn = value.try_into().map_err(|e| {
                    format!("error converting supplied value for admin_group_dn: {e}")
                });
                self
            }
            pub fn bind_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bind_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bind_dn: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn display_name_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name_attribute: {e}")
                });
                self
            }
            pub fn email_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for email_attribute: {e}")
                });
                self
            }
            pub fn group_base_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_base_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group_base_dn: {e}"));
                self
            }
            pub fn group_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group_filter: {e}"));
                self
            }
            pub fn groups_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.groups_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for groups_attribute: {e}")
                });
                self
            }
            pub fn has_bind_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.has_bind_password = value.try_into().map_err(|e| {
                    format!("error converting supplied value for has_bind_password: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn server_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.server_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for server_url: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
            pub fn use_starttls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.use_starttls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for use_starttls: {e}"));
                self
            }
            pub fn user_base_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_base_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_base_dn: {e}"));
                self
            }
            pub fn user_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_filter: {e}"));
                self
            }
            pub fn username_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.username_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for username_attribute: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LdapConfigResponse> for super::LdapConfigResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LdapConfigResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group_dn: value.admin_group_dn?,
                    bind_dn: value.bind_dn?,
                    created_at: value.created_at?,
                    display_name_attribute: value.display_name_attribute?,
                    email_attribute: value.email_attribute?,
                    group_base_dn: value.group_base_dn?,
                    group_filter: value.group_filter?,
                    groups_attribute: value.groups_attribute?,
                    has_bind_password: value.has_bind_password?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    priority: value.priority?,
                    server_url: value.server_url?,
                    updated_at: value.updated_at?,
                    use_starttls: value.use_starttls?,
                    user_base_dn: value.user_base_dn?,
                    user_filter: value.user_filter?,
                    username_attribute: value.username_attribute?,
                })
            }
        }
        impl ::std::convert::From<super::LdapConfigResponse> for LdapConfigResponse {
            fn from(value: super::LdapConfigResponse) -> Self {
                Self {
                    admin_group_dn: Ok(value.admin_group_dn),
                    bind_dn: Ok(value.bind_dn),
                    created_at: Ok(value.created_at),
                    display_name_attribute: Ok(value.display_name_attribute),
                    email_attribute: Ok(value.email_attribute),
                    group_base_dn: Ok(value.group_base_dn),
                    group_filter: Ok(value.group_filter),
                    groups_attribute: Ok(value.groups_attribute),
                    has_bind_password: Ok(value.has_bind_password),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    server_url: Ok(value.server_url),
                    updated_at: Ok(value.updated_at),
                    use_starttls: Ok(value.use_starttls),
                    user_base_dn: Ok(value.user_base_dn),
                    user_filter: Ok(value.user_filter),
                    username_attribute: Ok(value.username_attribute),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LdapLoginRequest {
            password: ::std::result::Result<::std::string::String, ::std::string::String>,
            username: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LdapLoginRequest {
            fn default() -> Self {
                Self {
                    password: Err("no value supplied for password".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LdapLoginRequest {
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {e}"));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LdapLoginRequest> for super::LdapLoginRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LdapLoginRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    password: value.password?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LdapLoginRequest> for LdapLoginRequest {
            fn from(value: super::LdapLoginRequest) -> Self {
                Self {
                    password: Ok(value.password),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LdapTestResult {
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            response_time_ms: ::std::result::Result<i64, ::std::string::String>,
            success: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for LdapTestResult {
            fn default() -> Self {
                Self {
                    message: Err("no value supplied for message".to_string()),
                    response_time_ms: Err("no value supplied for response_time_ms".to_string()),
                    success: Err("no value supplied for success".to_string()),
                }
            }
        }
        impl LdapTestResult {
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn response_time_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.response_time_ms = value.try_into().map_err(|e| {
                    format!("error converting supplied value for response_time_ms: {e}")
                });
                self
            }
            pub fn success<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.success = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for success: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LdapTestResult> for super::LdapTestResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LdapTestResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    message: value.message?,
                    response_time_ms: value.response_time_ms?,
                    success: value.success?,
                })
            }
        }
        impl ::std::convert::From<super::LdapTestResult> for LdapTestResult {
            fn from(value: super::LdapTestResult) -> Self {
                Self {
                    message: Ok(value.message),
                    response_time_ms: Ok(value.response_time_ms),
                    success: Ok(value.success),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LicenseCheckResult {
            compliant: ::std::result::Result<bool, ::std::string::String>,
            violations: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            warnings: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LicenseCheckResult {
            fn default() -> Self {
                Self {
                    compliant: Err("no value supplied for compliant".to_string()),
                    violations: Err("no value supplied for violations".to_string()),
                    warnings: Err("no value supplied for warnings".to_string()),
                }
            }
        }
        impl LicenseCheckResult {
            pub fn compliant<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.compliant = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for compliant: {e}"));
                self
            }
            pub fn violations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.violations = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for violations: {e}"));
                self
            }
            pub fn warnings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.warnings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for warnings: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LicenseCheckResult> for super::LicenseCheckResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LicenseCheckResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    compliant: value.compliant?,
                    violations: value.violations?,
                    warnings: value.warnings?,
                })
            }
        }
        impl ::std::convert::From<super::LicenseCheckResult> for LicenseCheckResult {
            fn from(value: super::LicenseCheckResult) -> Self {
                Self {
                    compliant: Ok(value.compliant),
                    violations: Ok(value.violations),
                    warnings: Ok(value.warnings),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LicensePolicyResponse {
            action: ::std::result::Result<::std::string::String, ::std::string::String>,
            allow_unknown: ::std::result::Result<bool, ::std::string::String>,
            allowed_licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            denied_licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LicensePolicyResponse {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    allow_unknown: Err("no value supplied for allow_unknown".to_string()),
                    allowed_licenses: Err("no value supplied for allowed_licenses".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    denied_licenses: Err("no value supplied for denied_licenses".to_string()),
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    updated_at: Ok(Default::default()),
                }
            }
        }
        impl LicensePolicyResponse {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {e}"));
                self
            }
            pub fn allow_unknown<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.allow_unknown = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allow_unknown: {e}"));
                self
            }
            pub fn allowed_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_licenses: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn denied_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.denied_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for denied_licenses: {e}")
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LicensePolicyResponse> for super::LicensePolicyResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LicensePolicyResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    allow_unknown: value.allow_unknown?,
                    allowed_licenses: value.allowed_licenses?,
                    created_at: value.created_at?,
                    denied_licenses: value.denied_licenses?,
                    description: value.description?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::LicensePolicyResponse> for LicensePolicyResponse {
            fn from(value: super::LicensePolicyResponse) -> Self {
                Self {
                    action: Ok(value.action),
                    allow_unknown: Ok(value.allow_unknown),
                    allowed_licenses: Ok(value.allowed_licenses),
                    created_at: Ok(value.created_at),
                    denied_licenses: Ok(value.denied_licenses),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LifecyclePolicy {
            config: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enabled: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_run_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            last_run_items_removed:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            policy_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LifecyclePolicy {
            fn default() -> Self {
                Self {
                    config: Err("no value supplied for config".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    enabled: Err("no value supplied for enabled".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    last_run_at: Ok(Default::default()),
                    last_run_items_removed: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    policy_type: Err("no value supplied for policy_type".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    repository_id: Ok(Default::default()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl LifecyclePolicy {
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn last_run_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_run_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_run_at: {e}"));
                self
            }
            pub fn last_run_items_removed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_run_items_removed = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_run_items_removed: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn policy_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_type: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LifecyclePolicy> for super::LifecyclePolicy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LifecyclePolicy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    config: value.config?,
                    created_at: value.created_at?,
                    description: value.description?,
                    enabled: value.enabled?,
                    id: value.id?,
                    last_run_at: value.last_run_at?,
                    last_run_items_removed: value.last_run_items_removed?,
                    name: value.name?,
                    policy_type: value.policy_type?,
                    priority: value.priority?,
                    repository_id: value.repository_id?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::LifecyclePolicy> for LifecyclePolicy {
            fn from(value: super::LifecyclePolicy) -> Self {
                Self {
                    config: Ok(value.config),
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    enabled: Ok(value.enabled),
                    id: Ok(value.id),
                    last_run_at: Ok(value.last_run_at),
                    last_run_items_removed: Ok(value.last_run_items_removed),
                    name: Ok(value.name),
                    policy_type: Ok(value.policy_type),
                    priority: Ok(value.priority),
                    repository_id: Ok(value.repository_id),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListArtifactsQuery {
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            path_prefix: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            q: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListArtifactsQuery {
            fn default() -> Self {
                Self {
                    page: Ok(Default::default()),
                    path_prefix: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    q: Ok(Default::default()),
                }
            }
        }
        impl ListArtifactsQuery {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn path_prefix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.path_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path_prefix: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn q<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.q = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for q: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListArtifactsQuery> for super::ListArtifactsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListArtifactsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    path_prefix: value.path_prefix?,
                    per_page: value.per_page?,
                    q: value.q?,
                })
            }
        }
        impl ::std::convert::From<super::ListArtifactsQuery> for ListArtifactsQuery {
            fn from(value: super::ListArtifactsQuery) -> Self {
                Self {
                    page: Ok(value.page),
                    path_prefix: Ok(value.path_prefix),
                    per_page: Ok(value.per_page),
                    q: Ok(value.q),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListBackupsQuery {
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListBackupsQuery {
            fn default() -> Self {
                Self {
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    status: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl ListBackupsQuery {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListBackupsQuery> for super::ListBackupsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListBackupsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    per_page: value.per_page?,
                    status: value.status?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::ListBackupsQuery> for ListBackupsQuery {
            fn from(value: super::ListBackupsQuery) -> Self {
                Self {
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    status: Ok(value.status),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListBuildsQuery {
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            search: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sort_by: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sort_order: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListBuildsQuery {
            fn default() -> Self {
                Self {
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    search: Ok(Default::default()),
                    sort_by: Ok(Default::default()),
                    sort_order: Ok(Default::default()),
                    status: Ok(Default::default()),
                }
            }
        }
        impl ListBuildsQuery {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn search<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.search = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for search: {e}"));
                self
            }
            pub fn sort_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sort_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sort_by: {e}"));
                self
            }
            pub fn sort_order<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sort_order = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sort_order: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListBuildsQuery> for super::ListBuildsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListBuildsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    per_page: value.per_page?,
                    search: value.search?,
                    sort_by: value.sort_by?,
                    sort_order: value.sort_order?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::ListBuildsQuery> for ListBuildsQuery {
            fn from(value: super::ListBuildsQuery) -> Self {
                Self {
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    search: Ok(value.search),
                    sort_by: Ok(value.sort_by),
                    sort_order: Ok(value.sort_order),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListFormatsQuery {
            enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            type_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListFormatsQuery {
            fn default() -> Self {
                Self {
                    enabled: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl ListFormatsQuery {
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListFormatsQuery> for super::ListFormatsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListFormatsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    enabled: value.enabled?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::ListFormatsQuery> for ListFormatsQuery {
            fn from(value: super::ListFormatsQuery) -> Self {
                Self {
                    enabled: Ok(value.enabled),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListKeysQuery {
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for ListKeysQuery {
            fn default() -> Self {
                Self {
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl ListKeysQuery {
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListKeysQuery> for super::ListKeysQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListKeysQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::ListKeysQuery> for ListKeysQuery {
            fn from(value: super::ListKeysQuery) -> Self {
                Self {
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListPluginsQuery {
            status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListPluginsQuery {
            fn default() -> Self {
                Self {
                    status: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl ListPluginsQuery {
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListPluginsQuery> for super::ListPluginsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListPluginsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    status: value.status?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::ListPluginsQuery> for ListPluginsQuery {
            fn from(value: super::ListPluginsQuery) -> Self {
                Self {
                    status: Ok(value.status),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListRepositoriesQuery {
            format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            q: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListRepositoriesQuery {
            fn default() -> Self {
                Self {
                    format: Ok(Default::default()),
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    q: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl ListRepositoriesQuery {
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn q<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.q = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for q: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListRepositoriesQuery> for super::ListRepositoriesQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListRepositoriesQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    format: value.format?,
                    page: value.page?,
                    per_page: value.per_page?,
                    q: value.q?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::ListRepositoriesQuery> for ListRepositoriesQuery {
            fn from(value: super::ListRepositoriesQuery) -> Self {
                Self {
                    format: Ok(value.format),
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    q: Ok(value.q),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListSbomsQuery {
            artifact_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for ListSbomsQuery {
            fn default() -> Self {
                Self {
                    artifact_id: Ok(Default::default()),
                    format: Ok(Default::default()),
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl ListSbomsQuery {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListSbomsQuery> for super::ListSbomsQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListSbomsQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    format: value.format?,
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::ListSbomsQuery> for ListSbomsQuery {
            fn from(value: super::ListSbomsQuery) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    format: Ok(value.format),
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListUsersQuery {
            is_active: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            is_admin: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            search: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListUsersQuery {
            fn default() -> Self {
                Self {
                    is_active: Ok(Default::default()),
                    is_admin: Ok(Default::default()),
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    search: Ok(Default::default()),
                }
            }
        }
        impl ListUsersQuery {
            pub fn is_active<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_active = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_active: {e}"));
                self
            }
            pub fn is_admin<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_admin = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_admin: {e}"));
                self
            }
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn search<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.search = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for search: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ListUsersQuery> for super::ListUsersQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListUsersQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_active: value.is_active?,
                    is_admin: value.is_admin?,
                    page: value.page?,
                    per_page: value.per_page?,
                    search: value.search?,
                })
            }
        }
        impl ::std::convert::From<super::ListUsersQuery> for ListUsersQuery {
            fn from(value: super::ListUsersQuery) -> Self {
                Self {
                    is_active: Ok(value.is_active),
                    is_admin: Ok(value.is_admin),
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    search: Ok(value.search),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LivezResponse {
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LivezResponse {
            fn default() -> Self {
                Self {
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl LivezResponse {
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LivezResponse> for super::LivezResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LivezResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::LivezResponse> for LivezResponse {
            fn from(value: super::LivezResponse) -> Self {
                Self {
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LoginRequest {
            password: ::std::result::Result<::std::string::String, ::std::string::String>,
            username: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LoginRequest {
            fn default() -> Self {
                Self {
                    password: Err("no value supplied for password".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LoginRequest {
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {e}"));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LoginRequest> for super::LoginRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LoginRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    password: value.password?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LoginRequest> for LoginRequest {
            fn from(value: super::LoginRequest) -> Self {
                Self {
                    password: Ok(value.password),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LoginResponse {
            access_token: ::std::result::Result<::std::string::String, ::std::string::String>,
            expires_in: ::std::result::Result<i64, ::std::string::String>,
            must_change_password: ::std::result::Result<bool, ::std::string::String>,
            refresh_token: ::std::result::Result<::std::string::String, ::std::string::String>,
            token_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            totp_required:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            totp_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LoginResponse {
            fn default() -> Self {
                Self {
                    access_token: Err("no value supplied for access_token".to_string()),
                    expires_in: Err("no value supplied for expires_in".to_string()),
                    must_change_password: Err(
                        "no value supplied for must_change_password".to_string()
                    ),
                    refresh_token: Err("no value supplied for refresh_token".to_string()),
                    token_type: Err("no value supplied for token_type".to_string()),
                    totp_required: Ok(Default::default()),
                    totp_token: Ok(Default::default()),
                }
            }
        }
        impl LoginResponse {
            pub fn access_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.access_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for access_token: {e}"));
                self
            }
            pub fn expires_in<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.expires_in = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for expires_in: {e}"));
                self
            }
            pub fn must_change_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.must_change_password = value.try_into().map_err(|e| {
                    format!("error converting supplied value for must_change_password: {e}")
                });
                self
            }
            pub fn refresh_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.refresh_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for refresh_token: {e}"));
                self
            }
            pub fn token_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.token_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token_type: {e}"));
                self
            }
            pub fn totp_required<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.totp_required = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for totp_required: {e}"));
                self
            }
            pub fn totp_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.totp_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for totp_token: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<LoginResponse> for super::LoginResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LoginResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    access_token: value.access_token?,
                    expires_in: value.expires_in?,
                    must_change_password: value.must_change_password?,
                    refresh_token: value.refresh_token?,
                    token_type: value.token_type?,
                    totp_required: value.totp_required?,
                    totp_token: value.totp_token?,
                })
            }
        }
        impl ::std::convert::From<super::LoginResponse> for LoginResponse {
            fn from(value: super::LoginResponse) -> Self {
                Self {
                    access_token: Ok(value.access_token),
                    expires_in: Ok(value.expires_in),
                    must_change_password: Ok(value.must_change_password),
                    refresh_token: Ok(value.refresh_token),
                    token_type: Ok(value.token_type),
                    totp_required: Ok(value.totp_required),
                    totp_token: Ok(value.totp_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MatchedPeerSchema {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            region: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for MatchedPeerSchema {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    region: Ok(Default::default()),
                }
            }
        }
        impl MatchedPeerSchema {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn region<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.region = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for region: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MatchedPeerSchema> for super::MatchedPeerSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MatchedPeerSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    region: value.region?,
                })
            }
        }
        impl ::std::convert::From<super::MatchedPeerSchema> for MatchedPeerSchema {
            fn from(value: super::MatchedPeerSchema) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    region: Ok(value.region),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MatchedRepoSchema {
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for MatchedRepoSchema {
            fn default() -> Self {
                Self {
                    format: Err("no value supplied for format".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    key: Err("no value supplied for key".to_string()),
                }
            }
        }
        impl MatchedRepoSchema {
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MatchedRepoSchema> for super::MatchedRepoSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MatchedRepoSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    format: value.format?,
                    id: value.id?,
                    key: value.key?,
                })
            }
        }
        impl ::std::convert::From<super::MatchedRepoSchema> for MatchedRepoSchema {
            fn from(value: super::MatchedRepoSchema) -> Self {
                Self {
                    format: Ok(value.format),
                    id: Ok(value.id),
                    key: Ok(value.key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MembersRequest {
            user_ids: ::std::result::Result<::std::vec::Vec<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for MembersRequest {
            fn default() -> Self {
                Self {
                    user_ids: Err("no value supplied for user_ids".to_string()),
                }
            }
        }
        impl MembersRequest {
            pub fn user_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.user_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_ids: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MembersRequest> for super::MembersRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MembersRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    user_ids: value.user_ids?,
                })
            }
        }
        impl ::std::convert::From<super::MembersRequest> for MembersRequest {
            fn from(value: super::MembersRequest) -> Self {
                Self {
                    user_ids: Ok(value.user_ids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MigrationItemResponse {
            checksum_source: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            checksum_target: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            completed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            error_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            item_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            job_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            retry_count: ::std::result::Result<i32, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            source_path: ::std::result::Result<::std::string::String, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_path: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for MigrationItemResponse {
            fn default() -> Self {
                Self {
                    checksum_source: Ok(Default::default()),
                    checksum_target: Ok(Default::default()),
                    completed_at: Ok(Default::default()),
                    error_message: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    item_type: Err("no value supplied for item_type".to_string()),
                    job_id: Err("no value supplied for job_id".to_string()),
                    retry_count: Err("no value supplied for retry_count".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    source_path: Err("no value supplied for source_path".to_string()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    target_path: Ok(Default::default()),
                }
            }
        }
        impl MigrationItemResponse {
            pub fn checksum_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_source: {e}")
                });
                self
            }
            pub fn checksum_target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_target = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_target: {e}")
                });
                self
            }
            pub fn completed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.completed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for completed_at: {e}"));
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_message: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn item_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.item_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for item_type: {e}"));
                self
            }
            pub fn job_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.job_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_id: {e}"));
                self
            }
            pub fn retry_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.retry_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for retry_count: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn source_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_path: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn target_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.target_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_path: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MigrationItemResponse> for super::MigrationItemResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MigrationItemResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_source: value.checksum_source?,
                    checksum_target: value.checksum_target?,
                    completed_at: value.completed_at?,
                    error_message: value.error_message?,
                    id: value.id?,
                    item_type: value.item_type?,
                    job_id: value.job_id?,
                    retry_count: value.retry_count?,
                    size_bytes: value.size_bytes?,
                    source_path: value.source_path?,
                    started_at: value.started_at?,
                    status: value.status?,
                    target_path: value.target_path?,
                })
            }
        }
        impl ::std::convert::From<super::MigrationItemResponse> for MigrationItemResponse {
            fn from(value: super::MigrationItemResponse) -> Self {
                Self {
                    checksum_source: Ok(value.checksum_source),
                    checksum_target: Ok(value.checksum_target),
                    completed_at: Ok(value.completed_at),
                    error_message: Ok(value.error_message),
                    id: Ok(value.id),
                    item_type: Ok(value.item_type),
                    job_id: Ok(value.job_id),
                    retry_count: Ok(value.retry_count),
                    size_bytes: Ok(value.size_bytes),
                    source_path: Ok(value.source_path),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    target_path: Ok(value.target_path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MigrationItemRow {
            checksum_source: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            checksum_target: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            completed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            error_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            item_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            job_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            metadata: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            retry_count: ::std::result::Result<i32, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            source_path: ::std::result::Result<::std::string::String, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_path: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for MigrationItemRow {
            fn default() -> Self {
                Self {
                    checksum_source: Ok(Default::default()),
                    checksum_target: Ok(Default::default()),
                    completed_at: Ok(Default::default()),
                    error_message: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    item_type: Err("no value supplied for item_type".to_string()),
                    job_id: Err("no value supplied for job_id".to_string()),
                    metadata: Err("no value supplied for metadata".to_string()),
                    retry_count: Err("no value supplied for retry_count".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    source_path: Err("no value supplied for source_path".to_string()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    target_path: Ok(Default::default()),
                }
            }
        }
        impl MigrationItemRow {
            pub fn checksum_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_source: {e}")
                });
                self
            }
            pub fn checksum_target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_target = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_target: {e}")
                });
                self
            }
            pub fn completed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.completed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for completed_at: {e}"));
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_message: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn item_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.item_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for item_type: {e}"));
                self
            }
            pub fn job_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.job_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_id: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn retry_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.retry_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for retry_count: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn source_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_path: {e}"));
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn target_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.target_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_path: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MigrationItemRow> for super::MigrationItemRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MigrationItemRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_source: value.checksum_source?,
                    checksum_target: value.checksum_target?,
                    completed_at: value.completed_at?,
                    error_message: value.error_message?,
                    id: value.id?,
                    item_type: value.item_type?,
                    job_id: value.job_id?,
                    metadata: value.metadata?,
                    retry_count: value.retry_count?,
                    size_bytes: value.size_bytes?,
                    source_path: value.source_path?,
                    started_at: value.started_at?,
                    status: value.status?,
                    target_path: value.target_path?,
                })
            }
        }
        impl ::std::convert::From<super::MigrationItemRow> for MigrationItemRow {
            fn from(value: super::MigrationItemRow) -> Self {
                Self {
                    checksum_source: Ok(value.checksum_source),
                    checksum_target: Ok(value.checksum_target),
                    completed_at: Ok(value.completed_at),
                    error_message: Ok(value.error_message),
                    id: Ok(value.id),
                    item_type: Ok(value.item_type),
                    job_id: Ok(value.job_id),
                    metadata: Ok(value.metadata),
                    retry_count: Ok(value.retry_count),
                    size_bytes: Ok(value.size_bytes),
                    source_path: Ok(value.source_path),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    target_path: Ok(value.target_path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MigrationJobResponse {
            completed_items: ::std::result::Result<i32, ::std::string::String>,
            config: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            error_summary: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            estimated_time_remaining:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            failed_items: ::std::result::Result<i32, ::std::string::String>,
            finished_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            job_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            progress_percent: ::std::result::Result<f64, ::std::string::String>,
            skipped_items: ::std::result::Result<i32, ::std::string::String>,
            source_connection_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            total_bytes: ::std::result::Result<i64, ::std::string::String>,
            total_items: ::std::result::Result<i32, ::std::string::String>,
            transferred_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for MigrationJobResponse {
            fn default() -> Self {
                Self {
                    completed_items: Err("no value supplied for completed_items".to_string()),
                    config: Err("no value supplied for config".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    error_summary: Ok(Default::default()),
                    estimated_time_remaining: Ok(Default::default()),
                    failed_items: Err("no value supplied for failed_items".to_string()),
                    finished_at: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    job_type: Err("no value supplied for job_type".to_string()),
                    progress_percent: Err("no value supplied for progress_percent".to_string()),
                    skipped_items: Err("no value supplied for skipped_items".to_string()),
                    source_connection_id: Err(
                        "no value supplied for source_connection_id".to_string()
                    ),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    total_bytes: Err("no value supplied for total_bytes".to_string()),
                    total_items: Err("no value supplied for total_items".to_string()),
                    transferred_bytes: Err("no value supplied for transferred_bytes".to_string()),
                }
            }
        }
        impl MigrationJobResponse {
            pub fn completed_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.completed_items = value.try_into().map_err(|e| {
                    format!("error converting supplied value for completed_items: {e}")
                });
                self
            }
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn error_summary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_summary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_summary: {e}"));
                self
            }
            pub fn estimated_time_remaining<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.estimated_time_remaining = value.try_into().map_err(|e| {
                    format!("error converting supplied value for estimated_time_remaining: {e}")
                });
                self
            }
            pub fn failed_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.failed_items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for failed_items: {e}"));
                self
            }
            pub fn finished_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.finished_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for finished_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn job_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.job_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_type: {e}"));
                self
            }
            pub fn progress_percent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.progress_percent = value.try_into().map_err(|e| {
                    format!("error converting supplied value for progress_percent: {e}")
                });
                self
            }
            pub fn skipped_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.skipped_items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for skipped_items: {e}"));
                self
            }
            pub fn source_connection_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.source_connection_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_connection_id: {e}")
                });
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn total_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_bytes: {e}"));
                self
            }
            pub fn total_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_items: {e}"));
                self
            }
            pub fn transferred_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.transferred_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transferred_bytes: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<MigrationJobResponse> for super::MigrationJobResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MigrationJobResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    completed_items: value.completed_items?,
                    config: value.config?,
                    created_at: value.created_at?,
                    error_summary: value.error_summary?,
                    estimated_time_remaining: value.estimated_time_remaining?,
                    failed_items: value.failed_items?,
                    finished_at: value.finished_at?,
                    id: value.id?,
                    job_type: value.job_type?,
                    progress_percent: value.progress_percent?,
                    skipped_items: value.skipped_items?,
                    source_connection_id: value.source_connection_id?,
                    started_at: value.started_at?,
                    status: value.status?,
                    total_bytes: value.total_bytes?,
                    total_items: value.total_items?,
                    transferred_bytes: value.transferred_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::MigrationJobResponse> for MigrationJobResponse {
            fn from(value: super::MigrationJobResponse) -> Self {
                Self {
                    completed_items: Ok(value.completed_items),
                    config: Ok(value.config),
                    created_at: Ok(value.created_at),
                    error_summary: Ok(value.error_summary),
                    estimated_time_remaining: Ok(value.estimated_time_remaining),
                    failed_items: Ok(value.failed_items),
                    finished_at: Ok(value.finished_at),
                    id: Ok(value.id),
                    job_type: Ok(value.job_type),
                    progress_percent: Ok(value.progress_percent),
                    skipped_items: Ok(value.skipped_items),
                    source_connection_id: Ok(value.source_connection_id),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    total_bytes: Ok(value.total_bytes),
                    total_items: Ok(value.total_items),
                    transferred_bytes: Ok(value.transferred_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MigrationJobRow {
            completed_items: ::std::result::Result<i32, ::std::string::String>,
            config: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            created_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            error_summary: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            failed_items: ::std::result::Result<i32, ::std::string::String>,
            finished_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            job_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            skipped_items: ::std::result::Result<i32, ::std::string::String>,
            source_connection_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            total_bytes: ::std::result::Result<i64, ::std::string::String>,
            total_items: ::std::result::Result<i32, ::std::string::String>,
            transferred_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for MigrationJobRow {
            fn default() -> Self {
                Self {
                    completed_items: Err("no value supplied for completed_items".to_string()),
                    config: Err("no value supplied for config".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    created_by: Ok(Default::default()),
                    error_summary: Ok(Default::default()),
                    failed_items: Err("no value supplied for failed_items".to_string()),
                    finished_at: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    job_type: Err("no value supplied for job_type".to_string()),
                    skipped_items: Err("no value supplied for skipped_items".to_string()),
                    source_connection_id: Err(
                        "no value supplied for source_connection_id".to_string()
                    ),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    total_bytes: Err("no value supplied for total_bytes".to_string()),
                    total_items: Err("no value supplied for total_items".to_string()),
                    transferred_bytes: Err("no value supplied for transferred_bytes".to_string()),
                }
            }
        }
        impl MigrationJobRow {
            pub fn completed_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.completed_items = value.try_into().map_err(|e| {
                    format!("error converting supplied value for completed_items: {e}")
                });
                self
            }
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn created_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_by: {e}"));
                self
            }
            pub fn error_summary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_summary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_summary: {e}"));
                self
            }
            pub fn failed_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.failed_items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for failed_items: {e}"));
                self
            }
            pub fn finished_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.finished_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for finished_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn job_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.job_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_type: {e}"));
                self
            }
            pub fn skipped_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.skipped_items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for skipped_items: {e}"));
                self
            }
            pub fn source_connection_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.source_connection_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_connection_id: {e}")
                });
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn total_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_bytes: {e}"));
                self
            }
            pub fn total_items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_items: {e}"));
                self
            }
            pub fn transferred_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.transferred_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transferred_bytes: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<MigrationJobRow> for super::MigrationJobRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MigrationJobRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    completed_items: value.completed_items?,
                    config: value.config?,
                    created_at: value.created_at?,
                    created_by: value.created_by?,
                    error_summary: value.error_summary?,
                    failed_items: value.failed_items?,
                    finished_at: value.finished_at?,
                    id: value.id?,
                    job_type: value.job_type?,
                    skipped_items: value.skipped_items?,
                    source_connection_id: value.source_connection_id?,
                    started_at: value.started_at?,
                    status: value.status?,
                    total_bytes: value.total_bytes?,
                    total_items: value.total_items?,
                    transferred_bytes: value.transferred_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::MigrationJobRow> for MigrationJobRow {
            fn from(value: super::MigrationJobRow) -> Self {
                Self {
                    completed_items: Ok(value.completed_items),
                    config: Ok(value.config),
                    created_at: Ok(value.created_at),
                    created_by: Ok(value.created_by),
                    error_summary: Ok(value.error_summary),
                    failed_items: Ok(value.failed_items),
                    finished_at: Ok(value.finished_at),
                    id: Ok(value.id),
                    job_type: Ok(value.job_type),
                    skipped_items: Ok(value.skipped_items),
                    source_connection_id: Ok(value.source_connection_id),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                    total_bytes: Ok(value.total_bytes),
                    total_items: Ok(value.total_items),
                    transferred_bytes: Ok(value.transferred_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MigrationReportResponse {
            errors: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            generated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            job_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            recommendations: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            summary: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            warnings: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for MigrationReportResponse {
            fn default() -> Self {
                Self {
                    errors: Err("no value supplied for errors".to_string()),
                    generated_at: Err("no value supplied for generated_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    job_id: Err("no value supplied for job_id".to_string()),
                    recommendations: Err("no value supplied for recommendations".to_string()),
                    summary: Err("no value supplied for summary".to_string()),
                    warnings: Err("no value supplied for warnings".to_string()),
                }
            }
        }
        impl MigrationReportResponse {
            pub fn errors<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.errors = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for errors: {e}"));
                self
            }
            pub fn generated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.generated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generated_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn job_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.job_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_id: {e}"));
                self
            }
            pub fn recommendations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.recommendations = value.try_into().map_err(|e| {
                    format!("error converting supplied value for recommendations: {e}")
                });
                self
            }
            pub fn summary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.summary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for summary: {e}"));
                self
            }
            pub fn warnings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.warnings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for warnings: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MigrationReportResponse> for super::MigrationReportResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MigrationReportResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    errors: value.errors?,
                    generated_at: value.generated_at?,
                    id: value.id?,
                    job_id: value.job_id?,
                    recommendations: value.recommendations?,
                    summary: value.summary?,
                    warnings: value.warnings?,
                })
            }
        }
        impl ::std::convert::From<super::MigrationReportResponse> for MigrationReportResponse {
            fn from(value: super::MigrationReportResponse) -> Self {
                Self {
                    errors: Ok(value.errors),
                    generated_at: Ok(value.generated_at),
                    id: Ok(value.id),
                    job_id: Ok(value.job_id),
                    recommendations: Ok(value.recommendations),
                    summary: Ok(value.summary),
                    warnings: Ok(value.warnings),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MigrationReportRow {
            errors: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            generated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            job_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            recommendations: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            summary: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            warnings: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for MigrationReportRow {
            fn default() -> Self {
                Self {
                    errors: Err("no value supplied for errors".to_string()),
                    generated_at: Err("no value supplied for generated_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    job_id: Err("no value supplied for job_id".to_string()),
                    recommendations: Err("no value supplied for recommendations".to_string()),
                    summary: Err("no value supplied for summary".to_string()),
                    warnings: Err("no value supplied for warnings".to_string()),
                }
            }
        }
        impl MigrationReportRow {
            pub fn errors<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.errors = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for errors: {e}"));
                self
            }
            pub fn generated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.generated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generated_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn job_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.job_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job_id: {e}"));
                self
            }
            pub fn recommendations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.recommendations = value.try_into().map_err(|e| {
                    format!("error converting supplied value for recommendations: {e}")
                });
                self
            }
            pub fn summary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.summary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for summary: {e}"));
                self
            }
            pub fn warnings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.warnings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for warnings: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<MigrationReportRow> for super::MigrationReportRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MigrationReportRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    errors: value.errors?,
                    generated_at: value.generated_at?,
                    id: value.id?,
                    job_id: value.job_id?,
                    recommendations: value.recommendations?,
                    summary: value.summary?,
                    warnings: value.warnings?,
                })
            }
        }
        impl ::std::convert::From<super::MigrationReportRow> for MigrationReportRow {
            fn from(value: super::MigrationReportRow) -> Self {
                Self {
                    errors: Ok(value.errors),
                    generated_at: Ok(value.generated_at),
                    id: Ok(value.id),
                    job_id: Ok(value.job_id),
                    recommendations: Ok(value.recommendations),
                    summary: Ok(value.summary),
                    warnings: Ok(value.warnings),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NetworkProfileBody {
            concurrent_transfers_limit:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_bandwidth_bps:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            sync_window_end: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sync_window_start: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sync_window_timezone: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for NetworkProfileBody {
            fn default() -> Self {
                Self {
                    concurrent_transfers_limit: Ok(Default::default()),
                    max_bandwidth_bps: Ok(Default::default()),
                    sync_window_end: Ok(Default::default()),
                    sync_window_start: Ok(Default::default()),
                    sync_window_timezone: Ok(Default::default()),
                }
            }
        }
        impl NetworkProfileBody {
            pub fn concurrent_transfers_limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.concurrent_transfers_limit = value.try_into().map_err(|e| {
                    format!("error converting supplied value for concurrent_transfers_limit: {e}")
                });
                self
            }
            pub fn max_bandwidth_bps<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_bandwidth_bps = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_bandwidth_bps: {e}")
                });
                self
            }
            pub fn sync_window_end<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sync_window_end = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sync_window_end: {e}")
                });
                self
            }
            pub fn sync_window_start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sync_window_start = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sync_window_start: {e}")
                });
                self
            }
            pub fn sync_window_timezone<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sync_window_timezone = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sync_window_timezone: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<NetworkProfileBody> for super::NetworkProfileBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkProfileBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    concurrent_transfers_limit: value.concurrent_transfers_limit?,
                    max_bandwidth_bps: value.max_bandwidth_bps?,
                    sync_window_end: value.sync_window_end?,
                    sync_window_start: value.sync_window_start?,
                    sync_window_timezone: value.sync_window_timezone?,
                })
            }
        }
        impl ::std::convert::From<super::NetworkProfileBody> for NetworkProfileBody {
            fn from(value: super::NetworkProfileBody) -> Self {
                Self {
                    concurrent_transfers_limit: Ok(value.concurrent_transfers_limit),
                    max_bandwidth_bps: Ok(value.max_bandwidth_bps),
                    sync_window_end: Ok(value.sync_window_end),
                    sync_window_start: Ok(value.sync_window_start),
                    sync_window_timezone: Ok(value.sync_window_timezone),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OidcConfigResponse {
            attribute_mapping: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            auto_create_users: ::std::result::Result<bool, ::std::string::String>,
            client_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            has_secret: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            issuer_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            scopes: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OidcConfigResponse {
            fn default() -> Self {
                Self {
                    attribute_mapping: Err("no value supplied for attribute_mapping".to_string()),
                    auto_create_users: Err("no value supplied for auto_create_users".to_string()),
                    client_id: Err("no value supplied for client_id".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    has_secret: Err("no value supplied for has_secret".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    issuer_url: Err("no value supplied for issuer_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    scopes: Err("no value supplied for scopes".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl OidcConfigResponse {
            pub fn attribute_mapping<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.attribute_mapping = value.try_into().map_err(|e| {
                    format!("error converting supplied value for attribute_mapping: {e}")
                });
                self
            }
            pub fn auto_create_users<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_create_users = value.try_into().map_err(|e| {
                    format!("error converting supplied value for auto_create_users: {e}")
                });
                self
            }
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn has_secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.has_secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for has_secret: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn issuer_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.issuer_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issuer_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn scopes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.scopes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scopes: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<OidcConfigResponse> for super::OidcConfigResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OidcConfigResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    attribute_mapping: value.attribute_mapping?,
                    auto_create_users: value.auto_create_users?,
                    client_id: value.client_id?,
                    created_at: value.created_at?,
                    has_secret: value.has_secret?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    issuer_url: value.issuer_url?,
                    name: value.name?,
                    scopes: value.scopes?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::OidcConfigResponse> for OidcConfigResponse {
            fn from(value: super::OidcConfigResponse) -> Self {
                Self {
                    attribute_mapping: Ok(value.attribute_mapping),
                    auto_create_users: Ok(value.auto_create_users),
                    client_id: Ok(value.client_id),
                    created_at: Ok(value.created_at),
                    has_secret: Ok(value.has_secret),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    issuer_url: Ok(value.issuer_url),
                    name: Ok(value.name),
                    scopes: Ok(value.scopes),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PackageResponse>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for PackageListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl PackageListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PackageResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PackageListResponse> for super::PackageListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::PackageListResponse> for PackageListResponse {
            fn from(value: super::PackageListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            metadata: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PackageResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    format: Err("no value supplied for format".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    metadata: Err("no value supplied for metadata".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PackageResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PackageResponse> for super::PackageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    download_count: value.download_count?,
                    format: value.format?,
                    id: value.id?,
                    metadata: value.metadata?,
                    name: value.name?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                    updated_at: value.updated_at?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::PackageResponse> for PackageResponse {
            fn from(value: super::PackageResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    download_count: Ok(value.download_count),
                    format: Ok(value.format),
                    id: Ok(value.id),
                    metadata: Ok(value.metadata),
                    name: Ok(value.name),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                    updated_at: Ok(value.updated_at),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageRow {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            metadata: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PackageRow {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    format: Err("no value supplied for format".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    metadata: Err("no value supplied for metadata".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PackageRow {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PackageRow> for super::PackageRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    download_count: value.download_count?,
                    format: value.format?,
                    id: value.id?,
                    metadata: value.metadata?,
                    name: value.name?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                    updated_at: value.updated_at?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::PackageRow> for PackageRow {
            fn from(value: super::PackageRow) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    download_count: Ok(value.download_count),
                    format: Ok(value.format),
                    id: Ok(value.id),
                    metadata: Ok(value.metadata),
                    name: Ok(value.name),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                    updated_at: Ok(value.updated_at),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageVersionResponse {
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PackageVersionResponse {
            fn default() -> Self {
                Self {
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PackageVersionResponse {
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PackageVersionResponse> for super::PackageVersionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageVersionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_sha256: value.checksum_sha256?,
                    created_at: value.created_at?,
                    download_count: value.download_count?,
                    size_bytes: value.size_bytes?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::PackageVersionResponse> for PackageVersionResponse {
            fn from(value: super::PackageVersionResponse) -> Self {
                Self {
                    checksum_sha256: Ok(value.checksum_sha256),
                    created_at: Ok(value.created_at),
                    download_count: Ok(value.download_count),
                    size_bytes: Ok(value.size_bytes),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageVersionRow {
            checksum_sha256: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PackageVersionRow {
            fn default() -> Self {
                Self {
                    checksum_sha256: Err("no value supplied for checksum_sha256".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PackageVersionRow {
            pub fn checksum_sha256<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_sha256 = value.try_into().map_err(|e| {
                    format!("error converting supplied value for checksum_sha256: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PackageVersionRow> for super::PackageVersionRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageVersionRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checksum_sha256: value.checksum_sha256?,
                    created_at: value.created_at?,
                    download_count: value.download_count?,
                    size_bytes: value.size_bytes?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::PackageVersionRow> for PackageVersionRow {
            fn from(value: super::PackageVersionRow) -> Self {
                Self {
                    checksum_sha256: Ok(value.checksum_sha256),
                    created_at: Ok(value.created_at),
                    download_count: Ok(value.download_count),
                    size_bytes: Ok(value.size_bytes),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageVersionsResponse {
            versions: ::std::result::Result<
                ::std::vec::Vec<super::PackageVersionResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PackageVersionsResponse {
            fn default() -> Self {
                Self {
                    versions: Err("no value supplied for versions".to_string()),
                }
            }
        }
        impl PackageVersionsResponse {
            pub fn versions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PackageVersionResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.versions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for versions: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PackageVersionsResponse> for super::PackageVersionsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageVersionsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    versions: value.versions?,
                })
            }
        }
        impl ::std::convert::From<super::PackageVersionsResponse> for PackageVersionsResponse {
            fn from(value: super::PackageVersionsResponse) -> Self {
                Self {
                    versions: Ok(value.versions),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Pagination {
            page: ::std::result::Result<i32, ::std::string::String>,
            per_page: ::std::result::Result<i32, ::std::string::String>,
            total: ::std::result::Result<i64, ::std::string::String>,
            total_pages: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for Pagination {
            fn default() -> Self {
                Self {
                    page: Err("no value supplied for page".to_string()),
                    per_page: Err("no value supplied for per_page".to_string()),
                    total: Err("no value supplied for total".to_string()),
                    total_pages: Err("no value supplied for total_pages".to_string()),
                }
            }
        }
        impl Pagination {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
            pub fn total_pages<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_pages = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_pages: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<Pagination> for super::Pagination {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Pagination,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    per_page: value.per_page?,
                    total: value.total?,
                    total_pages: value.total_pages?,
                })
            }
        }
        impl ::std::convert::From<super::Pagination> for Pagination {
            fn from(value: super::Pagination) -> Self {
                Self {
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    total: Ok(value.total),
                    total_pages: Ok(value.total_pages),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PaginationInfo {
            page: ::std::result::Result<i32, ::std::string::String>,
            per_page: ::std::result::Result<i32, ::std::string::String>,
            total: ::std::result::Result<i64, ::std::string::String>,
            total_pages: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for PaginationInfo {
            fn default() -> Self {
                Self {
                    page: Err("no value supplied for page".to_string()),
                    per_page: Err("no value supplied for per_page".to_string()),
                    total: Err("no value supplied for total".to_string()),
                    total_pages: Err("no value supplied for total_pages".to_string()),
                }
            }
        }
        impl PaginationInfo {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
            pub fn total_pages<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_pages = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_pages: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PaginationInfo> for super::PaginationInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PaginationInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    per_page: value.per_page?,
                    total: value.total?,
                    total_pages: value.total_pages?,
                })
            }
        }
        impl ::std::convert::From<super::PaginationInfo> for PaginationInfo {
            fn from(value: super::PaginationInfo) -> Self {
                Self {
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    total: Ok(value.total),
                    total_pages: Ok(value.total_pages),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerInstanceListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PeerInstanceResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for PeerInstanceListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl PeerInstanceListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PeerInstanceResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PeerInstanceListResponse> for super::PeerInstanceListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerInstanceListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::PeerInstanceListResponse> for PeerInstanceListResponse {
            fn from(value: super::PeerInstanceListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerInstanceResponse {
            cache_size_bytes: ::std::result::Result<i64, ::std::string::String>,
            cache_usage_percent: ::std::result::Result<f64, ::std::string::String>,
            cache_used_bytes: ::std::result::Result<i64, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            endpoint_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_local: ::std::result::Result<bool, ::std::string::String>,
            last_heartbeat_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            last_sync_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            region: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PeerInstanceResponse {
            fn default() -> Self {
                Self {
                    cache_size_bytes: Err("no value supplied for cache_size_bytes".to_string()),
                    cache_usage_percent: Err(
                        "no value supplied for cache_usage_percent".to_string()
                    ),
                    cache_used_bytes: Err("no value supplied for cache_used_bytes".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    endpoint_url: Err("no value supplied for endpoint_url".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_local: Err("no value supplied for is_local".to_string()),
                    last_heartbeat_at: Ok(Default::default()),
                    last_sync_at: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    region: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl PeerInstanceResponse {
            pub fn cache_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.cache_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cache_size_bytes: {e}")
                });
                self
            }
            pub fn cache_usage_percent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.cache_usage_percent = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cache_usage_percent: {e}")
                });
                self
            }
            pub fn cache_used_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.cache_used_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cache_used_bytes: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn endpoint_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint_url: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_local<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_local = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_local: {e}"));
                self
            }
            pub fn last_heartbeat_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_heartbeat_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_heartbeat_at: {e}")
                });
                self
            }
            pub fn last_sync_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_sync_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_sync_at: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn region<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.region = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for region: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PeerInstanceResponse> for super::PeerInstanceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerInstanceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cache_size_bytes: value.cache_size_bytes?,
                    cache_usage_percent: value.cache_usage_percent?,
                    cache_used_bytes: value.cache_used_bytes?,
                    created_at: value.created_at?,
                    endpoint_url: value.endpoint_url?,
                    id: value.id?,
                    is_local: value.is_local?,
                    last_heartbeat_at: value.last_heartbeat_at?,
                    last_sync_at: value.last_sync_at?,
                    name: value.name?,
                    region: value.region?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::PeerInstanceResponse> for PeerInstanceResponse {
            fn from(value: super::PeerInstanceResponse) -> Self {
                Self {
                    cache_size_bytes: Ok(value.cache_size_bytes),
                    cache_usage_percent: Ok(value.cache_usage_percent),
                    cache_used_bytes: Ok(value.cache_used_bytes),
                    created_at: Ok(value.created_at),
                    endpoint_url: Ok(value.endpoint_url),
                    id: Ok(value.id),
                    is_local: Ok(value.is_local),
                    last_heartbeat_at: Ok(value.last_heartbeat_at),
                    last_sync_at: Ok(value.last_sync_at),
                    name: Ok(value.name),
                    region: Ok(value.region),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerLabelEntrySchema {
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            value: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PeerLabelEntrySchema {
            fn default() -> Self {
                Self {
                    key: Err("no value supplied for key".to_string()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl PeerLabelEntrySchema {
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PeerLabelEntrySchema> for super::PeerLabelEntrySchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerLabelEntrySchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key: value.key?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PeerLabelEntrySchema> for PeerLabelEntrySchema {
            fn from(value: super::PeerLabelEntrySchema) -> Self {
                Self {
                    key: Ok(value.key),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerLabelResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_instance_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PeerLabelResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    peer_instance_id: Err("no value supplied for peer_instance_id".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PeerLabelResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn peer_instance_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.peer_instance_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for peer_instance_id: {e}")
                });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PeerLabelResponse> for super::PeerLabelResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerLabelResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    key: value.key?,
                    peer_instance_id: value.peer_instance_id?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PeerLabelResponse> for PeerLabelResponse {
            fn from(value: super::PeerLabelResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    key: Ok(value.key),
                    peer_instance_id: Ok(value.peer_instance_id),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerLabelsListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PeerLabelResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for PeerLabelsListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl PeerLabelsListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PeerLabelResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PeerLabelsListResponse> for super::PeerLabelsListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerLabelsListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::PeerLabelsListResponse> for PeerLabelsListResponse {
            fn from(value: super::PeerLabelsListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerResponse {
            bandwidth_estimate_bps:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            bytes_transferred_total: ::std::result::Result<i64, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_probed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            last_transfer_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            latency_ms: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            shared_artifacts_count: ::std::result::Result<i32, ::std::string::String>,
            shared_chunks_count: ::std::result::Result<i32, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            transfer_failure_count: ::std::result::Result<i32, ::std::string::String>,
            transfer_success_count: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for PeerResponse {
            fn default() -> Self {
                Self {
                    bandwidth_estimate_bps: Ok(Default::default()),
                    bytes_transferred_total: Err(
                        "no value supplied for bytes_transferred_total".to_string()
                    ),
                    id: Err("no value supplied for id".to_string()),
                    last_probed_at: Ok(Default::default()),
                    last_transfer_at: Ok(Default::default()),
                    latency_ms: Ok(Default::default()),
                    shared_artifacts_count: Err(
                        "no value supplied for shared_artifacts_count".to_string()
                    ),
                    shared_chunks_count: Err(
                        "no value supplied for shared_chunks_count".to_string()
                    ),
                    status: Err("no value supplied for status".to_string()),
                    target_peer_id: Err("no value supplied for target_peer_id".to_string()),
                    transfer_failure_count: Err(
                        "no value supplied for transfer_failure_count".to_string()
                    ),
                    transfer_success_count: Err(
                        "no value supplied for transfer_success_count".to_string()
                    ),
                }
            }
        }
        impl PeerResponse {
            pub fn bandwidth_estimate_bps<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bandwidth_estimate_bps = value.try_into().map_err(|e| {
                    format!("error converting supplied value for bandwidth_estimate_bps: {e}")
                });
                self
            }
            pub fn bytes_transferred_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.bytes_transferred_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for bytes_transferred_total: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn last_probed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_probed_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_probed_at: {e}")
                });
                self
            }
            pub fn last_transfer_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_transfer_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_transfer_at: {e}")
                });
                self
            }
            pub fn latency_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.latency_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for latency_ms: {e}"));
                self
            }
            pub fn shared_artifacts_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.shared_artifacts_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for shared_artifacts_count: {e}")
                });
                self
            }
            pub fn shared_chunks_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.shared_chunks_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for shared_chunks_count: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn target_peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_peer_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_peer_id: {e}")
                });
                self
            }
            pub fn transfer_failure_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.transfer_failure_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transfer_failure_count: {e}")
                });
                self
            }
            pub fn transfer_success_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.transfer_success_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transfer_success_count: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PeerResponse> for super::PeerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bandwidth_estimate_bps: value.bandwidth_estimate_bps?,
                    bytes_transferred_total: value.bytes_transferred_total?,
                    id: value.id?,
                    last_probed_at: value.last_probed_at?,
                    last_transfer_at: value.last_transfer_at?,
                    latency_ms: value.latency_ms?,
                    shared_artifacts_count: value.shared_artifacts_count?,
                    shared_chunks_count: value.shared_chunks_count?,
                    status: value.status?,
                    target_peer_id: value.target_peer_id?,
                    transfer_failure_count: value.transfer_failure_count?,
                    transfer_success_count: value.transfer_success_count?,
                })
            }
        }
        impl ::std::convert::From<super::PeerResponse> for PeerResponse {
            fn from(value: super::PeerResponse) -> Self {
                Self {
                    bandwidth_estimate_bps: Ok(value.bandwidth_estimate_bps),
                    bytes_transferred_total: Ok(value.bytes_transferred_total),
                    id: Ok(value.id),
                    last_probed_at: Ok(value.last_probed_at),
                    last_transfer_at: Ok(value.last_transfer_at),
                    latency_ms: Ok(value.latency_ms),
                    shared_artifacts_count: Ok(value.shared_artifacts_count),
                    shared_chunks_count: Ok(value.shared_chunks_count),
                    status: Ok(value.status),
                    target_peer_id: Ok(value.target_peer_id),
                    transfer_failure_count: Ok(value.transfer_failure_count),
                    transfer_success_count: Ok(value.transfer_success_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PeerSelectorSchema {
            all: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            match_labels: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                ::std::string::String,
            >,
            match_peers:
                ::std::result::Result<::std::vec::Vec<::uuid::Uuid>, ::std::string::String>,
            match_region: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PeerSelectorSchema {
            fn default() -> Self {
                Self {
                    all: Ok(Default::default()),
                    match_labels: Ok(Default::default()),
                    match_peers: Ok(Default::default()),
                    match_region: Ok(Default::default()),
                }
            }
        }
        impl PeerSelectorSchema {
            pub fn all<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.all = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for all: {e}"));
                self
            }
            pub fn match_labels<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.match_labels = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_labels: {e}"));
                self
            }
            pub fn match_peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.match_peers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_peers: {e}"));
                self
            }
            pub fn match_region<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.match_region = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_region: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PeerSelectorSchema> for super::PeerSelectorSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PeerSelectorSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    all: value.all?,
                    match_labels: value.match_labels?,
                    match_peers: value.match_peers?,
                    match_region: value.match_region?,
                })
            }
        }
        impl ::std::convert::From<super::PeerSelectorSchema> for PeerSelectorSchema {
            fn from(value: super::PeerSelectorSchema) -> Self {
                Self {
                    all: Ok(value.all),
                    match_labels: Ok(value.match_labels),
                    match_peers: Ok(value.match_peers),
                    match_region: Ok(value.match_region),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PendingQuery {
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            source_repository: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PendingQuery {
            fn default() -> Self {
                Self {
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    source_repository: Ok(Default::default()),
                }
            }
        }
        impl PendingQuery {
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn source_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repository: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PendingQuery> for super::PendingQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PendingQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    page: value.page?,
                    per_page: value.per_page?,
                    source_repository: value.source_repository?,
                })
            }
        }
        impl ::std::convert::From<super::PendingQuery> for PendingQuery {
            fn from(value: super::PendingQuery) -> Self {
                Self {
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    source_repository: Ok(value.source_repository),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PermissionListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PermissionResponse>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for PermissionListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl PermissionListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PermissionResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PermissionListResponse> for super::PermissionListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PermissionListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::PermissionListResponse> for PermissionListResponse {
            fn from(value: super::PermissionListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PermissionResponse {
            actions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            principal_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            target_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PermissionResponse {
            fn default() -> Self {
                Self {
                    actions: Err("no value supplied for actions".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    principal_id: Err("no value supplied for principal_id".to_string()),
                    principal_name: Ok(Default::default()),
                    principal_type: Err("no value supplied for principal_type".to_string()),
                    target_id: Err("no value supplied for target_id".to_string()),
                    target_name: Ok(Default::default()),
                    target_type: Err("no value supplied for target_type".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl PermissionResponse {
            pub fn actions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.actions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for actions: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn principal_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for principal_id: {e}"));
                self
            }
            pub fn principal_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for principal_name: {e}")
                });
                self
            }
            pub fn principal_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for principal_type: {e}")
                });
                self
            }
            pub fn target_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_id: {e}"));
                self
            }
            pub fn target_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.target_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_name: {e}"));
                self
            }
            pub fn target_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_type: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PermissionResponse> for super::PermissionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PermissionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    actions: value.actions?,
                    created_at: value.created_at?,
                    id: value.id?,
                    principal_id: value.principal_id?,
                    principal_name: value.principal_name?,
                    principal_type: value.principal_type?,
                    target_id: value.target_id?,
                    target_name: value.target_name?,
                    target_type: value.target_type?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::PermissionResponse> for PermissionResponse {
            fn from(value: super::PermissionResponse) -> Self {
                Self {
                    actions: Ok(value.actions),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    principal_id: Ok(value.principal_id),
                    principal_name: Ok(value.principal_name),
                    principal_type: Ok(value.principal_type),
                    target_id: Ok(value.target_id),
                    target_name: Ok(value.target_name),
                    target_type: Ok(value.target_type),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PermissionRow {
            actions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            principal_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            principal_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            target_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PermissionRow {
            fn default() -> Self {
                Self {
                    actions: Err("no value supplied for actions".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    principal_id: Err("no value supplied for principal_id".to_string()),
                    principal_name: Ok(Default::default()),
                    principal_type: Err("no value supplied for principal_type".to_string()),
                    target_id: Err("no value supplied for target_id".to_string()),
                    target_name: Ok(Default::default()),
                    target_type: Err("no value supplied for target_type".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl PermissionRow {
            pub fn actions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.actions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for actions: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn principal_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for principal_id: {e}"));
                self
            }
            pub fn principal_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for principal_name: {e}")
                });
                self
            }
            pub fn principal_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.principal_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for principal_type: {e}")
                });
                self
            }
            pub fn target_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_id: {e}"));
                self
            }
            pub fn target_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.target_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_name: {e}"));
                self
            }
            pub fn target_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_type: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PermissionRow> for super::PermissionRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PermissionRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    actions: value.actions?,
                    created_at: value.created_at?,
                    id: value.id?,
                    principal_id: value.principal_id?,
                    principal_name: value.principal_name?,
                    principal_type: value.principal_type?,
                    target_id: value.target_id?,
                    target_name: value.target_name?,
                    target_type: value.target_type?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::PermissionRow> for PermissionRow {
            fn from(value: super::PermissionRow) -> Self {
                Self {
                    actions: Ok(value.actions),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    principal_id: Ok(value.principal_id),
                    principal_name: Ok(value.principal_name),
                    principal_type: Ok(value.principal_type),
                    target_id: Ok(value.target_id),
                    target_name: Ok(value.target_name),
                    target_type: Ok(value.target_type),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PluginConfigResponse {
            config: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            plugin_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            schema: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PluginConfigResponse {
            fn default() -> Self {
                Self {
                    config: Err("no value supplied for config".to_string()),
                    plugin_id: Err("no value supplied for plugin_id".to_string()),
                    schema: Err("no value supplied for schema".to_string()),
                }
            }
        }
        impl PluginConfigResponse {
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
            pub fn plugin_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.plugin_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for plugin_id: {e}"));
                self
            }
            pub fn schema<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.schema = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for schema: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PluginConfigResponse> for super::PluginConfigResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PluginConfigResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    config: value.config?,
                    plugin_id: value.plugin_id?,
                    schema: value.schema?,
                })
            }
        }
        impl ::std::convert::From<super::PluginConfigResponse> for PluginConfigResponse {
            fn from(value: super::PluginConfigResponse) -> Self {
                Self {
                    config: Ok(value.config),
                    plugin_id: Ok(value.plugin_id),
                    schema: Ok(value.schema),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PluginInstallResponse {
            format_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            plugin_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PluginInstallResponse {
            fn default() -> Self {
                Self {
                    format_key: Err("no value supplied for format_key".to_string()),
                    message: Err("no value supplied for message".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    plugin_id: Err("no value supplied for plugin_id".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PluginInstallResponse {
            pub fn format_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format_key: {e}"));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn plugin_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.plugin_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for plugin_id: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PluginInstallResponse> for super::PluginInstallResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PluginInstallResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    format_key: value.format_key?,
                    message: value.message?,
                    name: value.name?,
                    plugin_id: value.plugin_id?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::PluginInstallResponse> for PluginInstallResponse {
            fn from(value: super::PluginInstallResponse) -> Self {
                Self {
                    format_key: Ok(value.format_key),
                    message: Ok(value.message),
                    name: Ok(value.name),
                    plugin_id: Ok(value.plugin_id),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PluginListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PluginResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PluginListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl PluginListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PluginResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PluginListResponse> for super::PluginListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PluginListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::PluginListResponse> for PluginListResponse {
            fn from(value: super::PluginListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PluginResponse {
            author: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            config_schema: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            display_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            enabled_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            homepage: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            installed_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            plugin_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PluginResponse {
            fn default() -> Self {
                Self {
                    author: Ok(Default::default()),
                    config_schema: Err("no value supplied for config_schema".to_string()),
                    description: Ok(Default::default()),
                    display_name: Err("no value supplied for display_name".to_string()),
                    enabled_at: Ok(Default::default()),
                    homepage: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    installed_at: Err("no value supplied for installed_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    plugin_type: Err("no value supplied for plugin_type".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PluginResponse {
            pub fn author<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.author = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for author: {e}"));
                self
            }
            pub fn config_schema<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config_schema = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config_schema: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn enabled_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.enabled_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled_at: {e}"));
                self
            }
            pub fn homepage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.homepage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for homepage: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn installed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.installed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for installed_at: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn plugin_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.plugin_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for plugin_type: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PluginResponse> for super::PluginResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PluginResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    author: value.author?,
                    config_schema: value.config_schema?,
                    description: value.description?,
                    display_name: value.display_name?,
                    enabled_at: value.enabled_at?,
                    homepage: value.homepage?,
                    id: value.id?,
                    installed_at: value.installed_at?,
                    name: value.name?,
                    plugin_type: value.plugin_type?,
                    status: value.status?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::PluginResponse> for PluginResponse {
            fn from(value: super::PluginResponse) -> Self {
                Self {
                    author: Ok(value.author),
                    config_schema: Ok(value.config_schema),
                    description: Ok(value.description),
                    display_name: Ok(value.display_name),
                    enabled_at: Ok(value.enabled_at),
                    homepage: Ok(value.homepage),
                    id: Ok(value.id),
                    installed_at: Ok(value.installed_at),
                    name: Ok(value.name),
                    plugin_type: Ok(value.plugin_type),
                    status: Ok(value.status),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PolicyExecutionResult {
            artifacts_matched: ::std::result::Result<i64, ::std::string::String>,
            artifacts_removed: ::std::result::Result<i64, ::std::string::String>,
            bytes_freed: ::std::result::Result<i64, ::std::string::String>,
            dry_run: ::std::result::Result<bool, ::std::string::String>,
            errors: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            policy_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            policy_name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PolicyExecutionResult {
            fn default() -> Self {
                Self {
                    artifacts_matched: Err("no value supplied for artifacts_matched".to_string()),
                    artifacts_removed: Err("no value supplied for artifacts_removed".to_string()),
                    bytes_freed: Err("no value supplied for bytes_freed".to_string()),
                    dry_run: Err("no value supplied for dry_run".to_string()),
                    errors: Err("no value supplied for errors".to_string()),
                    policy_id: Err("no value supplied for policy_id".to_string()),
                    policy_name: Err("no value supplied for policy_name".to_string()),
                }
            }
        }
        impl PolicyExecutionResult {
            pub fn artifacts_matched<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_matched = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_matched: {e}")
                });
                self
            }
            pub fn artifacts_removed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_removed = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_removed: {e}")
                });
                self
            }
            pub fn bytes_freed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.bytes_freed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bytes_freed: {e}"));
                self
            }
            pub fn dry_run<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.dry_run = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dry_run: {e}"));
                self
            }
            pub fn errors<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.errors = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for errors: {e}"));
                self
            }
            pub fn policy_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_id: {e}"));
                self
            }
            pub fn policy_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_name: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PolicyExecutionResult> for super::PolicyExecutionResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PolicyExecutionResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_matched: value.artifacts_matched?,
                    artifacts_removed: value.artifacts_removed?,
                    bytes_freed: value.bytes_freed?,
                    dry_run: value.dry_run?,
                    errors: value.errors?,
                    policy_id: value.policy_id?,
                    policy_name: value.policy_name?,
                })
            }
        }
        impl ::std::convert::From<super::PolicyExecutionResult> for PolicyExecutionResult {
            fn from(value: super::PolicyExecutionResult) -> Self {
                Self {
                    artifacts_matched: Ok(value.artifacts_matched),
                    artifacts_removed: Ok(value.artifacts_removed),
                    bytes_freed: Ok(value.bytes_freed),
                    dry_run: Ok(value.dry_run),
                    errors: Ok(value.errors),
                    policy_id: Ok(value.policy_id),
                    policy_name: Ok(value.policy_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PolicyResponse {
            block_on_fail: ::std::result::Result<bool, ::std::string::String>,
            block_unscanned: ::std::result::Result<bool, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            max_artifact_age_days:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            min_staging_hours:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            require_signature: ::std::result::Result<bool, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PolicyResponse {
            fn default() -> Self {
                Self {
                    block_on_fail: Err("no value supplied for block_on_fail".to_string()),
                    block_unscanned: Err("no value supplied for block_unscanned".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    max_artifact_age_days: Ok(Default::default()),
                    max_severity: Err("no value supplied for max_severity".to_string()),
                    min_staging_hours: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    require_signature: Err("no value supplied for require_signature".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl PolicyResponse {
            pub fn block_on_fail<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_on_fail = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_on_fail: {e}"));
                self
            }
            pub fn block_unscanned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_unscanned = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_unscanned: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_artifact_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_artifact_age_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_artifact_age_days: {e}")
                });
                self
            }
            pub fn max_severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.max_severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max_severity: {e}"));
                self
            }
            pub fn min_staging_hours<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_staging_hours = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_staging_hours: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn require_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signature: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PolicyResponse> for super::PolicyResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PolicyResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_on_fail: value.block_on_fail?,
                    block_unscanned: value.block_unscanned?,
                    created_at: value.created_at?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    max_artifact_age_days: value.max_artifact_age_days?,
                    max_severity: value.max_severity?,
                    min_staging_hours: value.min_staging_hours?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    require_signature: value.require_signature?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::PolicyResponse> for PolicyResponse {
            fn from(value: super::PolicyResponse) -> Self {
                Self {
                    block_on_fail: Ok(value.block_on_fail),
                    block_unscanned: Ok(value.block_unscanned),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    max_artifact_age_days: Ok(value.max_artifact_age_days),
                    max_severity: Ok(value.max_severity),
                    min_staging_hours: Ok(value.min_staging_hours),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    require_signature: Ok(value.require_signature),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PolicyViolation {
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            rule: ::std::result::Result<::std::string::String, ::std::string::String>,
            severity: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PolicyViolation {
            fn default() -> Self {
                Self {
                    message: Err("no value supplied for message".to_string()),
                    rule: Err("no value supplied for rule".to_string()),
                    severity: Err("no value supplied for severity".to_string()),
                }
            }
        }
        impl PolicyViolation {
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn rule<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.rule = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule: {e}"));
                self
            }
            pub fn severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for severity: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PolicyViolation> for super::PolicyViolation {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PolicyViolation,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    message: value.message?,
                    rule: value.rule?,
                    severity: value.severity?,
                })
            }
        }
        impl ::std::convert::From<super::PolicyViolation> for PolicyViolation {
            fn from(value: super::PolicyViolation) -> Self {
                Self {
                    message: Ok(value.message),
                    rule: Ok(value.rule),
                    severity: Ok(value.severity),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PreviewPolicyPayload {
            artifact_filter: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            precedence: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            priority: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            replication_mode: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repo_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PreviewPolicyPayload {
            fn default() -> Self {
                Self {
                    artifact_filter: Ok(Default::default()),
                    description: Ok(Default::default()),
                    enabled: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    peer_selector: Ok(Default::default()),
                    precedence: Ok(Default::default()),
                    priority: Ok(Default::default()),
                    replication_mode: Ok(Default::default()),
                    repo_selector: Ok(Default::default()),
                }
            }
        }
        impl PreviewPolicyPayload {
            pub fn artifact_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_filter = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_filter: {e}")
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.peer_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_selector: {e}"));
                self
            }
            pub fn precedence<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.precedence = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for precedence: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn replication_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.replication_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for replication_mode: {e}")
                });
                self
            }
            pub fn repo_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.repo_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repo_selector: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PreviewPolicyPayload> for super::PreviewPolicyPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PreviewPolicyPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_filter: value.artifact_filter?,
                    description: value.description?,
                    enabled: value.enabled?,
                    name: value.name?,
                    peer_selector: value.peer_selector?,
                    precedence: value.precedence?,
                    priority: value.priority?,
                    replication_mode: value.replication_mode?,
                    repo_selector: value.repo_selector?,
                })
            }
        }
        impl ::std::convert::From<super::PreviewPolicyPayload> for PreviewPolicyPayload {
            fn from(value: super::PreviewPolicyPayload) -> Self {
                Self {
                    artifact_filter: Ok(value.artifact_filter),
                    description: Ok(value.description),
                    enabled: Ok(value.enabled),
                    name: Ok(value.name),
                    peer_selector: Ok(value.peer_selector),
                    precedence: Ok(value.precedence),
                    priority: Ok(value.priority),
                    replication_mode: Ok(value.replication_mode),
                    repo_selector: Ok(value.repo_selector),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PreviewResultResponse {
            matched_peers: ::std::result::Result<
                ::std::vec::Vec<super::MatchedPeerSchema>,
                ::std::string::String,
            >,
            matched_repositories: ::std::result::Result<
                ::std::vec::Vec<super::MatchedRepoSchema>,
                ::std::string::String,
            >,
            subscription_count: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for PreviewResultResponse {
            fn default() -> Self {
                Self {
                    matched_peers: Err("no value supplied for matched_peers".to_string()),
                    matched_repositories: Err(
                        "no value supplied for matched_repositories".to_string()
                    ),
                    subscription_count: Err("no value supplied for subscription_count".to_string()),
                }
            }
        }
        impl PreviewResultResponse {
            pub fn matched_peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::MatchedPeerSchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.matched_peers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for matched_peers: {e}"));
                self
            }
            pub fn matched_repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::MatchedRepoSchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.matched_repositories = value.try_into().map_err(|e| {
                    format!("error converting supplied value for matched_repositories: {e}")
                });
                self
            }
            pub fn subscription_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.subscription_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscription_count: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PreviewResultResponse> for super::PreviewResultResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PreviewResultResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    matched_peers: value.matched_peers?,
                    matched_repositories: value.matched_repositories?,
                    subscription_count: value.subscription_count?,
                })
            }
        }
        impl ::std::convert::From<super::PreviewResultResponse> for PreviewResultResponse {
            fn from(value: super::PreviewResultResponse) -> Self {
                Self {
                    matched_peers: Ok(value.matched_peers),
                    matched_repositories: Ok(value.matched_repositories),
                    subscription_count: Ok(value.subscription_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProbeBody {
            bandwidth_estimate_bps:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            latency_ms: ::std::result::Result<i32, ::std::string::String>,
            target_peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }
        impl ::std::default::Default for ProbeBody {
            fn default() -> Self {
                Self {
                    bandwidth_estimate_bps: Ok(Default::default()),
                    latency_ms: Err("no value supplied for latency_ms".to_string()),
                    target_peer_id: Err("no value supplied for target_peer_id".to_string()),
                }
            }
        }
        impl ProbeBody {
            pub fn bandwidth_estimate_bps<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bandwidth_estimate_bps = value.try_into().map_err(|e| {
                    format!("error converting supplied value for bandwidth_estimate_bps: {e}")
                });
                self
            }
            pub fn latency_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.latency_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for latency_ms: {e}"));
                self
            }
            pub fn target_peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_peer_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_peer_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ProbeBody> for super::ProbeBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProbeBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bandwidth_estimate_bps: value.bandwidth_estimate_bps?,
                    latency_ms: value.latency_ms?,
                    target_peer_id: value.target_peer_id?,
                })
            }
        }
        impl ::std::convert::From<super::ProbeBody> for ProbeBody {
            fn from(value: super::ProbeBody) -> Self {
                Self {
                    bandwidth_estimate_bps: Ok(value.bandwidth_estimate_bps),
                    latency_ms: Ok(value.latency_ms),
                    target_peer_id: Ok(value.target_peer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromoteArtifactRequest {
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            skip_policy_check:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            target_repository: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PromoteArtifactRequest {
            fn default() -> Self {
                Self {
                    notes: Ok(Default::default()),
                    skip_policy_check: Ok(Default::default()),
                    target_repository: Err("no value supplied for target_repository".to_string()),
                }
            }
        }
        impl PromoteArtifactRequest {
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
            pub fn skip_policy_check<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.skip_policy_check = value.try_into().map_err(|e| {
                    format!("error converting supplied value for skip_policy_check: {e}")
                });
                self
            }
            pub fn target_repository<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repository = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repository: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PromoteArtifactRequest> for super::PromoteArtifactRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromoteArtifactRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    notes: value.notes?,
                    skip_policy_check: value.skip_policy_check?,
                    target_repository: value.target_repository?,
                })
            }
        }
        impl ::std::convert::From<super::PromoteArtifactRequest> for PromoteArtifactRequest {
            fn from(value: super::PromoteArtifactRequest) -> Self {
                Self {
                    notes: Ok(value.notes),
                    skip_policy_check: Ok(value.skip_policy_check),
                    target_repository: Ok(value.target_repository),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromotionHistoryEntry {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            artifact_path: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            policy_result: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            promoted_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            promoted_by_username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            rejection_reason: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            source_repo_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            target_repo_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PromotionHistoryEntry {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    artifact_path: Err("no value supplied for artifact_path".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    notes: Ok(Default::default()),
                    policy_result: Ok(Default::default()),
                    promoted_by: Ok(Default::default()),
                    promoted_by_username: Ok(Default::default()),
                    rejection_reason: Ok(Default::default()),
                    source_repo_key: Err("no value supplied for source_repo_key".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    target_repo_key: Err("no value supplied for target_repo_key".to_string()),
                }
            }
        }
        impl PromotionHistoryEntry {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn artifact_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_path: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
            pub fn policy_result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.policy_result = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_result: {e}"));
                self
            }
            pub fn promoted_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.promoted_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for promoted_by: {e}"));
                self
            }
            pub fn promoted_by_username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.promoted_by_username = value.try_into().map_err(|e| {
                    format!("error converting supplied value for promoted_by_username: {e}")
                });
                self
            }
            pub fn rejection_reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.rejection_reason = value.try_into().map_err(|e| {
                    format!("error converting supplied value for rejection_reason: {e}")
                });
                self
            }
            pub fn source_repo_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repo_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repo_key: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn target_repo_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repo_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repo_key: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PromotionHistoryEntry> for super::PromotionHistoryEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromotionHistoryEntry,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    artifact_path: value.artifact_path?,
                    created_at: value.created_at?,
                    id: value.id?,
                    notes: value.notes?,
                    policy_result: value.policy_result?,
                    promoted_by: value.promoted_by?,
                    promoted_by_username: value.promoted_by_username?,
                    rejection_reason: value.rejection_reason?,
                    source_repo_key: value.source_repo_key?,
                    status: value.status?,
                    target_repo_key: value.target_repo_key?,
                })
            }
        }
        impl ::std::convert::From<super::PromotionHistoryEntry> for PromotionHistoryEntry {
            fn from(value: super::PromotionHistoryEntry) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    artifact_path: Ok(value.artifact_path),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    notes: Ok(value.notes),
                    policy_result: Ok(value.policy_result),
                    promoted_by: Ok(value.promoted_by),
                    promoted_by_username: Ok(value.promoted_by_username),
                    rejection_reason: Ok(value.rejection_reason),
                    source_repo_key: Ok(value.source_repo_key),
                    status: Ok(value.status),
                    target_repo_key: Ok(value.target_repo_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromotionHistoryQuery {
            artifact_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            per_page: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PromotionHistoryQuery {
            fn default() -> Self {
                Self {
                    artifact_id: Ok(Default::default()),
                    page: Ok(Default::default()),
                    per_page: Ok(Default::default()),
                    status: Ok(Default::default()),
                }
            }
        }
        impl PromotionHistoryQuery {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for page: {e}"));
                self
            }
            pub fn per_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.per_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for per_page: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PromotionHistoryQuery> for super::PromotionHistoryQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromotionHistoryQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    page: value.page?,
                    per_page: value.per_page?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::PromotionHistoryQuery> for PromotionHistoryQuery {
            fn from(value: super::PromotionHistoryQuery) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    page: Ok(value.page),
                    per_page: Ok(value.per_page),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromotionHistoryResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PromotionHistoryEntry>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for PromotionHistoryResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl PromotionHistoryResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PromotionHistoryEntry>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PromotionHistoryResponse> for super::PromotionHistoryResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromotionHistoryResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::PromotionHistoryResponse> for PromotionHistoryResponse {
            fn from(value: super::PromotionHistoryResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromotionResponse {
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            policy_violations: ::std::result::Result<
                ::std::vec::Vec<super::PolicyViolation>,
                ::std::string::String,
            >,
            promoted: ::std::result::Result<bool, ::std::string::String>,
            promotion_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            source: ::std::result::Result<::std::string::String, ::std::string::String>,
            target: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PromotionResponse {
            fn default() -> Self {
                Self {
                    message: Ok(Default::default()),
                    policy_violations: Err("no value supplied for policy_violations".to_string()),
                    promoted: Err("no value supplied for promoted".to_string()),
                    promotion_id: Ok(Default::default()),
                    source: Err("no value supplied for source".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }
        impl PromotionResponse {
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn policy_violations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PolicyViolation>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_violations = value.try_into().map_err(|e| {
                    format!("error converting supplied value for policy_violations: {e}")
                });
                self
            }
            pub fn promoted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.promoted = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for promoted: {e}"));
                self
            }
            pub fn promotion_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.promotion_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for promotion_id: {e}"));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {e}"));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PromotionResponse> for super::PromotionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromotionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    message: value.message?,
                    policy_violations: value.policy_violations?,
                    promoted: value.promoted?,
                    promotion_id: value.promotion_id?,
                    source: value.source?,
                    target: value.target?,
                })
            }
        }
        impl ::std::convert::From<super::PromotionResponse> for PromotionResponse {
            fn from(value: super::PromotionResponse) -> Self {
                Self {
                    message: Ok(value.message),
                    policy_violations: Ok(value.policy_violations),
                    promoted: Ok(value.promoted),
                    promotion_id: Ok(value.promotion_id),
                    source: Ok(value.source),
                    target: Ok(value.target),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromotionRuleListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::PromotionRuleResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for PromotionRuleListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl PromotionRuleListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PromotionRuleResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PromotionRuleListResponse> for super::PromotionRuleListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromotionRuleListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::PromotionRuleListResponse> for PromotionRuleListResponse {
            fn from(value: super::PromotionRuleListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PromotionRuleResponse {
            allowed_licenses: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
            auto_promote: ::std::result::Result<bool, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            max_artifact_age_days:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_cve_severity: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            min_health_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_staging_hours:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            require_signature: ::std::result::Result<bool, ::std::string::String>,
            source_repo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target_repo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PromotionRuleResponse {
            fn default() -> Self {
                Self {
                    allowed_licenses: Ok(Default::default()),
                    auto_promote: Err("no value supplied for auto_promote".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    max_artifact_age_days: Ok(Default::default()),
                    max_cve_severity: Ok(Default::default()),
                    min_health_score: Ok(Default::default()),
                    min_staging_hours: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    require_signature: Err("no value supplied for require_signature".to_string()),
                    source_repo_id: Err("no value supplied for source_repo_id".to_string()),
                    target_repo_id: Err("no value supplied for target_repo_id".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl PromotionRuleResponse {
            pub fn allowed_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_licenses: {e}")
                });
                self
            }
            pub fn auto_promote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_promote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auto_promote: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_artifact_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_artifact_age_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_artifact_age_days: {e}")
                });
                self
            }
            pub fn max_cve_severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_cve_severity = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_cve_severity: {e}")
                });
                self
            }
            pub fn min_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_health_score: {e}")
                });
                self
            }
            pub fn min_staging_hours<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_staging_hours = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_staging_hours: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn require_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signature: {e}")
                });
                self
            }
            pub fn source_repo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.source_repo_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for source_repo_id: {e}")
                });
                self
            }
            pub fn target_repo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repo_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repo_id: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<PromotionRuleResponse> for super::PromotionRuleResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PromotionRuleResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowed_licenses: value.allowed_licenses?,
                    auto_promote: value.auto_promote?,
                    created_at: value.created_at?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    max_artifact_age_days: value.max_artifact_age_days?,
                    max_cve_severity: value.max_cve_severity?,
                    min_health_score: value.min_health_score?,
                    min_staging_hours: value.min_staging_hours?,
                    name: value.name?,
                    require_signature: value.require_signature?,
                    source_repo_id: value.source_repo_id?,
                    target_repo_id: value.target_repo_id?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::PromotionRuleResponse> for PromotionRuleResponse {
            fn from(value: super::PromotionRuleResponse) -> Self {
                Self {
                    allowed_licenses: Ok(value.allowed_licenses),
                    auto_promote: Ok(value.auto_promote),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    max_artifact_age_days: Ok(value.max_artifact_age_days),
                    max_cve_severity: Ok(value.max_cve_severity),
                    min_health_score: Ok(value.min_health_score),
                    min_staging_hours: Ok(value.min_staging_hours),
                    name: Ok(value.name),
                    require_signature: Ok(value.require_signature),
                    source_repo_id: Ok(value.source_repo_id),
                    target_repo_id: Ok(value.target_repo_id),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct QuickSearchResponse {
            results: ::std::result::Result<
                ::std::vec::Vec<super::SearchResultItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for QuickSearchResponse {
            fn default() -> Self {
                Self {
                    results: Err("no value supplied for results".to_string()),
                }
            }
        }
        impl QuickSearchResponse {
            pub fn results<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SearchResultItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.results = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for results: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<QuickSearchResponse> for super::QuickSearchResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: QuickSearchResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    results: value.results?,
                })
            }
        }
        impl ::std::convert::From<super::QuickSearchResponse> for QuickSearchResponse {
            fn from(value: super::QuickSearchResponse) -> Self {
                Self {
                    results: Ok(value.results),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ReadyzChecks {
            database: ::std::result::Result<super::CheckStatus, ::std::string::String>,
            migrations: ::std::result::Result<super::CheckStatus, ::std::string::String>,
            setup_complete: ::std::result::Result<super::CheckStatus, ::std::string::String>,
        }
        impl ::std::default::Default for ReadyzChecks {
            fn default() -> Self {
                Self {
                    database: Err("no value supplied for database".to_string()),
                    migrations: Err("no value supplied for migrations".to_string()),
                    setup_complete: Err("no value supplied for setup_complete".to_string()),
                }
            }
        }
        impl ReadyzChecks {
            pub fn database<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CheckStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.database = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for database: {e}"));
                self
            }
            pub fn migrations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CheckStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.migrations = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for migrations: {e}"));
                self
            }
            pub fn setup_complete<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CheckStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.setup_complete = value.try_into().map_err(|e| {
                    format!("error converting supplied value for setup_complete: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ReadyzChecks> for super::ReadyzChecks {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ReadyzChecks,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    database: value.database?,
                    migrations: value.migrations?,
                    setup_complete: value.setup_complete?,
                })
            }
        }
        impl ::std::convert::From<super::ReadyzChecks> for ReadyzChecks {
            fn from(value: super::ReadyzChecks) -> Self {
                Self {
                    database: Ok(value.database),
                    migrations: Ok(value.migrations),
                    setup_complete: Ok(value.setup_complete),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ReadyzResponse {
            checks: ::std::result::Result<super::ReadyzChecks, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ReadyzResponse {
            fn default() -> Self {
                Self {
                    checks: Err("no value supplied for checks".to_string()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl ReadyzResponse {
            pub fn checks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ReadyzChecks>,
                T::Error: ::std::fmt::Display,
            {
                self.checks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checks: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ReadyzResponse> for super::ReadyzResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ReadyzResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checks: value.checks?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::ReadyzResponse> for ReadyzResponse {
            fn from(value: super::ReadyzResponse) -> Self {
                Self {
                    checks: Ok(value.checks),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RefreshTokenRequest {
            refresh_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RefreshTokenRequest {
            fn default() -> Self {
                Self {
                    refresh_token: Ok(Default::default()),
                }
            }
        }
        impl RefreshTokenRequest {
            pub fn refresh_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.refresh_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for refresh_token: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RefreshTokenRequest> for super::RefreshTokenRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RefreshTokenRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    refresh_token: value.refresh_token?,
                })
            }
        }
        impl ::std::convert::From<super::RefreshTokenRequest> for RefreshTokenRequest {
            fn from(value: super::RefreshTokenRequest) -> Self {
                Self {
                    refresh_token: Ok(value.refresh_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RegisterPeerRequest {
            api_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            cache_size_bytes:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            endpoint_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            region: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sync_filter: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RegisterPeerRequest {
            fn default() -> Self {
                Self {
                    api_key: Err("no value supplied for api_key".to_string()),
                    cache_size_bytes: Ok(Default::default()),
                    endpoint_url: Err("no value supplied for endpoint_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    region: Ok(Default::default()),
                    sync_filter: Err("no value supplied for sync_filter".to_string()),
                }
            }
        }
        impl RegisterPeerRequest {
            pub fn api_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.api_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for api_key: {e}"));
                self
            }
            pub fn cache_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.cache_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for cache_size_bytes: {e}")
                });
                self
            }
            pub fn endpoint_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn region<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.region = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for region: {e}"));
                self
            }
            pub fn sync_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.sync_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sync_filter: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RegisterPeerRequest> for super::RegisterPeerRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RegisterPeerRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    api_key: value.api_key?,
                    cache_size_bytes: value.cache_size_bytes?,
                    endpoint_url: value.endpoint_url?,
                    name: value.name?,
                    region: value.region?,
                    sync_filter: value.sync_filter?,
                })
            }
        }
        impl ::std::convert::From<super::RegisterPeerRequest> for RegisterPeerRequest {
            fn from(value: super::RegisterPeerRequest) -> Self {
                Self {
                    api_key: Ok(value.api_key),
                    cache_size_bytes: Ok(value.cache_size_bytes),
                    endpoint_url: Ok(value.endpoint_url),
                    name: Ok(value.name),
                    region: Ok(value.region),
                    sync_filter: Ok(value.sync_filter),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ReindexResponse {
            artifacts_indexed: ::std::result::Result<i64, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            repositories_indexed: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for ReindexResponse {
            fn default() -> Self {
                Self {
                    artifacts_indexed: Err("no value supplied for artifacts_indexed".to_string()),
                    message: Err("no value supplied for message".to_string()),
                    repositories_indexed: Err(
                        "no value supplied for repositories_indexed".to_string()
                    ),
                }
            }
        }
        impl ReindexResponse {
            pub fn artifacts_indexed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_indexed = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_indexed: {e}")
                });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn repositories_indexed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.repositories_indexed = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repositories_indexed: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ReindexResponse> for super::ReindexResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ReindexResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_indexed: value.artifacts_indexed?,
                    message: value.message?,
                    repositories_indexed: value.repositories_indexed?,
                })
            }
        }
        impl ::std::convert::From<super::ReindexResponse> for ReindexResponse {
            fn from(value: super::ReindexResponse) -> Self {
                Self {
                    artifacts_indexed: Ok(value.artifacts_indexed),
                    message: Ok(value.message),
                    repositories_indexed: Ok(value.repositories_indexed),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RejectArtifactRequest {
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            reason: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RejectArtifactRequest {
            fn default() -> Self {
                Self {
                    notes: Ok(Default::default()),
                    reason: Err("no value supplied for reason".to_string()),
                }
            }
        }
        impl RejectArtifactRequest {
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
            pub fn reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.reason = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reason: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RejectArtifactRequest> for super::RejectArtifactRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RejectArtifactRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    notes: value.notes?,
                    reason: value.reason?,
                })
            }
        }
        impl ::std::convert::From<super::RejectArtifactRequest> for RejectArtifactRequest {
            fn from(value: super::RejectArtifactRequest) -> Self {
                Self {
                    notes: Ok(value.notes),
                    reason: Ok(value.reason),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RejectionResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            reason: ::std::result::Result<::std::string::String, ::std::string::String>,
            rejected: ::std::result::Result<bool, ::std::string::String>,
            rejection_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            source: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RejectionResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    reason: Err("no value supplied for reason".to_string()),
                    rejected: Err("no value supplied for rejected".to_string()),
                    rejection_id: Err("no value supplied for rejection_id".to_string()),
                    source: Err("no value supplied for source".to_string()),
                }
            }
        }
        impl RejectionResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.reason = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reason: {e}"));
                self
            }
            pub fn rejected<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.rejected = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rejected: {e}"));
                self
            }
            pub fn rejection_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rejection_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rejection_id: {e}"));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RejectionResponse> for super::RejectionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RejectionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    reason: value.reason?,
                    rejected: value.rejected?,
                    rejection_id: value.rejection_id?,
                    source: value.source?,
                })
            }
        }
        impl ::std::convert::From<super::RejectionResponse> for RejectionResponse {
            fn from(value: super::RejectionResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    reason: Ok(value.reason),
                    rejected: Ok(value.rejected),
                    rejection_id: Ok(value.rejection_id),
                    source: Ok(value.source),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RemoteInstanceResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RemoteInstanceResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl RemoteInstanceResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RemoteInstanceResponse> for super::RemoteInstanceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RemoteInstanceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    name: value.name?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::RemoteInstanceResponse> for RemoteInstanceResponse {
            fn from(value: super::RemoteInstanceResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepoHealthResponse {
            artifacts_evaluated: ::std::result::Result<i32, ::std::string::String>,
            artifacts_failing: ::std::result::Result<i32, ::std::string::String>,
            artifacts_passing: ::std::result::Result<i32, ::std::string::String>,
            avg_license_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            avg_metadata_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            avg_quality_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            avg_security_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            health_grade: ::std::result::Result<::std::string::String, ::std::string::String>,
            health_score: ::std::result::Result<i32, ::std::string::String>,
            last_evaluated_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RepoHealthResponse {
            fn default() -> Self {
                Self {
                    artifacts_evaluated: Err(
                        "no value supplied for artifacts_evaluated".to_string()
                    ),
                    artifacts_failing: Err("no value supplied for artifacts_failing".to_string()),
                    artifacts_passing: Err("no value supplied for artifacts_passing".to_string()),
                    avg_license_score: Ok(Default::default()),
                    avg_metadata_score: Ok(Default::default()),
                    avg_quality_score: Ok(Default::default()),
                    avg_security_score: Ok(Default::default()),
                    health_grade: Err("no value supplied for health_grade".to_string()),
                    health_score: Err("no value supplied for health_score".to_string()),
                    last_evaluated_at: Ok(Default::default()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                }
            }
        }
        impl RepoHealthResponse {
            pub fn artifacts_evaluated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_evaluated = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_evaluated: {e}")
                });
                self
            }
            pub fn artifacts_failing<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_failing = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_failing: {e}")
                });
                self
            }
            pub fn artifacts_passing<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_passing = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_passing: {e}")
                });
                self
            }
            pub fn avg_license_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.avg_license_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for avg_license_score: {e}")
                });
                self
            }
            pub fn avg_metadata_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.avg_metadata_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for avg_metadata_score: {e}")
                });
                self
            }
            pub fn avg_quality_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.avg_quality_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for avg_quality_score: {e}")
                });
                self
            }
            pub fn avg_security_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.avg_security_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for avg_security_score: {e}")
                });
                self
            }
            pub fn health_grade<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.health_grade = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for health_grade: {e}"));
                self
            }
            pub fn health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.health_score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for health_score: {e}"));
                self
            }
            pub fn last_evaluated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_evaluated_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_evaluated_at: {e}")
                });
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<RepoHealthResponse> for super::RepoHealthResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepoHealthResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_evaluated: value.artifacts_evaluated?,
                    artifacts_failing: value.artifacts_failing?,
                    artifacts_passing: value.artifacts_passing?,
                    avg_license_score: value.avg_license_score?,
                    avg_metadata_score: value.avg_metadata_score?,
                    avg_quality_score: value.avg_quality_score?,
                    avg_security_score: value.avg_security_score?,
                    health_grade: value.health_grade?,
                    health_score: value.health_score?,
                    last_evaluated_at: value.last_evaluated_at?,
                    repository_id: value.repository_id?,
                    repository_key: value.repository_key?,
                })
            }
        }
        impl ::std::convert::From<super::RepoHealthResponse> for RepoHealthResponse {
            fn from(value: super::RepoHealthResponse) -> Self {
                Self {
                    artifacts_evaluated: Ok(value.artifacts_evaluated),
                    artifacts_failing: Ok(value.artifacts_failing),
                    artifacts_passing: Ok(value.artifacts_passing),
                    avg_license_score: Ok(value.avg_license_score),
                    avg_metadata_score: Ok(value.avg_metadata_score),
                    avg_quality_score: Ok(value.avg_quality_score),
                    avg_security_score: Ok(value.avg_security_score),
                    health_grade: Ok(value.health_grade),
                    health_score: Ok(value.health_score),
                    last_evaluated_at: Ok(value.last_evaluated_at),
                    repository_id: Ok(value.repository_id),
                    repository_key: Ok(value.repository_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepoSecurityResponse {
            config: ::std::result::Result<
                ::std::option::Option<super::ScanConfigResponse>,
                ::std::string::String,
            >,
            score: ::std::result::Result<
                ::std::option::Option<super::ScoreResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RepoSecurityResponse {
            fn default() -> Self {
                Self {
                    config: Ok(Default::default()),
                    score: Ok(Default::default()),
                }
            }
        }
        impl RepoSecurityResponse {
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::ScanConfigResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
            pub fn score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::ScoreResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for score: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepoSecurityResponse> for super::RepoSecurityResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepoSecurityResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    config: value.config?,
                    score: value.score?,
                })
            }
        }
        impl ::std::convert::From<super::RepoSecurityResponse> for RepoSecurityResponse {
            fn from(value: super::RepoSecurityResponse) -> Self {
                Self {
                    config: Ok(value.config),
                    score: Ok(value.score),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepoSelectorSchema {
            match_formats: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            match_labels: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                ::std::string::String,
            >,
            match_pattern: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            match_repos:
                ::std::result::Result<::std::vec::Vec<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for RepoSelectorSchema {
            fn default() -> Self {
                Self {
                    match_formats: Ok(Default::default()),
                    match_labels: Ok(Default::default()),
                    match_pattern: Ok(Default::default()),
                    match_repos: Ok(Default::default()),
                }
            }
        }
        impl RepoSelectorSchema {
            pub fn match_formats<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.match_formats = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_formats: {e}"));
                self
            }
            pub fn match_labels<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.match_labels = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_labels: {e}"));
                self
            }
            pub fn match_pattern<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.match_pattern = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_pattern: {e}"));
                self
            }
            pub fn match_repos<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.match_repos = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_repos: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepoSelectorSchema> for super::RepoSelectorSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepoSelectorSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    match_formats: value.match_formats?,
                    match_labels: value.match_labels?,
                    match_pattern: value.match_pattern?,
                    match_repos: value.match_repos?,
                })
            }
        }
        impl ::std::convert::From<super::RepoSelectorSchema> for RepoSelectorSchema {
            fn from(value: super::RepoSelectorSchema) -> Self {
                Self {
                    match_formats: Ok(value.match_formats),
                    match_labels: Ok(value.match_labels),
                    match_pattern: Ok(value.match_pattern),
                    match_repos: Ok(value.match_repos),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepositoryAssessment {
            artifact_count: ::std::result::Result<i64, ::std::string::String>,
            compatibility: ::std::result::Result<::std::string::String, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            package_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            total_size_bytes: ::std::result::Result<i64, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
            warnings: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RepositoryAssessment {
            fn default() -> Self {
                Self {
                    artifact_count: Err("no value supplied for artifact_count".to_string()),
                    compatibility: Err("no value supplied for compatibility".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    package_type: Err("no value supplied for package_type".to_string()),
                    total_size_bytes: Err("no value supplied for total_size_bytes".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    warnings: Err("no value supplied for warnings".to_string()),
                }
            }
        }
        impl RepositoryAssessment {
            pub fn artifact_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_count: {e}")
                });
                self
            }
            pub fn compatibility<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.compatibility = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for compatibility: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn package_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.package_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for package_type: {e}"));
                self
            }
            pub fn total_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_size_bytes: {e}")
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
            pub fn warnings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.warnings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for warnings: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepositoryAssessment> for super::RepositoryAssessment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepositoryAssessment,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_count: value.artifact_count?,
                    compatibility: value.compatibility?,
                    key: value.key?,
                    package_type: value.package_type?,
                    total_size_bytes: value.total_size_bytes?,
                    type_: value.type_?,
                    warnings: value.warnings?,
                })
            }
        }
        impl ::std::convert::From<super::RepositoryAssessment> for RepositoryAssessment {
            fn from(value: super::RepositoryAssessment) -> Self {
                Self {
                    artifact_count: Ok(value.artifact_count),
                    compatibility: Ok(value.compatibility),
                    key: Ok(value.key),
                    package_type: Ok(value.package_type),
                    total_size_bytes: Ok(value.total_size_bytes),
                    type_: Ok(value.type_),
                    warnings: Ok(value.warnings),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepositoryListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::RepositoryResponse>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for RepositoryListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl RepositoryListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::RepositoryResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepositoryListResponse> for super::RepositoryListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepositoryListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::RepositoryListResponse> for RepositoryListResponse {
            fn from(value: super::RepositoryListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepositoryResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_public: ::std::result::Result<bool, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            quota_bytes: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            repo_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            storage_used_bytes: ::std::result::Result<i64, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RepositoryResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    format: Err("no value supplied for format".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_public: Err("no value supplied for is_public".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    quota_bytes: Ok(Default::default()),
                    repo_type: Err("no value supplied for repo_type".to_string()),
                    storage_used_bytes: Err("no value supplied for storage_used_bytes".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl RepositoryResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_public<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_public = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_public: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn quota_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.quota_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for quota_bytes: {e}"));
                self
            }
            pub fn repo_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repo_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repo_type: {e}"));
                self
            }
            pub fn storage_used_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_used_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for storage_used_bytes: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepositoryResponse> for super::RepositoryResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepositoryResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    format: value.format?,
                    id: value.id?,
                    is_public: value.is_public?,
                    key: value.key?,
                    name: value.name?,
                    quota_bytes: value.quota_bytes?,
                    repo_type: value.repo_type?,
                    storage_used_bytes: value.storage_used_bytes?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::RepositoryResponse> for RepositoryResponse {
            fn from(value: super::RepositoryResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    format: Ok(value.format),
                    id: Ok(value.id),
                    is_public: Ok(value.is_public),
                    key: Ok(value.key),
                    name: Ok(value.name),
                    quota_bytes: Ok(value.quota_bytes),
                    repo_type: Ok(value.repo_type),
                    storage_used_bytes: Ok(value.storage_used_bytes),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepositorySigningConfig {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            require_signatures: ::std::result::Result<bool, ::std::string::String>,
            sign_metadata: ::std::result::Result<bool, ::std::string::String>,
            sign_packages: ::std::result::Result<bool, ::std::string::String>,
            signing_key_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RepositorySigningConfig {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    require_signatures: Err("no value supplied for require_signatures".to_string()),
                    sign_metadata: Err("no value supplied for sign_metadata".to_string()),
                    sign_packages: Err("no value supplied for sign_packages".to_string()),
                    signing_key_id: Ok(Default::default()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl RepositorySigningConfig {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn require_signatures<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signatures = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signatures: {e}")
                });
                self
            }
            pub fn sign_metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_metadata: {e}"));
                self
            }
            pub fn sign_packages<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_packages = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_packages: {e}"));
                self
            }
            pub fn signing_key_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.signing_key_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signing_key_id: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepositorySigningConfig> for super::RepositorySigningConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepositorySigningConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    repository_id: value.repository_id?,
                    require_signatures: value.require_signatures?,
                    sign_metadata: value.sign_metadata?,
                    sign_packages: value.sign_packages?,
                    signing_key_id: value.signing_key_id?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::RepositorySigningConfig> for RepositorySigningConfig {
            fn from(value: super::RepositorySigningConfig) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    repository_id: Ok(value.repository_id),
                    require_signatures: Ok(value.require_signatures),
                    sign_metadata: Ok(value.sign_metadata),
                    sign_packages: Ok(value.sign_packages),
                    signing_key_id: Ok(value.signing_key_id),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepositorySnapshot {
            artifact_count: ::std::result::Result<i64, ::std::string::String>,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            repository_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repository_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            snapshot_date: ::std::result::Result<::chrono::naive::NaiveDate, ::std::string::String>,
            storage_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for RepositorySnapshot {
            fn default() -> Self {
                Self {
                    artifact_count: Err("no value supplied for artifact_count".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    repository_key: Ok(Default::default()),
                    repository_name: Ok(Default::default()),
                    snapshot_date: Err("no value supplied for snapshot_date".to_string()),
                    storage_bytes: Err("no value supplied for storage_bytes".to_string()),
                }
            }
        }
        impl RepositorySnapshot {
            pub fn artifact_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_count: {e}")
                });
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn repository_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_name: {e}")
                });
                self
            }
            pub fn snapshot_date<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::naive::NaiveDate>,
                T::Error: ::std::fmt::Display,
            {
                self.snapshot_date = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for snapshot_date: {e}"));
                self
            }
            pub fn storage_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepositorySnapshot> for super::RepositorySnapshot {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepositorySnapshot,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_count: value.artifact_count?,
                    download_count: value.download_count?,
                    repository_id: value.repository_id?,
                    repository_key: value.repository_key?,
                    repository_name: value.repository_name?,
                    snapshot_date: value.snapshot_date?,
                    storage_bytes: value.storage_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::RepositorySnapshot> for RepositorySnapshot {
            fn from(value: super::RepositorySnapshot) -> Self {
                Self {
                    artifact_count: Ok(value.artifact_count),
                    download_count: Ok(value.download_count),
                    repository_id: Ok(value.repository_id),
                    repository_key: Ok(value.repository_key),
                    repository_name: Ok(value.repository_name),
                    snapshot_date: Ok(value.snapshot_date),
                    storage_bytes: Ok(value.storage_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RepositoryStorageBreakdown {
            artifact_count: ::std::result::Result<i64, ::std::string::String>,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            last_upload_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            storage_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for RepositoryStorageBreakdown {
            fn default() -> Self {
                Self {
                    artifact_count: Err("no value supplied for artifact_count".to_string()),
                    download_count: Err("no value supplied for download_count".to_string()),
                    format: Err("no value supplied for format".to_string()),
                    last_upload_at: Ok(Default::default()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    repository_name: Err("no value supplied for repository_name".to_string()),
                    storage_bytes: Err("no value supplied for storage_bytes".to_string()),
                }
            }
        }
        impl RepositoryStorageBreakdown {
            pub fn artifact_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_count: {e}")
                });
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn last_upload_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_upload_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_upload_at: {e}")
                });
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn repository_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_name: {e}")
                });
                self
            }
            pub fn storage_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RepositoryStorageBreakdown> for super::RepositoryStorageBreakdown {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RepositoryStorageBreakdown,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_count: value.artifact_count?,
                    download_count: value.download_count?,
                    format: value.format?,
                    last_upload_at: value.last_upload_at?,
                    repository_id: value.repository_id?,
                    repository_key: value.repository_key?,
                    repository_name: value.repository_name?,
                    storage_bytes: value.storage_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::RepositoryStorageBreakdown> for RepositoryStorageBreakdown {
            fn from(value: super::RepositoryStorageBreakdown) -> Self {
                Self {
                    artifact_count: Ok(value.artifact_count),
                    download_count: Ok(value.download_count),
                    format: Ok(value.format),
                    last_upload_at: Ok(value.last_upload_at),
                    repository_id: Ok(value.repository_id),
                    repository_key: Ok(value.repository_key),
                    repository_name: Ok(value.repository_name),
                    storage_bytes: Ok(value.storage_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResetPasswordResponse {
            temporary_password: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ResetPasswordResponse {
            fn default() -> Self {
                Self {
                    temporary_password: Err("no value supplied for temporary_password".to_string()),
                }
            }
        }
        impl ResetPasswordResponse {
            pub fn temporary_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.temporary_password = value.try_into().map_err(|e| {
                    format!("error converting supplied value for temporary_password: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ResetPasswordResponse> for super::ResetPasswordResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResetPasswordResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    temporary_password: value.temporary_password?,
                })
            }
        }
        impl ::std::convert::From<super::ResetPasswordResponse> for ResetPasswordResponse {
            fn from(value: super::ResetPasswordResponse) -> Self {
                Self {
                    temporary_password: Ok(value.temporary_password),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RestoreRequest {
            restore_artifacts:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            restore_database:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            target_repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for RestoreRequest {
            fn default() -> Self {
                Self {
                    restore_artifacts: Ok(Default::default()),
                    restore_database: Ok(Default::default()),
                    target_repository_id: Ok(Default::default()),
                }
            }
        }
        impl RestoreRequest {
            pub fn restore_artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.restore_artifacts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for restore_artifacts: {e}")
                });
                self
            }
            pub fn restore_database<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.restore_database = value.try_into().map_err(|e| {
                    format!("error converting supplied value for restore_database: {e}")
                });
                self
            }
            pub fn target_repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.target_repository_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for target_repository_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<RestoreRequest> for super::RestoreRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RestoreRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    restore_artifacts: value.restore_artifacts?,
                    restore_database: value.restore_database?,
                    target_repository_id: value.target_repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::RestoreRequest> for RestoreRequest {
            fn from(value: super::RestoreRequest) -> Self {
                Self {
                    restore_artifacts: Ok(value.restore_artifacts),
                    restore_database: Ok(value.restore_database),
                    target_repository_id: Ok(value.target_repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RestoreResponse {
            artifacts_restored: ::std::result::Result<i32, ::std::string::String>,
            errors: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            tables_restored: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RestoreResponse {
            fn default() -> Self {
                Self {
                    artifacts_restored: Err("no value supplied for artifacts_restored".to_string()),
                    errors: Err("no value supplied for errors".to_string()),
                    tables_restored: Err("no value supplied for tables_restored".to_string()),
                }
            }
        }
        impl RestoreResponse {
            pub fn artifacts_restored<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_restored = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_restored: {e}")
                });
                self
            }
            pub fn errors<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.errors = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for errors: {e}"));
                self
            }
            pub fn tables_restored<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.tables_restored = value.try_into().map_err(|e| {
                    format!("error converting supplied value for tables_restored: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<RestoreResponse> for super::RestoreResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RestoreResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_restored: value.artifacts_restored?,
                    errors: value.errors?,
                    tables_restored: value.tables_restored?,
                })
            }
        }
        impl ::std::convert::From<super::RestoreResponse> for RestoreResponse {
            fn from(value: super::RestoreResponse) -> Self {
                Self {
                    artifacts_restored: Ok(value.artifacts_restored),
                    errors: Ok(value.errors),
                    tables_restored: Ok(value.tables_restored),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ReviewRequest {
            notes: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ReviewRequest {
            fn default() -> Self {
                Self {
                    notes: Ok(Default::default()),
                }
            }
        }
        impl ReviewRequest {
            pub fn notes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.notes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for notes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ReviewRequest> for super::ReviewRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ReviewRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    notes: value.notes?,
                })
            }
        }
        impl ::std::convert::From<super::ReviewRequest> for ReviewRequest {
            fn from(value: super::ReviewRequest) -> Self {
                Self {
                    notes: Ok(value.notes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RoleListResponse {
            items:
                ::std::result::Result<::std::vec::Vec<super::RoleResponse>, ::std::string::String>,
        }
        impl ::std::default::Default for RoleListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl RoleListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::RoleResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RoleListResponse> for super::RoleListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RoleListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::RoleListResponse> for RoleListResponse {
            fn from(value: super::RoleListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RoleResponse {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            permissions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RoleResponse {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    permissions: Err("no value supplied for permissions".to_string()),
                }
            }
        }
        impl RoleResponse {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn permissions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.permissions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for permissions: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RoleResponse> for super::RoleResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RoleResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    permissions: value.permissions?,
                })
            }
        }
        impl ::std::convert::From<super::RoleResponse> for RoleResponse {
            fn from(value: super::RoleResponse) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    permissions: Ok(value.permissions),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RuleEvaluationResponse {
            passed: ::std::result::Result<bool, ::std::string::String>,
            rule_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            rule_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            violations: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RuleEvaluationResponse {
            fn default() -> Self {
                Self {
                    passed: Err("no value supplied for passed".to_string()),
                    rule_id: Err("no value supplied for rule_id".to_string()),
                    rule_name: Err("no value supplied for rule_name".to_string()),
                    violations: Err("no value supplied for violations".to_string()),
                }
            }
        }
        impl RuleEvaluationResponse {
            pub fn passed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.passed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for passed: {e}"));
                self
            }
            pub fn rule_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rule_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule_id: {e}"));
                self
            }
            pub fn rule_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.rule_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule_name: {e}"));
                self
            }
            pub fn violations<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.violations = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for violations: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<RuleEvaluationResponse> for super::RuleEvaluationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RuleEvaluationResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    passed: value.passed?,
                    rule_id: value.rule_id?,
                    rule_name: value.rule_name?,
                    violations: value.violations?,
                })
            }
        }
        impl ::std::convert::From<super::RuleEvaluationResponse> for RuleEvaluationResponse {
            fn from(value: super::RuleEvaluationResponse) -> Self {
                Self {
                    passed: Ok(value.passed),
                    rule_id: Ok(value.rule_id),
                    rule_name: Ok(value.rule_name),
                    violations: Ok(value.violations),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SamlAcsForm {
            relay_state: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            saml_response: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SamlAcsForm {
            fn default() -> Self {
                Self {
                    relay_state: Ok(Default::default()),
                    saml_response: Err("no value supplied for saml_response".to_string()),
                }
            }
        }
        impl SamlAcsForm {
            pub fn relay_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.relay_state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for relay_state: {e}"));
                self
            }
            pub fn saml_response<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.saml_response = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for saml_response: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SamlAcsForm> for super::SamlAcsForm {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SamlAcsForm,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    relay_state: value.relay_state?,
                    saml_response: value.saml_response?,
                })
            }
        }
        impl ::std::convert::From<super::SamlAcsForm> for SamlAcsForm {
            fn from(value: super::SamlAcsForm) -> Self {
                Self {
                    relay_state: Ok(value.relay_state),
                    saml_response: Ok(value.saml_response),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SamlConfigResponse {
            admin_group: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            attribute_mapping: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            entity_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            has_certificate: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            name_id_format: ::std::result::Result<::std::string::String, ::std::string::String>,
            require_signed_assertions: ::std::result::Result<bool, ::std::string::String>,
            sign_requests: ::std::result::Result<bool, ::std::string::String>,
            slo_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sp_entity_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            sso_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SamlConfigResponse {
            fn default() -> Self {
                Self {
                    admin_group: Ok(Default::default()),
                    attribute_mapping: Err("no value supplied for attribute_mapping".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    entity_id: Err("no value supplied for entity_id".to_string()),
                    has_certificate: Err("no value supplied for has_certificate".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    name_id_format: Err("no value supplied for name_id_format".to_string()),
                    require_signed_assertions: Err(
                        "no value supplied for require_signed_assertions".to_string(),
                    ),
                    sign_requests: Err("no value supplied for sign_requests".to_string()),
                    slo_url: Ok(Default::default()),
                    sp_entity_id: Err("no value supplied for sp_entity_id".to_string()),
                    sso_url: Err("no value supplied for sso_url".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl SamlConfigResponse {
            pub fn admin_group<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for admin_group: {e}"));
                self
            }
            pub fn attribute_mapping<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.attribute_mapping = value.try_into().map_err(|e| {
                    format!("error converting supplied value for attribute_mapping: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.entity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for entity_id: {e}"));
                self
            }
            pub fn has_certificate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.has_certificate = value.try_into().map_err(|e| {
                    format!("error converting supplied value for has_certificate: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn name_id_format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name_id_format = value.try_into().map_err(|e| {
                    format!("error converting supplied value for name_id_format: {e}")
                });
                self
            }
            pub fn require_signed_assertions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signed_assertions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signed_assertions: {e}")
                });
                self
            }
            pub fn sign_requests<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_requests = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_requests: {e}"));
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {e}"));
                self
            }
            pub fn sp_entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sp_entity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sp_entity_id: {e}"));
                self
            }
            pub fn sso_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sso_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sso_url: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SamlConfigResponse> for super::SamlConfigResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SamlConfigResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group: value.admin_group?,
                    attribute_mapping: value.attribute_mapping?,
                    created_at: value.created_at?,
                    entity_id: value.entity_id?,
                    has_certificate: value.has_certificate?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    name_id_format: value.name_id_format?,
                    require_signed_assertions: value.require_signed_assertions?,
                    sign_requests: value.sign_requests?,
                    slo_url: value.slo_url?,
                    sp_entity_id: value.sp_entity_id?,
                    sso_url: value.sso_url?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::SamlConfigResponse> for SamlConfigResponse {
            fn from(value: super::SamlConfigResponse) -> Self {
                Self {
                    admin_group: Ok(value.admin_group),
                    attribute_mapping: Ok(value.attribute_mapping),
                    created_at: Ok(value.created_at),
                    entity_id: Ok(value.entity_id),
                    has_certificate: Ok(value.has_certificate),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    name_id_format: Ok(value.name_id_format),
                    require_signed_assertions: Ok(value.require_signed_assertions),
                    sign_requests: Ok(value.sign_requests),
                    slo_url: Ok(value.slo_url),
                    sp_entity_id: Ok(value.sp_entity_id),
                    sso_url: Ok(value.sso_url),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SbomContentResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            component_count: ::std::result::Result<i32, ::std::string::String>,
            content: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            content_hash: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            dependency_count: ::std::result::Result<i32, ::std::string::String>,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            format_version: ::std::result::Result<::std::string::String, ::std::string::String>,
            generated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            generator: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            generator_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            license_count: ::std::result::Result<i32, ::std::string::String>,
            licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            spec_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SbomContentResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    component_count: Err("no value supplied for component_count".to_string()),
                    content: Err("no value supplied for content".to_string()),
                    content_hash: Err("no value supplied for content_hash".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    dependency_count: Err("no value supplied for dependency_count".to_string()),
                    format: Err("no value supplied for format".to_string()),
                    format_version: Err("no value supplied for format_version".to_string()),
                    generated_at: Err("no value supplied for generated_at".to_string()),
                    generator: Ok(Default::default()),
                    generator_version: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    license_count: Err("no value supplied for license_count".to_string()),
                    licenses: Err("no value supplied for licenses".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    spec_version: Ok(Default::default()),
                }
            }
        }
        impl SbomContentResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn component_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.component_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_count: {e}")
                });
                self
            }
            pub fn content<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.content = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content: {e}"));
                self
            }
            pub fn content_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.content_hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content_hash: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn dependency_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.dependency_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for dependency_count: {e}")
                });
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn format_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for format_version: {e}")
                });
                self
            }
            pub fn generated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.generated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generated_at: {e}"));
                self
            }
            pub fn generator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.generator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generator: {e}"));
                self
            }
            pub fn generator_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.generator_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for generator_version: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn license_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.license_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for license_count: {e}"));
                self
            }
            pub fn licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.licenses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for licenses: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn spec_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.spec_version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spec_version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SbomContentResponse> for super::SbomContentResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SbomContentResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    component_count: value.component_count?,
                    content: value.content?,
                    content_hash: value.content_hash?,
                    created_at: value.created_at?,
                    dependency_count: value.dependency_count?,
                    format: value.format?,
                    format_version: value.format_version?,
                    generated_at: value.generated_at?,
                    generator: value.generator?,
                    generator_version: value.generator_version?,
                    id: value.id?,
                    license_count: value.license_count?,
                    licenses: value.licenses?,
                    repository_id: value.repository_id?,
                    spec_version: value.spec_version?,
                })
            }
        }
        impl ::std::convert::From<super::SbomContentResponse> for SbomContentResponse {
            fn from(value: super::SbomContentResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    component_count: Ok(value.component_count),
                    content: Ok(value.content),
                    content_hash: Ok(value.content_hash),
                    created_at: Ok(value.created_at),
                    dependency_count: Ok(value.dependency_count),
                    format: Ok(value.format),
                    format_version: Ok(value.format_version),
                    generated_at: Ok(value.generated_at),
                    generator: Ok(value.generator),
                    generator_version: Ok(value.generator_version),
                    id: Ok(value.id),
                    license_count: Ok(value.license_count),
                    licenses: Ok(value.licenses),
                    repository_id: Ok(value.repository_id),
                    spec_version: Ok(value.spec_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SbomResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            component_count: ::std::result::Result<i32, ::std::string::String>,
            content_hash: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            dependency_count: ::std::result::Result<i32, ::std::string::String>,
            format: ::std::result::Result<::std::string::String, ::std::string::String>,
            format_version: ::std::result::Result<::std::string::String, ::std::string::String>,
            generated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            generator: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            generator_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            license_count: ::std::result::Result<i32, ::std::string::String>,
            licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            spec_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SbomResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    component_count: Err("no value supplied for component_count".to_string()),
                    content_hash: Err("no value supplied for content_hash".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    dependency_count: Err("no value supplied for dependency_count".to_string()),
                    format: Err("no value supplied for format".to_string()),
                    format_version: Err("no value supplied for format_version".to_string()),
                    generated_at: Err("no value supplied for generated_at".to_string()),
                    generator: Ok(Default::default()),
                    generator_version: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    license_count: Err("no value supplied for license_count".to_string()),
                    licenses: Err("no value supplied for licenses".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    spec_version: Ok(Default::default()),
                }
            }
        }
        impl SbomResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn component_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.component_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_count: {e}")
                });
                self
            }
            pub fn content_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.content_hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content_hash: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn dependency_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.dependency_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for dependency_count: {e}")
                });
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn format_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.format_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for format_version: {e}")
                });
                self
            }
            pub fn generated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.generated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generated_at: {e}"));
                self
            }
            pub fn generator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.generator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generator: {e}"));
                self
            }
            pub fn generator_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.generator_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for generator_version: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn license_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.license_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for license_count: {e}"));
                self
            }
            pub fn licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.licenses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for licenses: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn spec_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.spec_version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spec_version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SbomResponse> for super::SbomResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SbomResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    component_count: value.component_count?,
                    content_hash: value.content_hash?,
                    created_at: value.created_at?,
                    dependency_count: value.dependency_count?,
                    format: value.format?,
                    format_version: value.format_version?,
                    generated_at: value.generated_at?,
                    generator: value.generator?,
                    generator_version: value.generator_version?,
                    id: value.id?,
                    license_count: value.license_count?,
                    licenses: value.licenses?,
                    repository_id: value.repository_id?,
                    spec_version: value.spec_version?,
                })
            }
        }
        impl ::std::convert::From<super::SbomResponse> for SbomResponse {
            fn from(value: super::SbomResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    component_count: Ok(value.component_count),
                    content_hash: Ok(value.content_hash),
                    created_at: Ok(value.created_at),
                    dependency_count: Ok(value.dependency_count),
                    format: Ok(value.format),
                    format_version: Ok(value.format_version),
                    generated_at: Ok(value.generated_at),
                    generator: Ok(value.generator),
                    generator_version: Ok(value.generator_version),
                    id: Ok(value.id),
                    license_count: Ok(value.license_count),
                    licenses: Ok(value.licenses),
                    repository_id: Ok(value.repository_id),
                    spec_version: Ok(value.spec_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ScanConfigResponse {
            block_on_policy_violation: ::std::result::Result<bool, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            scan_enabled: ::std::result::Result<bool, ::std::string::String>,
            scan_on_proxy: ::std::result::Result<bool, ::std::string::String>,
            scan_on_upload: ::std::result::Result<bool, ::std::string::String>,
            severity_threshold: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ScanConfigResponse {
            fn default() -> Self {
                Self {
                    block_on_policy_violation: Err(
                        "no value supplied for block_on_policy_violation".to_string(),
                    ),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    scan_enabled: Err("no value supplied for scan_enabled".to_string()),
                    scan_on_proxy: Err("no value supplied for scan_on_proxy".to_string()),
                    scan_on_upload: Err("no value supplied for scan_on_upload".to_string()),
                    severity_threshold: Err("no value supplied for severity_threshold".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl ScanConfigResponse {
            pub fn block_on_policy_violation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_on_policy_violation = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_on_policy_violation: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn scan_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scan_enabled: {e}"));
                self
            }
            pub fn scan_on_proxy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_on_proxy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scan_on_proxy: {e}"));
                self
            }
            pub fn scan_on_upload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_on_upload = value.try_into().map_err(|e| {
                    format!("error converting supplied value for scan_on_upload: {e}")
                });
                self
            }
            pub fn severity_threshold<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity_threshold = value.try_into().map_err(|e| {
                    format!("error converting supplied value for severity_threshold: {e}")
                });
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ScanConfigResponse> for super::ScanConfigResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ScanConfigResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_on_policy_violation: value.block_on_policy_violation?,
                    created_at: value.created_at?,
                    id: value.id?,
                    repository_id: value.repository_id?,
                    scan_enabled: value.scan_enabled?,
                    scan_on_proxy: value.scan_on_proxy?,
                    scan_on_upload: value.scan_on_upload?,
                    severity_threshold: value.severity_threshold?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::ScanConfigResponse> for ScanConfigResponse {
            fn from(value: super::ScanConfigResponse) -> Self {
                Self {
                    block_on_policy_violation: Ok(value.block_on_policy_violation),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    repository_id: Ok(value.repository_id),
                    scan_enabled: Ok(value.scan_enabled),
                    scan_on_proxy: Ok(value.scan_on_proxy),
                    scan_on_upload: Ok(value.scan_on_upload),
                    severity_threshold: Ok(value.severity_threshold),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ScanListResponse {
            items:
                ::std::result::Result<::std::vec::Vec<super::ScanResponse>, ::std::string::String>,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for ScanListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl ScanListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ScanResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ScanListResponse> for super::ScanListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ScanListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::ScanListResponse> for ScanListResponse {
            fn from(value: super::ScanListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ScanResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            artifact_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            artifact_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            completed_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            critical_count: ::std::result::Result<i32, ::std::string::String>,
            error_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            findings_count: ::std::result::Result<i32, ::std::string::String>,
            high_count: ::std::result::Result<i32, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            info_count: ::std::result::Result<i32, ::std::string::String>,
            low_count: ::std::result::Result<i32, ::std::string::String>,
            medium_count: ::std::result::Result<i32, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            scan_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            scanner_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            started_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ScanResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    artifact_name: Ok(Default::default()),
                    artifact_version: Ok(Default::default()),
                    completed_at: Ok(Default::default()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    critical_count: Err("no value supplied for critical_count".to_string()),
                    error_message: Ok(Default::default()),
                    findings_count: Err("no value supplied for findings_count".to_string()),
                    high_count: Err("no value supplied for high_count".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    info_count: Err("no value supplied for info_count".to_string()),
                    low_count: Err("no value supplied for low_count".to_string()),
                    medium_count: Err("no value supplied for medium_count".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    scan_type: Err("no value supplied for scan_type".to_string()),
                    scanner_version: Ok(Default::default()),
                    started_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl ScanResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn artifact_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_name: {e}"));
                self
            }
            pub fn artifact_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_version: {e}")
                });
                self
            }
            pub fn completed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.completed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for completed_at: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn critical_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.critical_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for critical_count: {e}")
                });
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_message: {e}"));
                self
            }
            pub fn findings_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.findings_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for findings_count: {e}")
                });
                self
            }
            pub fn high_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.high_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high_count: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn info_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.info_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for info_count: {e}"));
                self
            }
            pub fn low_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.low_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low_count: {e}"));
                self
            }
            pub fn medium_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.medium_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for medium_count: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn scan_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scan_type: {e}"));
                self
            }
            pub fn scanner_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.scanner_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for scanner_version: {e}")
                });
                self
            }
            pub fn started_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.started_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for started_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ScanResponse> for super::ScanResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ScanResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    artifact_name: value.artifact_name?,
                    artifact_version: value.artifact_version?,
                    completed_at: value.completed_at?,
                    created_at: value.created_at?,
                    critical_count: value.critical_count?,
                    error_message: value.error_message?,
                    findings_count: value.findings_count?,
                    high_count: value.high_count?,
                    id: value.id?,
                    info_count: value.info_count?,
                    low_count: value.low_count?,
                    medium_count: value.medium_count?,
                    repository_id: value.repository_id?,
                    scan_type: value.scan_type?,
                    scanner_version: value.scanner_version?,
                    started_at: value.started_at?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::ScanResponse> for ScanResponse {
            fn from(value: super::ScanResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    artifact_name: Ok(value.artifact_name),
                    artifact_version: Ok(value.artifact_version),
                    completed_at: Ok(value.completed_at),
                    created_at: Ok(value.created_at),
                    critical_count: Ok(value.critical_count),
                    error_message: Ok(value.error_message),
                    findings_count: Ok(value.findings_count),
                    high_count: Ok(value.high_count),
                    id: Ok(value.id),
                    info_count: Ok(value.info_count),
                    low_count: Ok(value.low_count),
                    medium_count: Ok(value.medium_count),
                    repository_id: Ok(value.repository_id),
                    scan_type: Ok(value.scan_type),
                    scanner_version: Ok(value.scanner_version),
                    started_at: Ok(value.started_at),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ScoreResponse {
            acknowledged_count: ::std::result::Result<i32, ::std::string::String>,
            calculated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            critical_count: ::std::result::Result<i32, ::std::string::String>,
            grade: ::std::result::Result<::std::string::String, ::std::string::String>,
            high_count: ::std::result::Result<i32, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_scan_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            low_count: ::std::result::Result<i32, ::std::string::String>,
            medium_count: ::std::result::Result<i32, ::std::string::String>,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            score: ::std::result::Result<i32, ::std::string::String>,
            total_findings: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for ScoreResponse {
            fn default() -> Self {
                Self {
                    acknowledged_count: Err("no value supplied for acknowledged_count".to_string()),
                    calculated_at: Err("no value supplied for calculated_at".to_string()),
                    critical_count: Err("no value supplied for critical_count".to_string()),
                    grade: Err("no value supplied for grade".to_string()),
                    high_count: Err("no value supplied for high_count".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    last_scan_at: Ok(Default::default()),
                    low_count: Err("no value supplied for low_count".to_string()),
                    medium_count: Err("no value supplied for medium_count".to_string()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    score: Err("no value supplied for score".to_string()),
                    total_findings: Err("no value supplied for total_findings".to_string()),
                }
            }
        }
        impl ScoreResponse {
            pub fn acknowledged_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.acknowledged_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for acknowledged_count: {e}")
                });
                self
            }
            pub fn calculated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.calculated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for calculated_at: {e}"));
                self
            }
            pub fn critical_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.critical_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for critical_count: {e}")
                });
                self
            }
            pub fn grade<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.grade = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for grade: {e}"));
                self
            }
            pub fn high_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.high_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high_count: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn last_scan_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_scan_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_scan_at: {e}"));
                self
            }
            pub fn low_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.low_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low_count: {e}"));
                self
            }
            pub fn medium_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.medium_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for medium_count: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for score: {e}"));
                self
            }
            pub fn total_findings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_findings = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_findings: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ScoreResponse> for super::ScoreResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ScoreResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acknowledged_count: value.acknowledged_count?,
                    calculated_at: value.calculated_at?,
                    critical_count: value.critical_count?,
                    grade: value.grade?,
                    high_count: value.high_count?,
                    id: value.id?,
                    last_scan_at: value.last_scan_at?,
                    low_count: value.low_count?,
                    medium_count: value.medium_count?,
                    repository_id: value.repository_id?,
                    score: value.score?,
                    total_findings: value.total_findings?,
                })
            }
        }
        impl ::std::convert::From<super::ScoreResponse> for ScoreResponse {
            fn from(value: super::ScoreResponse) -> Self {
                Self {
                    acknowledged_count: Ok(value.acknowledged_count),
                    calculated_at: Ok(value.calculated_at),
                    critical_count: Ok(value.critical_count),
                    grade: Ok(value.grade),
                    high_count: Ok(value.high_count),
                    id: Ok(value.id),
                    last_scan_at: Ok(value.last_scan_at),
                    low_count: Ok(value.low_count),
                    medium_count: Ok(value.medium_count),
                    repository_id: Ok(value.repository_id),
                    score: Ok(value.score),
                    total_findings: Ok(value.total_findings),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ScoredPeerResponse {
            available_chunks: ::std::result::Result<i32, ::std::string::String>,
            bandwidth_estimate_bps:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            endpoint_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            latency_ms: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            score: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for ScoredPeerResponse {
            fn default() -> Self {
                Self {
                    available_chunks: Err("no value supplied for available_chunks".to_string()),
                    bandwidth_estimate_bps: Ok(Default::default()),
                    endpoint_url: Err("no value supplied for endpoint_url".to_string()),
                    latency_ms: Ok(Default::default()),
                    peer_id: Err("no value supplied for peer_id".to_string()),
                    score: Err("no value supplied for score".to_string()),
                }
            }
        }
        impl ScoredPeerResponse {
            pub fn available_chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.available_chunks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for available_chunks: {e}")
                });
                self
            }
            pub fn bandwidth_estimate_bps<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bandwidth_estimate_bps = value.try_into().map_err(|e| {
                    format!("error converting supplied value for bandwidth_estimate_bps: {e}")
                });
                self
            }
            pub fn endpoint_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint_url: {e}"));
                self
            }
            pub fn latency_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.latency_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for latency_ms: {e}"));
                self
            }
            pub fn peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.peer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_id: {e}"));
                self
            }
            pub fn score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.score = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for score: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ScoredPeerResponse> for super::ScoredPeerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ScoredPeerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    available_chunks: value.available_chunks?,
                    bandwidth_estimate_bps: value.bandwidth_estimate_bps?,
                    endpoint_url: value.endpoint_url?,
                    latency_ms: value.latency_ms?,
                    peer_id: value.peer_id?,
                    score: value.score?,
                })
            }
        }
        impl ::std::convert::From<super::ScoredPeerResponse> for ScoredPeerResponse {
            fn from(value: super::ScoredPeerResponse) -> Self {
                Self {
                    available_chunks: Ok(value.available_chunks),
                    bandwidth_estimate_bps: Ok(value.bandwidth_estimate_bps),
                    endpoint_url: Ok(value.endpoint_url),
                    latency_ms: Ok(value.latency_ms),
                    peer_id: Ok(value.peer_id),
                    score: Ok(value.score),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SearchResultItem {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            highlights: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SearchResultItem {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    format: Ok(Default::default()),
                    highlights: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    path: Ok(Default::default()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    size_bytes: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl SearchResultItem {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.format = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for format: {e}"));
                self
            }
            pub fn highlights<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.highlights = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for highlights: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SearchResultItem> for super::SearchResultItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SearchResultItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    format: value.format?,
                    highlights: value.highlights?,
                    id: value.id?,
                    name: value.name?,
                    path: value.path?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                    type_: value.type_?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::SearchResultItem> for SearchResultItem {
            fn from(value: super::SearchResultItem) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    format: Ok(value.format),
                    highlights: Ok(value.highlights),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                    type_: Ok(value.type_),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ServiceHealthEntry {
            checked_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            previous_status: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            response_time_ms:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            service_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ServiceHealthEntry {
            fn default() -> Self {
                Self {
                    checked_at: Err("no value supplied for checked_at".to_string()),
                    message: Ok(Default::default()),
                    previous_status: Ok(Default::default()),
                    response_time_ms: Ok(Default::default()),
                    service_name: Err("no value supplied for service_name".to_string()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl ServiceHealthEntry {
            pub fn checked_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.checked_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checked_at: {e}"));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
            pub fn previous_status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.previous_status = value.try_into().map_err(|e| {
                    format!("error converting supplied value for previous_status: {e}")
                });
                self
            }
            pub fn response_time_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.response_time_ms = value.try_into().map_err(|e| {
                    format!("error converting supplied value for response_time_ms: {e}")
                });
                self
            }
            pub fn service_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.service_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service_name: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ServiceHealthEntry> for super::ServiceHealthEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ServiceHealthEntry,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    checked_at: value.checked_at?,
                    message: value.message?,
                    previous_status: value.previous_status?,
                    response_time_ms: value.response_time_ms?,
                    service_name: value.service_name?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::ServiceHealthEntry> for ServiceHealthEntry {
            fn from(value: super::ServiceHealthEntry) -> Self {
                Self {
                    checked_at: Ok(value.checked_at),
                    message: Ok(value.message),
                    previous_status: Ok(value.previous_status),
                    response_time_ms: Ok(value.response_time_ms),
                    service_name: Ok(value.service_name),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SetLabelsRequest {
            labels: ::std::result::Result<
                ::std::vec::Vec<super::LabelEntrySchema>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SetLabelsRequest {
            fn default() -> Self {
                Self {
                    labels: Err("no value supplied for labels".to_string()),
                }
            }
        }
        impl SetLabelsRequest {
            pub fn labels<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::LabelEntrySchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.labels = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for labels: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SetLabelsRequest> for super::SetLabelsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SetLabelsRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    labels: value.labels?,
                })
            }
        }
        impl ::std::convert::From<super::SetLabelsRequest> for SetLabelsRequest {
            fn from(value: super::SetLabelsRequest) -> Self {
                Self {
                    labels: Ok(value.labels),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SetPeerLabelsRequest {
            labels: ::std::result::Result<
                ::std::vec::Vec<super::PeerLabelEntrySchema>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SetPeerLabelsRequest {
            fn default() -> Self {
                Self {
                    labels: Err("no value supplied for labels".to_string()),
                }
            }
        }
        impl SetPeerLabelsRequest {
            pub fn labels<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PeerLabelEntrySchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.labels = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for labels: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SetPeerLabelsRequest> for super::SetPeerLabelsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SetPeerLabelsRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    labels: value.labels?,
                })
            }
        }
        impl ::std::convert::From<super::SetPeerLabelsRequest> for SetPeerLabelsRequest {
            fn from(value: super::SetPeerLabelsRequest) -> Self {
                Self {
                    labels: Ok(value.labels),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SetupStatusResponse {
            setup_required: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for SetupStatusResponse {
            fn default() -> Self {
                Self {
                    setup_required: Err("no value supplied for setup_required".to_string()),
                }
            }
        }
        impl SetupStatusResponse {
            pub fn setup_required<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.setup_required = value.try_into().map_err(|e| {
                    format!("error converting supplied value for setup_required: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SetupStatusResponse> for super::SetupStatusResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SetupStatusResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    setup_required: value.setup_required?,
                })
            }
        }
        impl ::std::convert::From<super::SetupStatusResponse> for SetupStatusResponse {
            fn from(value: super::SetupStatusResponse) -> Self {
                Self {
                    setup_required: Ok(value.setup_required),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SigningConfigResponse {
            key: ::std::result::Result<
                ::std::option::Option<super::SigningKeyPublic>,
                ::std::string::String,
            >,
            repository_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            require_signatures: ::std::result::Result<bool, ::std::string::String>,
            sign_metadata: ::std::result::Result<bool, ::std::string::String>,
            sign_packages: ::std::result::Result<bool, ::std::string::String>,
            signing_key_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for SigningConfigResponse {
            fn default() -> Self {
                Self {
                    key: Ok(Default::default()),
                    repository_id: Err("no value supplied for repository_id".to_string()),
                    require_signatures: Err("no value supplied for require_signatures".to_string()),
                    sign_metadata: Err("no value supplied for sign_metadata".to_string()),
                    sign_packages: Err("no value supplied for sign_packages".to_string()),
                    signing_key_id: Ok(Default::default()),
                }
            }
        }
        impl SigningConfigResponse {
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::SigningKeyPublic>>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn require_signatures<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signatures = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signatures: {e}")
                });
                self
            }
            pub fn sign_metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_metadata: {e}"));
                self
            }
            pub fn sign_packages<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_packages = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_packages: {e}"));
                self
            }
            pub fn signing_key_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.signing_key_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signing_key_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SigningConfigResponse> for super::SigningConfigResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SigningConfigResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key: value.key?,
                    repository_id: value.repository_id?,
                    require_signatures: value.require_signatures?,
                    sign_metadata: value.sign_metadata?,
                    sign_packages: value.sign_packages?,
                    signing_key_id: value.signing_key_id?,
                })
            }
        }
        impl ::std::convert::From<super::SigningConfigResponse> for SigningConfigResponse {
            fn from(value: super::SigningConfigResponse) -> Self {
                Self {
                    key: Ok(value.key),
                    repository_id: Ok(value.repository_id),
                    require_signatures: Ok(value.require_signatures),
                    sign_metadata: Ok(value.sign_metadata),
                    sign_packages: Ok(value.sign_packages),
                    signing_key_id: Ok(value.signing_key_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SigningKeyPublic {
            algorithm: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            expires_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            fingerprint: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_active: ::std::result::Result<bool, ::std::string::String>,
            key_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            key_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            last_used_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            public_key_pem: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            uid_email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            uid_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SigningKeyPublic {
            fn default() -> Self {
                Self {
                    algorithm: Err("no value supplied for algorithm".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    expires_at: Ok(Default::default()),
                    fingerprint: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    is_active: Err("no value supplied for is_active".to_string()),
                    key_id: Ok(Default::default()),
                    key_type: Err("no value supplied for key_type".to_string()),
                    last_used_at: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    public_key_pem: Err("no value supplied for public_key_pem".to_string()),
                    repository_id: Ok(Default::default()),
                    uid_email: Ok(Default::default()),
                    uid_name: Ok(Default::default()),
                }
            }
        }
        impl SigningKeyPublic {
            pub fn algorithm<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.algorithm = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for algorithm: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn expires_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.expires_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for expires_at: {e}"));
                self
            }
            pub fn fingerprint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.fingerprint = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fingerprint: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_active<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_active = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_active: {e}"));
                self
            }
            pub fn key_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.key_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key_id: {e}"));
                self
            }
            pub fn key_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key_type: {e}"));
                self
            }
            pub fn last_used_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_used_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_used_at: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn public_key_pem<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key_pem = value.try_into().map_err(|e| {
                    format!("error converting supplied value for public_key_pem: {e}")
                });
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn uid_email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.uid_email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid_email: {e}"));
                self
            }
            pub fn uid_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.uid_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid_name: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SigningKeyPublic> for super::SigningKeyPublic {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SigningKeyPublic,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    algorithm: value.algorithm?,
                    created_at: value.created_at?,
                    expires_at: value.expires_at?,
                    fingerprint: value.fingerprint?,
                    id: value.id?,
                    is_active: value.is_active?,
                    key_id: value.key_id?,
                    key_type: value.key_type?,
                    last_used_at: value.last_used_at?,
                    name: value.name?,
                    public_key_pem: value.public_key_pem?,
                    repository_id: value.repository_id?,
                    uid_email: value.uid_email?,
                    uid_name: value.uid_name?,
                })
            }
        }
        impl ::std::convert::From<super::SigningKeyPublic> for SigningKeyPublic {
            fn from(value: super::SigningKeyPublic) -> Self {
                Self {
                    algorithm: Ok(value.algorithm),
                    created_at: Ok(value.created_at),
                    expires_at: Ok(value.expires_at),
                    fingerprint: Ok(value.fingerprint),
                    id: Ok(value.id),
                    is_active: Ok(value.is_active),
                    key_id: Ok(value.key_id),
                    key_type: Ok(value.key_type),
                    last_used_at: Ok(value.last_used_at),
                    name: Ok(value.name),
                    public_key_pem: Ok(value.public_key_pem),
                    repository_id: Ok(value.repository_id),
                    uid_email: Ok(value.uid_email),
                    uid_name: Ok(value.uid_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SourceConnectionRow {
            auth_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            created_by:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            credentials_enc: ::std::result::Result<::std::vec::Vec<i32>, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            source_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
            verified_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SourceConnectionRow {
            fn default() -> Self {
                Self {
                    auth_type: Err("no value supplied for auth_type".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    created_by: Ok(Default::default()),
                    credentials_enc: Err("no value supplied for credentials_enc".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source_type: Err("no value supplied for source_type".to_string()),
                    url: Err("no value supplied for url".to_string()),
                    verified_at: Ok(Default::default()),
                }
            }
        }
        impl SourceConnectionRow {
            pub fn auth_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.auth_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auth_type: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn created_by<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_by = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_by: {e}"));
                self
            }
            pub fn credentials_enc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.credentials_enc = value.try_into().map_err(|e| {
                    format!("error converting supplied value for credentials_enc: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn source_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_type: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SourceConnectionRow> for super::SourceConnectionRow {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SourceConnectionRow,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auth_type: value.auth_type?,
                    created_at: value.created_at?,
                    created_by: value.created_by?,
                    credentials_enc: value.credentials_enc?,
                    id: value.id?,
                    name: value.name?,
                    source_type: value.source_type?,
                    url: value.url?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::SourceConnectionRow> for SourceConnectionRow {
            fn from(value: super::SourceConnectionRow) -> Self {
                Self {
                    auth_type: Ok(value.auth_type),
                    created_at: Ok(value.created_at),
                    created_by: Ok(value.created_by),
                    credentials_enc: Ok(value.credentials_enc),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    source_type: Ok(value.source_type),
                    url: Ok(value.url),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SourceRepository {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            package_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SourceRepository {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    key: Err("no value supplied for key".to_string()),
                    package_type: Err("no value supplied for package_type".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl SourceRepository {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn package_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.package_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for package_type: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SourceRepository> for super::SourceRepository {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SourceRepository,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    key: value.key?,
                    package_type: value.package_type?,
                    type_: value.type_?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::SourceRepository> for SourceRepository {
            fn from(value: super::SourceRepository) -> Self {
                Self {
                    description: Ok(value.description),
                    key: Ok(value.key),
                    package_type: Ok(value.package_type),
                    type_: Ok(value.type_),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SsoProviderInfo {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            login_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            provider_type: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SsoProviderInfo {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    login_url: Err("no value supplied for login_url".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    provider_type: Err("no value supplied for provider_type".to_string()),
                }
            }
        }
        impl SsoProviderInfo {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn login_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.login_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for login_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn provider_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.provider_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for provider_type: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SsoProviderInfo> for super::SsoProviderInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SsoProviderInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    login_url: value.login_url?,
                    name: value.name?,
                    provider_type: value.provider_type?,
                })
            }
        }
        impl ::std::convert::From<super::SsoProviderInfo> for SsoProviderInfo {
            fn from(value: super::SsoProviderInfo) -> Self {
                Self {
                    id: Ok(value.id),
                    login_url: Ok(value.login_url),
                    name: Ok(value.name),
                    provider_type: Ok(value.provider_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StaleArtifact {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            days_since_download: ::std::result::Result<i64, ::std::string::String>,
            download_count: ::std::result::Result<i64, ::std::string::String>,
            last_downloaded_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for StaleArtifact {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    days_since_download: Err(
                        "no value supplied for days_since_download".to_string()
                    ),
                    download_count: Err("no value supplied for download_count".to_string()),
                    last_downloaded_at: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    repository_key: Err("no value supplied for repository_key".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                }
            }
        }
        impl StaleArtifact {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn days_since_download<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.days_since_download = value.try_into().map_err(|e| {
                    format!("error converting supplied value for days_since_download: {e}")
                });
                self
            }
            pub fn download_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.download_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for download_count: {e}")
                });
                self
            }
            pub fn last_downloaded_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_downloaded_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_downloaded_at: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<StaleArtifact> for super::StaleArtifact {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StaleArtifact,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    created_at: value.created_at?,
                    days_since_download: value.days_since_download?,
                    download_count: value.download_count?,
                    last_downloaded_at: value.last_downloaded_at?,
                    name: value.name?,
                    path: value.path?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::StaleArtifact> for StaleArtifact {
            fn from(value: super::StaleArtifact) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    created_at: Ok(value.created_at),
                    days_since_download: Ok(value.days_since_download),
                    download_count: Ok(value.download_count),
                    last_downloaded_at: Ok(value.last_downloaded_at),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StaleQuery {
            days: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            limit: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for StaleQuery {
            fn default() -> Self {
                Self {
                    days: Ok(Default::default()),
                    limit: Ok(Default::default()),
                }
            }
        }
        impl StaleQuery {
            pub fn days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.days = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for days: {e}"));
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for limit: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<StaleQuery> for super::StaleQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StaleQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    days: value.days?,
                    limit: value.limit?,
                })
            }
        }
        impl ::std::convert::From<super::StaleQuery> for StaleQuery {
            fn from(value: super::StaleQuery) -> Self {
                Self {
                    days: Ok(value.days),
                    limit: Ok(value.limit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StorageSnapshot {
            snapshot_date: ::std::result::Result<::chrono::naive::NaiveDate, ::std::string::String>,
            total_artifacts: ::std::result::Result<i64, ::std::string::String>,
            total_downloads: ::std::result::Result<i64, ::std::string::String>,
            total_repositories: ::std::result::Result<i64, ::std::string::String>,
            total_storage_bytes: ::std::result::Result<i64, ::std::string::String>,
            total_users: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for StorageSnapshot {
            fn default() -> Self {
                Self {
                    snapshot_date: Err("no value supplied for snapshot_date".to_string()),
                    total_artifacts: Err("no value supplied for total_artifacts".to_string()),
                    total_downloads: Err("no value supplied for total_downloads".to_string()),
                    total_repositories: Err("no value supplied for total_repositories".to_string()),
                    total_storage_bytes: Err(
                        "no value supplied for total_storage_bytes".to_string()
                    ),
                    total_users: Err("no value supplied for total_users".to_string()),
                }
            }
        }
        impl StorageSnapshot {
            pub fn snapshot_date<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::naive::NaiveDate>,
                T::Error: ::std::fmt::Display,
            {
                self.snapshot_date = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for snapshot_date: {e}"));
                self
            }
            pub fn total_artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_artifacts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_artifacts: {e}")
                });
                self
            }
            pub fn total_downloads<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_downloads = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_downloads: {e}")
                });
                self
            }
            pub fn total_repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_repositories = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_repositories: {e}")
                });
                self
            }
            pub fn total_storage_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_storage_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_storage_bytes: {e}")
                });
                self
            }
            pub fn total_users<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_users = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_users: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<StorageSnapshot> for super::StorageSnapshot {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StorageSnapshot,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    snapshot_date: value.snapshot_date?,
                    total_artifacts: value.total_artifacts?,
                    total_downloads: value.total_downloads?,
                    total_repositories: value.total_repositories?,
                    total_storage_bytes: value.total_storage_bytes?,
                    total_users: value.total_users?,
                })
            }
        }
        impl ::std::convert::From<super::StorageSnapshot> for StorageSnapshot {
            fn from(value: super::StorageSnapshot) -> Self {
                Self {
                    snapshot_date: Ok(value.snapshot_date),
                    total_artifacts: Ok(value.total_artifacts),
                    total_downloads: Ok(value.total_downloads),
                    total_repositories: Ok(value.total_repositories),
                    total_storage_bytes: Ok(value.total_storage_bytes),
                    total_users: Ok(value.total_users),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SubmitCrashesRequest {
            ids: ::std::result::Result<::std::vec::Vec<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for SubmitCrashesRequest {
            fn default() -> Self {
                Self {
                    ids: Err("no value supplied for ids".to_string()),
                }
            }
        }
        impl SubmitCrashesRequest {
            pub fn ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ids: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SubmitCrashesRequest> for super::SubmitCrashesRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SubmitCrashesRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { ids: value.ids? })
            }
        }
        impl ::std::convert::From<super::SubmitCrashesRequest> for SubmitCrashesRequest {
            fn from(value: super::SubmitCrashesRequest) -> Self {
                Self { ids: Ok(value.ids) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SubmitResponse {
            marked_submitted: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for SubmitResponse {
            fn default() -> Self {
                Self {
                    marked_submitted: Err("no value supplied for marked_submitted".to_string()),
                }
            }
        }
        impl SubmitResponse {
            pub fn marked_submitted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.marked_submitted = value.try_into().map_err(|e| {
                    format!("error converting supplied value for marked_submitted: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SubmitResponse> for super::SubmitResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SubmitResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    marked_submitted: value.marked_submitted?,
                })
            }
        }
        impl ::std::convert::From<super::SubmitResponse> for SubmitResponse {
            fn from(value: super::SubmitResponse) -> Self {
                Self {
                    marked_submitted: Ok(value.marked_submitted),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SuggestResponse {
            suggestions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SuggestResponse {
            fn default() -> Self {
                Self {
                    suggestions: Err("no value supplied for suggestions".to_string()),
                }
            }
        }
        impl SuggestResponse {
            pub fn suggestions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.suggestions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for suggestions: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SuggestResponse> for super::SuggestResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SuggestResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    suggestions: value.suggestions?,
                })
            }
        }
        impl ::std::convert::From<super::SuggestResponse> for SuggestResponse {
            fn from(value: super::SuggestResponse) -> Self {
                Self {
                    suggestions: Ok(value.suggestions),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SuppressIssueRequest {
            reason: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SuppressIssueRequest {
            fn default() -> Self {
                Self {
                    reason: Err("no value supplied for reason".to_string()),
                }
            }
        }
        impl SuppressIssueRequest {
            pub fn reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.reason = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reason: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SuppressIssueRequest> for super::SuppressIssueRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SuppressIssueRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    reason: value.reason?,
                })
            }
        }
        impl ::std::convert::From<super::SuppressIssueRequest> for SuppressIssueRequest {
            fn from(value: super::SuppressIssueRequest) -> Self {
                Self {
                    reason: Ok(value.reason),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SuppressRequest {
            service_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            until: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SuppressRequest {
            fn default() -> Self {
                Self {
                    service_name: Err("no value supplied for service_name".to_string()),
                    until: Err("no value supplied for until".to_string()),
                }
            }
        }
        impl SuppressRequest {
            pub fn service_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.service_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service_name: {e}"));
                self
            }
            pub fn until<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.until = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for until: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SuppressRequest> for super::SuppressRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SuppressRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    service_name: value.service_name?,
                    until: value.until?,
                })
            }
        }
        impl ::std::convert::From<super::SuppressRequest> for SuppressRequest {
            fn from(value: super::SuppressRequest) -> Self {
                Self {
                    service_name: Ok(value.service_name),
                    until: Ok(value.until),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SyncPolicyListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::SyncPolicyResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for SyncPolicyListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl SyncPolicyListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SyncPolicyResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SyncPolicyListResponse> for super::SyncPolicyListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SyncPolicyListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::SyncPolicyListResponse> for SyncPolicyListResponse {
            fn from(value: super::SyncPolicyListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SyncPolicyResponse {
            artifact_filter: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            enabled: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            peer_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            precedence: ::std::result::Result<i32, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
            replication_mode: ::std::result::Result<::std::string::String, ::std::string::String>,
            repo_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SyncPolicyResponse {
            fn default() -> Self {
                Self {
                    artifact_filter: Err("no value supplied for artifact_filter".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    enabled: Err("no value supplied for enabled".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    peer_selector: Err("no value supplied for peer_selector".to_string()),
                    precedence: Err("no value supplied for precedence".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    replication_mode: Err("no value supplied for replication_mode".to_string()),
                    repo_selector: Err("no value supplied for repo_selector".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl SyncPolicyResponse {
            pub fn artifact_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_filter = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_filter: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.peer_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_selector: {e}"));
                self
            }
            pub fn precedence<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.precedence = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for precedence: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn replication_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.replication_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for replication_mode: {e}")
                });
                self
            }
            pub fn repo_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.repo_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repo_selector: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SyncPolicyResponse> for super::SyncPolicyResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SyncPolicyResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_filter: value.artifact_filter?,
                    created_at: value.created_at?,
                    description: value.description?,
                    enabled: value.enabled?,
                    id: value.id?,
                    name: value.name?,
                    peer_selector: value.peer_selector?,
                    precedence: value.precedence?,
                    priority: value.priority?,
                    replication_mode: value.replication_mode?,
                    repo_selector: value.repo_selector?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::SyncPolicyResponse> for SyncPolicyResponse {
            fn from(value: super::SyncPolicyResponse) -> Self {
                Self {
                    artifact_filter: Ok(value.artifact_filter),
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    enabled: Ok(value.enabled),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    peer_selector: Ok(value.peer_selector),
                    precedence: Ok(value.precedence),
                    priority: Ok(value.priority),
                    replication_mode: Ok(value.replication_mode),
                    repo_selector: Ok(value.repo_selector),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SyncTaskResponse {
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            artifact_size: ::std::result::Result<i64, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
            storage_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SyncTaskResponse {
            fn default() -> Self {
                Self {
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    artifact_size: Err("no value supplied for artifact_size".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    storage_key: Err("no value supplied for storage_key".to_string()),
                }
            }
        }
        impl SyncTaskResponse {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn artifact_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_size: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn storage_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.storage_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage_key: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SyncTaskResponse> for super::SyncTaskResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SyncTaskResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    artifact_size: value.artifact_size?,
                    id: value.id?,
                    priority: value.priority?,
                    storage_key: value.storage_key?,
                })
            }
        }
        impl ::std::convert::From<super::SyncTaskResponse> for SyncTaskResponse {
            fn from(value: super::SyncTaskResponse) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    artifact_size: Ok(value.artifact_size),
                    id: Ok(value.id),
                    priority: Ok(value.priority),
                    storage_key: Ok(value.storage_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SystemSettings {
            allow_anonymous_download: ::std::result::Result<bool, ::std::string::String>,
            audit_retention_days: ::std::result::Result<i32, ::std::string::String>,
            backup_retention_count: ::std::result::Result<i32, ::std::string::String>,
            edge_stale_threshold_minutes: ::std::result::Result<i32, ::std::string::String>,
            max_upload_size_bytes: ::std::result::Result<i64, ::std::string::String>,
            retention_days: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for SystemSettings {
            fn default() -> Self {
                Self {
                    allow_anonymous_download: Err(
                        "no value supplied for allow_anonymous_download".to_string()
                    ),
                    audit_retention_days: Err(
                        "no value supplied for audit_retention_days".to_string()
                    ),
                    backup_retention_count: Err(
                        "no value supplied for backup_retention_count".to_string()
                    ),
                    edge_stale_threshold_minutes: Err(
                        "no value supplied for edge_stale_threshold_minutes".to_string(),
                    ),
                    max_upload_size_bytes: Err(
                        "no value supplied for max_upload_size_bytes".to_string()
                    ),
                    retention_days: Err("no value supplied for retention_days".to_string()),
                }
            }
        }
        impl SystemSettings {
            pub fn allow_anonymous_download<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.allow_anonymous_download = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allow_anonymous_download: {e}")
                });
                self
            }
            pub fn audit_retention_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.audit_retention_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for audit_retention_days: {e}")
                });
                self
            }
            pub fn backup_retention_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.backup_retention_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for backup_retention_count: {e}")
                });
                self
            }
            pub fn edge_stale_threshold_minutes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.edge_stale_threshold_minutes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for edge_stale_threshold_minutes: {e}")
                });
                self
            }
            pub fn max_upload_size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.max_upload_size_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_upload_size_bytes: {e}")
                });
                self
            }
            pub fn retention_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.retention_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for retention_days: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SystemSettings> for super::SystemSettings {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SystemSettings,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allow_anonymous_download: value.allow_anonymous_download?,
                    audit_retention_days: value.audit_retention_days?,
                    backup_retention_count: value.backup_retention_count?,
                    edge_stale_threshold_minutes: value.edge_stale_threshold_minutes?,
                    max_upload_size_bytes: value.max_upload_size_bytes?,
                    retention_days: value.retention_days?,
                })
            }
        }
        impl ::std::convert::From<super::SystemSettings> for SystemSettings {
            fn from(value: super::SystemSettings) -> Self {
                Self {
                    allow_anonymous_download: Ok(value.allow_anonymous_download),
                    audit_retention_days: Ok(value.audit_retention_days),
                    backup_retention_count: Ok(value.backup_retention_count),
                    edge_stale_threshold_minutes: Ok(value.edge_stale_threshold_minutes),
                    max_upload_size_bytes: Ok(value.max_upload_size_bytes),
                    retention_days: Ok(value.retention_days),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SystemStats {
            active_peers: ::std::result::Result<i64, ::std::string::String>,
            pending_sync_tasks: ::std::result::Result<i64, ::std::string::String>,
            total_artifacts: ::std::result::Result<i64, ::std::string::String>,
            total_downloads: ::std::result::Result<i64, ::std::string::String>,
            total_repositories: ::std::result::Result<i64, ::std::string::String>,
            total_storage_bytes: ::std::result::Result<i64, ::std::string::String>,
            total_users: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for SystemStats {
            fn default() -> Self {
                Self {
                    active_peers: Err("no value supplied for active_peers".to_string()),
                    pending_sync_tasks: Err("no value supplied for pending_sync_tasks".to_string()),
                    total_artifacts: Err("no value supplied for total_artifacts".to_string()),
                    total_downloads: Err("no value supplied for total_downloads".to_string()),
                    total_repositories: Err("no value supplied for total_repositories".to_string()),
                    total_storage_bytes: Err(
                        "no value supplied for total_storage_bytes".to_string()
                    ),
                    total_users: Err("no value supplied for total_users".to_string()),
                }
            }
        }
        impl SystemStats {
            pub fn active_peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.active_peers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for active_peers: {e}"));
                self
            }
            pub fn pending_sync_tasks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.pending_sync_tasks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for pending_sync_tasks: {e}")
                });
                self
            }
            pub fn total_artifacts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_artifacts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_artifacts: {e}")
                });
                self
            }
            pub fn total_downloads<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_downloads = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_downloads: {e}")
                });
                self
            }
            pub fn total_repositories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_repositories = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_repositories: {e}")
                });
                self
            }
            pub fn total_storage_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_storage_bytes = value.try_into().map_err(|e| {
                    format!("error converting supplied value for total_storage_bytes: {e}")
                });
                self
            }
            pub fn total_users<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_users = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_users: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<SystemStats> for super::SystemStats {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SystemStats,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    active_peers: value.active_peers?,
                    pending_sync_tasks: value.pending_sync_tasks?,
                    total_artifacts: value.total_artifacts?,
                    total_downloads: value.total_downloads?,
                    total_repositories: value.total_repositories?,
                    total_storage_bytes: value.total_storage_bytes?,
                    total_users: value.total_users?,
                })
            }
        }
        impl ::std::convert::From<super::SystemStats> for SystemStats {
            fn from(value: super::SystemStats) -> Self {
                Self {
                    active_peers: Ok(value.active_peers),
                    pending_sync_tasks: Ok(value.pending_sync_tasks),
                    total_artifacts: Ok(value.total_artifacts),
                    total_downloads: Ok(value.total_downloads),
                    total_repositories: Ok(value.total_repositories),
                    total_storage_bytes: Ok(value.total_storage_bytes),
                    total_users: Ok(value.total_users),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TelemetrySettings {
            enabled: ::std::result::Result<bool, ::std::string::String>,
            include_logs: ::std::result::Result<bool, ::std::string::String>,
            review_before_send: ::std::result::Result<bool, ::std::string::String>,
            scrub_level: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TelemetrySettings {
            fn default() -> Self {
                Self {
                    enabled: Err("no value supplied for enabled".to_string()),
                    include_logs: Err("no value supplied for include_logs".to_string()),
                    review_before_send: Err("no value supplied for review_before_send".to_string()),
                    scrub_level: Err("no value supplied for scrub_level".to_string()),
                }
            }
        }
        impl TelemetrySettings {
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn include_logs<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.include_logs = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for include_logs: {e}"));
                self
            }
            pub fn review_before_send<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.review_before_send = value.try_into().map_err(|e| {
                    format!("error converting supplied value for review_before_send: {e}")
                });
                self
            }
            pub fn scrub_level<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.scrub_level = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scrub_level: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TelemetrySettings> for super::TelemetrySettings {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TelemetrySettings,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    enabled: value.enabled?,
                    include_logs: value.include_logs?,
                    review_before_send: value.review_before_send?,
                    scrub_level: value.scrub_level?,
                })
            }
        }
        impl ::std::convert::From<super::TelemetrySettings> for TelemetrySettings {
            fn from(value: super::TelemetrySettings) -> Self {
                Self {
                    enabled: Ok(value.enabled),
                    include_logs: Ok(value.include_logs),
                    review_before_send: Ok(value.review_before_send),
                    scrub_level: Ok(value.scrub_level),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TestFormatRequest {
            base64: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            content: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TestFormatRequest {
            fn default() -> Self {
                Self {
                    base64: Ok(Default::default()),
                    content: Err("no value supplied for content".to_string()),
                    path: Err("no value supplied for path".to_string()),
                }
            }
        }
        impl TestFormatRequest {
            pub fn base64<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.base64 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for base64: {e}"));
                self
            }
            pub fn content<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.content = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TestFormatRequest> for super::TestFormatRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TestFormatRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    base64: value.base64?,
                    content: value.content?,
                    path: value.path?,
                })
            }
        }
        impl ::std::convert::From<super::TestFormatRequest> for TestFormatRequest {
            fn from(value: super::TestFormatRequest) -> Self {
                Self {
                    base64: Ok(value.base64),
                    content: Ok(value.content),
                    path: Ok(value.path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TestFormatResponse {
            metadata: ::std::result::Result<
                ::std::option::Option<super::TestMetadata>,
                ::std::string::String,
            >,
            parse_error: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            valid: ::std::result::Result<bool, ::std::string::String>,
            validation_error: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TestFormatResponse {
            fn default() -> Self {
                Self {
                    metadata: Ok(Default::default()),
                    parse_error: Ok(Default::default()),
                    valid: Err("no value supplied for valid".to_string()),
                    validation_error: Ok(Default::default()),
                }
            }
        }
        impl TestFormatResponse {
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TestMetadata>>,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {e}"));
                self
            }
            pub fn parse_error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.parse_error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for parse_error: {e}"));
                self
            }
            pub fn valid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.valid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for valid: {e}"));
                self
            }
            pub fn validation_error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.validation_error = value.try_into().map_err(|e| {
                    format!("error converting supplied value for validation_error: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<TestFormatResponse> for super::TestFormatResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TestFormatResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    metadata: value.metadata?,
                    parse_error: value.parse_error?,
                    valid: value.valid?,
                    validation_error: value.validation_error?,
                })
            }
        }
        impl ::std::convert::From<super::TestFormatResponse> for TestFormatResponse {
            fn from(value: super::TestFormatResponse) -> Self {
                Self {
                    metadata: Ok(value.metadata),
                    parse_error: Ok(value.parse_error),
                    valid: Ok(value.valid),
                    validation_error: Ok(value.validation_error),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TestMetadata {
            content_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            size_bytes: ::std::result::Result<i64, ::std::string::String>,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TestMetadata {
            fn default() -> Self {
                Self {
                    content_type: Err("no value supplied for content_type".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    size_bytes: Err("no value supplied for size_bytes".to_string()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl TestMetadata {
            pub fn content_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.content_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for content_type: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TestMetadata> for super::TestMetadata {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TestMetadata,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    content_type: value.content_type?,
                    path: value.path?,
                    size_bytes: value.size_bytes?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::TestMetadata> for TestMetadata {
            fn from(value: super::TestMetadata) -> Self {
                Self {
                    content_type: Ok(value.content_type),
                    path: Ok(value.path),
                    size_bytes: Ok(value.size_bytes),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TestWebhookResponse {
            error: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            response_body: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status_code: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            success: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for TestWebhookResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    response_body: Ok(Default::default()),
                    status_code: Ok(Default::default()),
                    success: Err("no value supplied for success".to_string()),
                }
            }
        }
        impl TestWebhookResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {e}"));
                self
            }
            pub fn response_body<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.response_body = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for response_body: {e}"));
                self
            }
            pub fn status_code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.status_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status_code: {e}"));
                self
            }
            pub fn success<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.success = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for success: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TestWebhookResponse> for super::TestWebhookResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TestWebhookResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    response_body: value.response_body?,
                    status_code: value.status_code?,
                    success: value.success?,
                })
            }
        }
        impl ::std::convert::From<super::TestWebhookResponse> for TestWebhookResponse {
            fn from(value: super::TestWebhookResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    response_body: Ok(value.response_body),
                    status_code: Ok(value.status_code),
                    success: Ok(value.success),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TicketResponse {
            expires_in: ::std::result::Result<i64, ::std::string::String>,
            ticket: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TicketResponse {
            fn default() -> Self {
                Self {
                    expires_in: Err("no value supplied for expires_in".to_string()),
                    ticket: Err("no value supplied for ticket".to_string()),
                }
            }
        }
        impl TicketResponse {
            pub fn expires_in<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.expires_in = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for expires_in: {e}"));
                self
            }
            pub fn ticket<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.ticket = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ticket: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TicketResponse> for super::TicketResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TicketResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    expires_in: value.expires_in?,
                    ticket: value.ticket?,
                })
            }
        }
        impl ::std::convert::From<super::TicketResponse> for TicketResponse {
            fn from(value: super::TicketResponse) -> Self {
                Self {
                    expires_in: Ok(value.expires_in),
                    ticket: Ok(value.ticket),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TogglePolicyPayload {
            enabled: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for TogglePolicyPayload {
            fn default() -> Self {
                Self {
                    enabled: Err("no value supplied for enabled".to_string()),
                }
            }
        }
        impl TogglePolicyPayload {
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TogglePolicyPayload> for super::TogglePolicyPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TogglePolicyPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    enabled: value.enabled?,
                })
            }
        }
        impl ::std::convert::From<super::TogglePolicyPayload> for TogglePolicyPayload {
            fn from(value: super::TogglePolicyPayload) -> Self {
                Self {
                    enabled: Ok(value.enabled),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ToggleRequest {
            enabled: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for ToggleRequest {
            fn default() -> Self {
                Self {
                    enabled: Err("no value supplied for enabled".to_string()),
                }
            }
        }
        impl ToggleRequest {
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<ToggleRequest> for super::ToggleRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ToggleRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    enabled: value.enabled?,
                })
            }
        }
        impl ::std::convert::From<super::ToggleRequest> for ToggleRequest {
            fn from(value: super::ToggleRequest) -> Self {
                Self {
                    enabled: Ok(value.enabled),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TotpCodeRequest {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TotpCodeRequest {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                }
            }
        }
        impl TotpCodeRequest {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TotpCodeRequest> for super::TotpCodeRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TotpCodeRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { code: value.code? })
            }
        }
        impl ::std::convert::From<super::TotpCodeRequest> for TotpCodeRequest {
            fn from(value: super::TotpCodeRequest) -> Self {
                Self {
                    code: Ok(value.code),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TotpDisableRequest {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
            password: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TotpDisableRequest {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                    password: Err("no value supplied for password".to_string()),
                }
            }
        }
        impl TotpDisableRequest {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {e}"));
                self
            }
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TotpDisableRequest> for super::TotpDisableRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TotpDisableRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    password: value.password?,
                })
            }
        }
        impl ::std::convert::From<super::TotpDisableRequest> for TotpDisableRequest {
            fn from(value: super::TotpDisableRequest) -> Self {
                Self {
                    code: Ok(value.code),
                    password: Ok(value.password),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TotpEnableResponse {
            backup_codes: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TotpEnableResponse {
            fn default() -> Self {
                Self {
                    backup_codes: Err("no value supplied for backup_codes".to_string()),
                }
            }
        }
        impl TotpEnableResponse {
            pub fn backup_codes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.backup_codes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for backup_codes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TotpEnableResponse> for super::TotpEnableResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TotpEnableResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    backup_codes: value.backup_codes?,
                })
            }
        }
        impl ::std::convert::From<super::TotpEnableResponse> for TotpEnableResponse {
            fn from(value: super::TotpEnableResponse) -> Self {
                Self {
                    backup_codes: Ok(value.backup_codes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TotpSetupResponse {
            qr_code_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            secret: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TotpSetupResponse {
            fn default() -> Self {
                Self {
                    qr_code_url: Err("no value supplied for qr_code_url".to_string()),
                    secret: Err("no value supplied for secret".to_string()),
                }
            }
        }
        impl TotpSetupResponse {
            pub fn qr_code_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.qr_code_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for qr_code_url: {e}"));
                self
            }
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TotpSetupResponse> for super::TotpSetupResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TotpSetupResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    qr_code_url: value.qr_code_url?,
                    secret: value.secret?,
                })
            }
        }
        impl ::std::convert::From<super::TotpSetupResponse> for TotpSetupResponse {
            fn from(value: super::TotpSetupResponse) -> Self {
                Self {
                    qr_code_url: Ok(value.qr_code_url),
                    secret: Ok(value.secret),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TotpVerifyRequest {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
            totp_token: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TotpVerifyRequest {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                    totp_token: Err("no value supplied for totp_token".to_string()),
                }
            }
        }
        impl TotpVerifyRequest {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {e}"));
                self
            }
            pub fn totp_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.totp_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for totp_token: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TotpVerifyRequest> for super::TotpVerifyRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TotpVerifyRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    totp_token: value.totp_token?,
                })
            }
        }
        impl ::std::convert::From<super::TotpVerifyRequest> for TotpVerifyRequest {
            fn from(value: super::TotpVerifyRequest) -> Self {
                Self {
                    code: Ok(value.code),
                    totp_token: Ok(value.totp_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransferSessionResponse {
            artifact_checksum: ::std::result::Result<::std::string::String, ::std::string::String>,
            artifact_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            checksum_algo: ::std::result::Result<::std::string::String, ::std::string::String>,
            chunk_size: ::std::result::Result<i32, ::std::string::String>,
            completed_chunks: ::std::result::Result<i32, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            requesting_peer_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            total_chunks: ::std::result::Result<i32, ::std::string::String>,
            total_size: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for TransferSessionResponse {
            fn default() -> Self {
                Self {
                    artifact_checksum: Err("no value supplied for artifact_checksum".to_string()),
                    artifact_id: Err("no value supplied for artifact_id".to_string()),
                    checksum_algo: Err("no value supplied for checksum_algo".to_string()),
                    chunk_size: Err("no value supplied for chunk_size".to_string()),
                    completed_chunks: Err("no value supplied for completed_chunks".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    requesting_peer_id: Err("no value supplied for requesting_peer_id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    total_chunks: Err("no value supplied for total_chunks".to_string()),
                    total_size: Err("no value supplied for total_size".to_string()),
                }
            }
        }
        impl TransferSessionResponse {
            pub fn artifact_checksum<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_checksum = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_checksum: {e}")
                });
                self
            }
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn checksum_algo<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.checksum_algo = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for checksum_algo: {e}"));
                self
            }
            pub fn chunk_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.chunk_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunk_size: {e}"));
                self
            }
            pub fn completed_chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.completed_chunks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for completed_chunks: {e}")
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn requesting_peer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.requesting_peer_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for requesting_peer_id: {e}")
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn total_chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_chunks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_chunks: {e}"));
                self
            }
            pub fn total_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_size: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TransferSessionResponse> for super::TransferSessionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransferSessionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_checksum: value.artifact_checksum?,
                    artifact_id: value.artifact_id?,
                    checksum_algo: value.checksum_algo?,
                    chunk_size: value.chunk_size?,
                    completed_chunks: value.completed_chunks?,
                    id: value.id?,
                    requesting_peer_id: value.requesting_peer_id?,
                    status: value.status?,
                    total_chunks: value.total_chunks?,
                    total_size: value.total_size?,
                })
            }
        }
        impl ::std::convert::From<super::TransferSessionResponse> for TransferSessionResponse {
            fn from(value: super::TransferSessionResponse) -> Self {
                Self {
                    artifact_checksum: Ok(value.artifact_checksum),
                    artifact_id: Ok(value.artifact_id),
                    checksum_algo: Ok(value.checksum_algo),
                    chunk_size: Ok(value.chunk_size),
                    completed_chunks: Ok(value.completed_chunks),
                    id: Ok(value.id),
                    requesting_peer_id: Ok(value.requesting_peer_id),
                    status: Ok(value.status),
                    total_chunks: Ok(value.total_chunks),
                    total_size: Ok(value.total_size),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TreeNodeResponse {
            children_count:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            created_at: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            has_children: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            size_bytes: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TreeNodeResponse {
            fn default() -> Self {
                Self {
                    children_count: Ok(Default::default()),
                    created_at: Ok(Default::default()),
                    has_children: Err("no value supplied for has_children".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    repository_key: Ok(Default::default()),
                    size_bytes: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl TreeNodeResponse {
            pub fn children_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.children_count = value.try_into().map_err(|e| {
                    format!("error converting supplied value for children_count: {e}")
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn has_children<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.has_children = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for has_children: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {e}"));
                self
            }
            pub fn repository_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for repository_key: {e}")
                });
                self
            }
            pub fn size_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.size_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size_bytes: {e}"));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TreeNodeResponse> for super::TreeNodeResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TreeNodeResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    children_count: value.children_count?,
                    created_at: value.created_at?,
                    has_children: value.has_children?,
                    id: value.id?,
                    name: value.name?,
                    path: value.path?,
                    repository_key: value.repository_key?,
                    size_bytes: value.size_bytes?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::TreeNodeResponse> for TreeNodeResponse {
            fn from(value: super::TreeNodeResponse) -> Self {
                Self {
                    children_count: Ok(value.children_count),
                    created_at: Ok(value.created_at),
                    has_children: Ok(value.has_children),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    path: Ok(value.path),
                    repository_key: Ok(value.repository_key),
                    size_bytes: Ok(value.size_bytes),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TreeResponse {
            nodes: ::std::result::Result<
                ::std::vec::Vec<super::TreeNodeResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TreeResponse {
            fn default() -> Self {
                Self {
                    nodes: Err("no value supplied for nodes".to_string()),
                }
            }
        }
        impl TreeResponse {
            pub fn nodes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TreeNodeResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.nodes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nodes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TreeResponse> for super::TreeResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TreeResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    nodes: value.nodes?,
                })
            }
        }
        impl ::std::convert::From<super::TreeResponse> for TreeResponse {
            fn from(value: super::TreeResponse) -> Self {
                Self {
                    nodes: Ok(value.nodes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TriggerChecksRequest {
            artifact_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for TriggerChecksRequest {
            fn default() -> Self {
                Self {
                    artifact_id: Ok(Default::default()),
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl TriggerChecksRequest {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TriggerChecksRequest> for super::TriggerChecksRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TriggerChecksRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::TriggerChecksRequest> for TriggerChecksRequest {
            fn from(value: super::TriggerChecksRequest) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TriggerChecksResponse {
            artifacts_queued: ::std::result::Result<i32, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TriggerChecksResponse {
            fn default() -> Self {
                Self {
                    artifacts_queued: Err("no value supplied for artifacts_queued".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl TriggerChecksResponse {
            pub fn artifacts_queued<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_queued = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_queued: {e}")
                });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TriggerChecksResponse> for super::TriggerChecksResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TriggerChecksResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_queued: value.artifacts_queued?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::TriggerChecksResponse> for TriggerChecksResponse {
            fn from(value: super::TriggerChecksResponse) -> Self {
                Self {
                    artifacts_queued: Ok(value.artifacts_queued),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TriggerScanRequest {
            artifact_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for TriggerScanRequest {
            fn default() -> Self {
                Self {
                    artifact_id: Ok(Default::default()),
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl TriggerScanRequest {
            pub fn artifact_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for artifact_id: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TriggerScanRequest> for super::TriggerScanRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TriggerScanRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_id: value.artifact_id?,
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::TriggerScanRequest> for TriggerScanRequest {
            fn from(value: super::TriggerScanRequest) -> Self {
                Self {
                    artifact_id: Ok(value.artifact_id),
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TriggerScanResponse {
            artifacts_queued: ::std::result::Result<i32, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TriggerScanResponse {
            fn default() -> Self {
                Self {
                    artifacts_queued: Err("no value supplied for artifacts_queued".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl TriggerScanResponse {
            pub fn artifacts_queued<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.artifacts_queued = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifacts_queued: {e}")
                });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<TriggerScanResponse> for super::TriggerScanResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TriggerScanResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifacts_queued: value.artifacts_queued?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::TriggerScanResponse> for TriggerScanResponse {
            fn from(value: super::TriggerScanResponse) -> Self {
                Self {
                    artifacts_queued: Ok(value.artifacts_queued),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UninstallQuery {
            force: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for UninstallQuery {
            fn default() -> Self {
                Self {
                    force: Ok(Default::default()),
                }
            }
        }
        impl UninstallQuery {
            pub fn force<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.force = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for force: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UninstallQuery> for super::UninstallQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UninstallQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    force: value.force?,
                })
            }
        }
        impl ::std::convert::From<super::UninstallQuery> for UninstallQuery {
            fn from(value: super::UninstallQuery) -> Self {
                Self {
                    force: Ok(value.force),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateAnalysisBody {
            component_uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            details: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            justification: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            project_uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
            state: ::std::result::Result<::std::string::String, ::std::string::String>,
            suppressed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            vulnerability_uuid: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateAnalysisBody {
            fn default() -> Self {
                Self {
                    component_uuid: Err("no value supplied for component_uuid".to_string()),
                    details: Ok(Default::default()),
                    justification: Ok(Default::default()),
                    project_uuid: Err("no value supplied for project_uuid".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    suppressed: Ok(Default::default()),
                    vulnerability_uuid: Err("no value supplied for vulnerability_uuid".to_string()),
                }
            }
        }
        impl UpdateAnalysisBody {
            pub fn component_uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.component_uuid = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_uuid: {e}")
                });
                self
            }
            pub fn details<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.details = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for details: {e}"));
                self
            }
            pub fn justification<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.justification = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for justification: {e}"));
                self
            }
            pub fn project_uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.project_uuid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_uuid: {e}"));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {e}"));
                self
            }
            pub fn suppressed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.suppressed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for suppressed: {e}"));
                self
            }
            pub fn vulnerability_uuid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.vulnerability_uuid = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vulnerability_uuid: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateAnalysisBody> for super::UpdateAnalysisBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateAnalysisBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    component_uuid: value.component_uuid?,
                    details: value.details?,
                    justification: value.justification?,
                    project_uuid: value.project_uuid?,
                    state: value.state?,
                    suppressed: value.suppressed?,
                    vulnerability_uuid: value.vulnerability_uuid?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateAnalysisBody> for UpdateAnalysisBody {
            fn from(value: super::UpdateAnalysisBody) -> Self {
                Self {
                    component_uuid: Ok(value.component_uuid),
                    details: Ok(value.details),
                    justification: Ok(value.justification),
                    project_uuid: Ok(value.project_uuid),
                    state: Ok(value.state),
                    suppressed: Ok(value.suppressed),
                    vulnerability_uuid: Ok(value.vulnerability_uuid),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateBuildRequest {
            finished_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateBuildRequest {
            fn default() -> Self {
                Self {
                    finished_at: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl UpdateBuildRequest {
            pub fn finished_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.finished_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for finished_at: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateBuildRequest> for super::UpdateBuildRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateBuildRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    finished_at: value.finished_at?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateBuildRequest> for UpdateBuildRequest {
            fn from(value: super::UpdateBuildRequest) -> Self {
                Self {
                    finished_at: Ok(value.finished_at),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateChunkAvailabilityBody {
            chunk_bitmap: ::std::result::Result<::std::vec::Vec<i32>, ::std::string::String>,
            total_chunks: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateChunkAvailabilityBody {
            fn default() -> Self {
                Self {
                    chunk_bitmap: Err("no value supplied for chunk_bitmap".to_string()),
                    total_chunks: Err("no value supplied for total_chunks".to_string()),
                }
            }
        }
        impl UpdateChunkAvailabilityBody {
            pub fn chunk_bitmap<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.chunk_bitmap = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunk_bitmap: {e}"));
                self
            }
            pub fn total_chunks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.total_chunks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_chunks: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateChunkAvailabilityBody> for super::UpdateChunkAvailabilityBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateChunkAvailabilityBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chunk_bitmap: value.chunk_bitmap?,
                    total_chunks: value.total_chunks?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateChunkAvailabilityBody> for UpdateChunkAvailabilityBody {
            fn from(value: super::UpdateChunkAvailabilityBody) -> Self {
                Self {
                    chunk_bitmap: Ok(value.chunk_bitmap),
                    total_chunks: Ok(value.total_chunks),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateCveStatusRequest {
            reason: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateCveStatusRequest {
            fn default() -> Self {
                Self {
                    reason: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl UpdateCveStatusRequest {
            pub fn reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.reason = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for reason: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateCveStatusRequest> for super::UpdateCveStatusRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateCveStatusRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    reason: value.reason?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateCveStatusRequest> for UpdateCveStatusRequest {
            fn from(value: super::UpdateCveStatusRequest) -> Self {
                Self {
                    reason: Ok(value.reason),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateGateRequest {
            action: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enforce_on_download:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            enforce_on_promotion:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            max_critical_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_high_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_medium_issues:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_health_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_metadata_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_quality_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_security_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            required_checks: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateGateRequest {
            fn default() -> Self {
                Self {
                    action: Ok(Default::default()),
                    description: Ok(Default::default()),
                    enforce_on_download: Ok(Default::default()),
                    enforce_on_promotion: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    max_critical_issues: Ok(Default::default()),
                    max_high_issues: Ok(Default::default()),
                    max_medium_issues: Ok(Default::default()),
                    min_health_score: Ok(Default::default()),
                    min_metadata_score: Ok(Default::default()),
                    min_quality_score: Ok(Default::default()),
                    min_security_score: Ok(Default::default()),
                    name: Ok(Default::default()),
                    required_checks: Ok(Default::default()),
                }
            }
        }
        impl UpdateGateRequest {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enforce_on_download<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_on_download = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enforce_on_download: {e}")
                });
                self
            }
            pub fn enforce_on_promotion<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_on_promotion = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enforce_on_promotion: {e}")
                });
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_critical_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_critical_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_critical_issues: {e}")
                });
                self
            }
            pub fn max_high_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_high_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_high_issues: {e}")
                });
                self
            }
            pub fn max_medium_issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_medium_issues = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_medium_issues: {e}")
                });
                self
            }
            pub fn min_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_health_score: {e}")
                });
                self
            }
            pub fn min_metadata_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_metadata_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_metadata_score: {e}")
                });
                self
            }
            pub fn min_quality_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_quality_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_quality_score: {e}")
                });
                self
            }
            pub fn min_security_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_security_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_security_score: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn required_checks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.required_checks = value.try_into().map_err(|e| {
                    format!("error converting supplied value for required_checks: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateGateRequest> for super::UpdateGateRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateGateRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    enforce_on_download: value.enforce_on_download?,
                    enforce_on_promotion: value.enforce_on_promotion?,
                    is_enabled: value.is_enabled?,
                    max_critical_issues: value.max_critical_issues?,
                    max_high_issues: value.max_high_issues?,
                    max_medium_issues: value.max_medium_issues?,
                    min_health_score: value.min_health_score?,
                    min_metadata_score: value.min_metadata_score?,
                    min_quality_score: value.min_quality_score?,
                    min_security_score: value.min_security_score?,
                    name: value.name?,
                    required_checks: value.required_checks?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateGateRequest> for UpdateGateRequest {
            fn from(value: super::UpdateGateRequest) -> Self {
                Self {
                    action: Ok(value.action),
                    description: Ok(value.description),
                    enforce_on_download: Ok(value.enforce_on_download),
                    enforce_on_promotion: Ok(value.enforce_on_promotion),
                    is_enabled: Ok(value.is_enabled),
                    max_critical_issues: Ok(value.max_critical_issues),
                    max_high_issues: Ok(value.max_high_issues),
                    max_medium_issues: Ok(value.max_medium_issues),
                    min_health_score: Ok(value.min_health_score),
                    min_metadata_score: Ok(value.min_metadata_score),
                    min_quality_score: Ok(value.min_quality_score),
                    min_security_score: Ok(value.min_security_score),
                    name: Ok(value.name),
                    required_checks: Ok(value.required_checks),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateLdapConfigRequest {
            admin_group_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bind_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bind_password: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            display_name_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            group_base_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            group_filter: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            groups_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            priority: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            server_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            use_starttls: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            user_base_dn: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            user_filter: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            username_attribute: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateLdapConfigRequest {
            fn default() -> Self {
                Self {
                    admin_group_dn: Ok(Default::default()),
                    bind_dn: Ok(Default::default()),
                    bind_password: Ok(Default::default()),
                    display_name_attribute: Ok(Default::default()),
                    email_attribute: Ok(Default::default()),
                    group_base_dn: Ok(Default::default()),
                    group_filter: Ok(Default::default()),
                    groups_attribute: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    name: Ok(Default::default()),
                    priority: Ok(Default::default()),
                    server_url: Ok(Default::default()),
                    use_starttls: Ok(Default::default()),
                    user_base_dn: Ok(Default::default()),
                    user_filter: Ok(Default::default()),
                    username_attribute: Ok(Default::default()),
                }
            }
        }
        impl UpdateLdapConfigRequest {
            pub fn admin_group_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group_dn = value.try_into().map_err(|e| {
                    format!("error converting supplied value for admin_group_dn: {e}")
                });
                self
            }
            pub fn bind_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bind_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bind_dn: {e}"));
                self
            }
            pub fn bind_password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bind_password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bind_password: {e}"));
                self
            }
            pub fn display_name_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name_attribute: {e}")
                });
                self
            }
            pub fn email_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for email_attribute: {e}")
                });
                self
            }
            pub fn group_base_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_base_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group_base_dn: {e}"));
                self
            }
            pub fn group_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for group_filter: {e}"));
                self
            }
            pub fn groups_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.groups_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for groups_attribute: {e}")
                });
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn server_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.server_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for server_url: {e}"));
                self
            }
            pub fn use_starttls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.use_starttls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for use_starttls: {e}"));
                self
            }
            pub fn user_base_dn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.user_base_dn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_base_dn: {e}"));
                self
            }
            pub fn user_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.user_filter = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_filter: {e}"));
                self
            }
            pub fn username_attribute<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username_attribute = value.try_into().map_err(|e| {
                    format!("error converting supplied value for username_attribute: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateLdapConfigRequest> for super::UpdateLdapConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateLdapConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group_dn: value.admin_group_dn?,
                    bind_dn: value.bind_dn?,
                    bind_password: value.bind_password?,
                    display_name_attribute: value.display_name_attribute?,
                    email_attribute: value.email_attribute?,
                    group_base_dn: value.group_base_dn?,
                    group_filter: value.group_filter?,
                    groups_attribute: value.groups_attribute?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    priority: value.priority?,
                    server_url: value.server_url?,
                    use_starttls: value.use_starttls?,
                    user_base_dn: value.user_base_dn?,
                    user_filter: value.user_filter?,
                    username_attribute: value.username_attribute?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateLdapConfigRequest> for UpdateLdapConfigRequest {
            fn from(value: super::UpdateLdapConfigRequest) -> Self {
                Self {
                    admin_group_dn: Ok(value.admin_group_dn),
                    bind_dn: Ok(value.bind_dn),
                    bind_password: Ok(value.bind_password),
                    display_name_attribute: Ok(value.display_name_attribute),
                    email_attribute: Ok(value.email_attribute),
                    group_base_dn: Ok(value.group_base_dn),
                    group_filter: Ok(value.group_filter),
                    groups_attribute: Ok(value.groups_attribute),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    server_url: Ok(value.server_url),
                    use_starttls: Ok(value.use_starttls),
                    user_base_dn: Ok(value.user_base_dn),
                    user_filter: Ok(value.user_filter),
                    username_attribute: Ok(value.username_attribute),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateOidcConfigRequest {
            attribute_mapping: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            auto_create_users:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            client_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            client_secret: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            issuer_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            scopes: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateOidcConfigRequest {
            fn default() -> Self {
                Self {
                    attribute_mapping: Ok(Default::default()),
                    auto_create_users: Ok(Default::default()),
                    client_id: Ok(Default::default()),
                    client_secret: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    issuer_url: Ok(Default::default()),
                    name: Ok(Default::default()),
                    scopes: Ok(Default::default()),
                }
            }
        }
        impl UpdateOidcConfigRequest {
            pub fn attribute_mapping<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.attribute_mapping = value.try_into().map_err(|e| {
                    format!("error converting supplied value for attribute_mapping: {e}")
                });
                self
            }
            pub fn auto_create_users<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_create_users = value.try_into().map_err(|e| {
                    format!("error converting supplied value for auto_create_users: {e}")
                });
                self
            }
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {e}"));
                self
            }
            pub fn client_secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.client_secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_secret: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn issuer_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.issuer_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issuer_url: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn scopes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.scopes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scopes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateOidcConfigRequest> for super::UpdateOidcConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateOidcConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    attribute_mapping: value.attribute_mapping?,
                    auto_create_users: value.auto_create_users?,
                    client_id: value.client_id?,
                    client_secret: value.client_secret?,
                    is_enabled: value.is_enabled?,
                    issuer_url: value.issuer_url?,
                    name: value.name?,
                    scopes: value.scopes?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateOidcConfigRequest> for UpdateOidcConfigRequest {
            fn from(value: super::UpdateOidcConfigRequest) -> Self {
                Self {
                    attribute_mapping: Ok(value.attribute_mapping),
                    auto_create_users: Ok(value.auto_create_users),
                    client_id: Ok(value.client_id),
                    client_secret: Ok(value.client_secret),
                    is_enabled: Ok(value.is_enabled),
                    issuer_url: Ok(value.issuer_url),
                    name: Ok(value.name),
                    scopes: Ok(value.scopes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdatePluginConfigRequest {
            config: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdatePluginConfigRequest {
            fn default() -> Self {
                Self {
                    config: Err("no value supplied for config".to_string()),
                }
            }
        }
        impl UpdatePluginConfigRequest {
            pub fn config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for config: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdatePluginConfigRequest> for super::UpdatePluginConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdatePluginConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    config: value.config?,
                })
            }
        }
        impl ::std::convert::From<super::UpdatePluginConfigRequest> for UpdatePluginConfigRequest {
            fn from(value: super::UpdatePluginConfigRequest) -> Self {
                Self {
                    config: Ok(value.config),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdatePolicyRequest {
            block_on_fail: ::std::result::Result<bool, ::std::string::String>,
            block_unscanned: ::std::result::Result<bool, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            max_artifact_age_days:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_severity: ::std::result::Result<::std::string::String, ::std::string::String>,
            min_staging_hours:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            require_signature:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for UpdatePolicyRequest {
            fn default() -> Self {
                Self {
                    block_on_fail: Err("no value supplied for block_on_fail".to_string()),
                    block_unscanned: Err("no value supplied for block_unscanned".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    max_artifact_age_days: Ok(Default::default()),
                    max_severity: Err("no value supplied for max_severity".to_string()),
                    min_staging_hours: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    require_signature: Ok(Default::default()),
                }
            }
        }
        impl UpdatePolicyRequest {
            pub fn block_on_fail<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_on_fail = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_on_fail: {e}"));
                self
            }
            pub fn block_unscanned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_unscanned = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_unscanned: {e}")
                });
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_artifact_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_artifact_age_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_artifact_age_days: {e}")
                });
                self
            }
            pub fn max_severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.max_severity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max_severity: {e}"));
                self
            }
            pub fn min_staging_hours<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_staging_hours = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_staging_hours: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn require_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signature: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpdatePolicyRequest> for super::UpdatePolicyRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdatePolicyRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_on_fail: value.block_on_fail?,
                    block_unscanned: value.block_unscanned?,
                    is_enabled: value.is_enabled?,
                    max_artifact_age_days: value.max_artifact_age_days?,
                    max_severity: value.max_severity?,
                    min_staging_hours: value.min_staging_hours?,
                    name: value.name?,
                    require_signature: value.require_signature?,
                })
            }
        }
        impl ::std::convert::From<super::UpdatePolicyRequest> for UpdatePolicyRequest {
            fn from(value: super::UpdatePolicyRequest) -> Self {
                Self {
                    block_on_fail: Ok(value.block_on_fail),
                    block_unscanned: Ok(value.block_unscanned),
                    is_enabled: Ok(value.is_enabled),
                    max_artifact_age_days: Ok(value.max_artifact_age_days),
                    max_severity: Ok(value.max_severity),
                    min_staging_hours: Ok(value.min_staging_hours),
                    name: Ok(value.name),
                    require_signature: Ok(value.require_signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateRepositoryRequest {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_public: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            quota_bytes: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateRepositoryRequest {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    is_public: Ok(Default::default()),
                    key: Ok(Default::default()),
                    name: Ok(Default::default()),
                    quota_bytes: Ok(Default::default()),
                }
            }
        }
        impl UpdateRepositoryRequest {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn is_public<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_public = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_public: {e}"));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn quota_bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.quota_bytes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for quota_bytes: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateRepositoryRequest> for super::UpdateRepositoryRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateRepositoryRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    is_public: value.is_public?,
                    key: value.key?,
                    name: value.name?,
                    quota_bytes: value.quota_bytes?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateRepositoryRequest> for UpdateRepositoryRequest {
            fn from(value: super::UpdateRepositoryRequest) -> Self {
                Self {
                    description: Ok(value.description),
                    is_public: Ok(value.is_public),
                    key: Ok(value.key),
                    name: Ok(value.name),
                    quota_bytes: Ok(value.quota_bytes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateRuleRequest {
            allowed_licenses: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
            auto_promote: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            max_artifact_age_days:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            max_cve_severity: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            min_health_score:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            min_staging_hours:
                ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            require_signature:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateRuleRequest {
            fn default() -> Self {
                Self {
                    allowed_licenses: Ok(Default::default()),
                    auto_promote: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    max_artifact_age_days: Ok(Default::default()),
                    max_cve_severity: Ok(Default::default()),
                    min_health_score: Ok(Default::default()),
                    min_staging_hours: Ok(Default::default()),
                    name: Ok(Default::default()),
                    require_signature: Ok(Default::default()),
                }
            }
        }
        impl UpdateRuleRequest {
            pub fn allowed_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_licenses: {e}")
                });
                self
            }
            pub fn auto_promote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_promote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for auto_promote: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn max_artifact_age_days<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_artifact_age_days = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_artifact_age_days: {e}")
                });
                self
            }
            pub fn max_cve_severity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.max_cve_severity = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_cve_severity: {e}")
                });
                self
            }
            pub fn min_health_score<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_health_score = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_health_score: {e}")
                });
                self
            }
            pub fn min_staging_hours<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_staging_hours = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_staging_hours: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn require_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signature = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signature: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateRuleRequest> for super::UpdateRuleRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateRuleRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowed_licenses: value.allowed_licenses?,
                    auto_promote: value.auto_promote?,
                    is_enabled: value.is_enabled?,
                    max_artifact_age_days: value.max_artifact_age_days?,
                    max_cve_severity: value.max_cve_severity?,
                    min_health_score: value.min_health_score?,
                    min_staging_hours: value.min_staging_hours?,
                    name: value.name?,
                    require_signature: value.require_signature?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateRuleRequest> for UpdateRuleRequest {
            fn from(value: super::UpdateRuleRequest) -> Self {
                Self {
                    allowed_licenses: Ok(value.allowed_licenses),
                    auto_promote: Ok(value.auto_promote),
                    is_enabled: Ok(value.is_enabled),
                    max_artifact_age_days: Ok(value.max_artifact_age_days),
                    max_cve_severity: Ok(value.max_cve_severity),
                    min_health_score: Ok(value.min_health_score),
                    min_staging_hours: Ok(value.min_staging_hours),
                    name: Ok(value.name),
                    require_signature: Ok(value.require_signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateSamlConfigRequest {
            admin_group: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            attribute_mapping: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            certificate: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            entity_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name_id_format: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            require_signed_assertions:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            sign_requests:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            slo_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sp_entity_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sso_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateSamlConfigRequest {
            fn default() -> Self {
                Self {
                    admin_group: Ok(Default::default()),
                    attribute_mapping: Ok(Default::default()),
                    certificate: Ok(Default::default()),
                    entity_id: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    name: Ok(Default::default()),
                    name_id_format: Ok(Default::default()),
                    require_signed_assertions: Ok(Default::default()),
                    sign_requests: Ok(Default::default()),
                    slo_url: Ok(Default::default()),
                    sp_entity_id: Ok(Default::default()),
                    sso_url: Ok(Default::default()),
                }
            }
        }
        impl UpdateSamlConfigRequest {
            pub fn admin_group<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for admin_group: {e}"));
                self
            }
            pub fn attribute_mapping<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.attribute_mapping = value.try_into().map_err(|e| {
                    format!("error converting supplied value for attribute_mapping: {e}")
                });
                self
            }
            pub fn certificate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.certificate = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for certificate: {e}"));
                self
            }
            pub fn entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.entity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for entity_id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn name_id_format<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name_id_format = value.try_into().map_err(|e| {
                    format!("error converting supplied value for name_id_format: {e}")
                });
                self
            }
            pub fn require_signed_assertions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signed_assertions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signed_assertions: {e}")
                });
                self
            }
            pub fn sign_requests<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_requests = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_requests: {e}"));
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {e}"));
                self
            }
            pub fn sp_entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sp_entity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sp_entity_id: {e}"));
                self
            }
            pub fn sso_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.sso_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sso_url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateSamlConfigRequest> for super::UpdateSamlConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateSamlConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group: value.admin_group?,
                    attribute_mapping: value.attribute_mapping?,
                    certificate: value.certificate?,
                    entity_id: value.entity_id?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    name_id_format: value.name_id_format?,
                    require_signed_assertions: value.require_signed_assertions?,
                    sign_requests: value.sign_requests?,
                    slo_url: value.slo_url?,
                    sp_entity_id: value.sp_entity_id?,
                    sso_url: value.sso_url?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateSamlConfigRequest> for UpdateSamlConfigRequest {
            fn from(value: super::UpdateSamlConfigRequest) -> Self {
                Self {
                    admin_group: Ok(value.admin_group),
                    attribute_mapping: Ok(value.attribute_mapping),
                    certificate: Ok(value.certificate),
                    entity_id: Ok(value.entity_id),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    name_id_format: Ok(value.name_id_format),
                    require_signed_assertions: Ok(value.require_signed_assertions),
                    sign_requests: Ok(value.sign_requests),
                    slo_url: Ok(value.slo_url),
                    sp_entity_id: Ok(value.sp_entity_id),
                    sso_url: Ok(value.sso_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateSigningConfigPayload {
            require_signatures:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            sign_metadata:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            sign_packages:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            signing_key_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateSigningConfigPayload {
            fn default() -> Self {
                Self {
                    require_signatures: Ok(Default::default()),
                    sign_metadata: Ok(Default::default()),
                    sign_packages: Ok(Default::default()),
                    signing_key_id: Ok(Default::default()),
                }
            }
        }
        impl UpdateSigningConfigPayload {
            pub fn require_signatures<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.require_signatures = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_signatures: {e}")
                });
                self
            }
            pub fn sign_metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_metadata: {e}"));
                self
            }
            pub fn sign_packages<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sign_packages = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sign_packages: {e}"));
                self
            }
            pub fn signing_key_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.signing_key_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signing_key_id: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateSigningConfigPayload> for super::UpdateSigningConfigPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateSigningConfigPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    require_signatures: value.require_signatures?,
                    sign_metadata: value.sign_metadata?,
                    sign_packages: value.sign_packages?,
                    signing_key_id: value.signing_key_id?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateSigningConfigPayload> for UpdateSigningConfigPayload {
            fn from(value: super::UpdateSigningConfigPayload) -> Self {
                Self {
                    require_signatures: Ok(value.require_signatures),
                    sign_metadata: Ok(value.sign_metadata),
                    sign_packages: Ok(value.sign_packages),
                    signing_key_id: Ok(value.signing_key_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateSyncPolicyPayload {
            artifact_filter: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            peer_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            precedence: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            priority: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            replication_mode: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            repo_selector: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateSyncPolicyPayload {
            fn default() -> Self {
                Self {
                    artifact_filter: Ok(Default::default()),
                    description: Ok(Default::default()),
                    enabled: Ok(Default::default()),
                    name: Ok(Default::default()),
                    peer_selector: Ok(Default::default()),
                    precedence: Ok(Default::default()),
                    priority: Ok(Default::default()),
                    replication_mode: Ok(Default::default()),
                    repo_selector: Ok(Default::default()),
                }
            }
        }
        impl UpdateSyncPolicyPayload {
            pub fn artifact_filter<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.artifact_filter = value.try_into().map_err(|e| {
                    format!("error converting supplied value for artifact_filter: {e}")
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn peer_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.peer_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer_selector: {e}"));
                self
            }
            pub fn precedence<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.precedence = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for precedence: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
            pub fn replication_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.replication_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for replication_mode: {e}")
                });
                self
            }
            pub fn repo_selector<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.repo_selector = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repo_selector: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateSyncPolicyPayload> for super::UpdateSyncPolicyPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateSyncPolicyPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    artifact_filter: value.artifact_filter?,
                    description: value.description?,
                    enabled: value.enabled?,
                    name: value.name?,
                    peer_selector: value.peer_selector?,
                    precedence: value.precedence?,
                    priority: value.priority?,
                    replication_mode: value.replication_mode?,
                    repo_selector: value.repo_selector?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateSyncPolicyPayload> for UpdateSyncPolicyPayload {
            fn from(value: super::UpdateSyncPolicyPayload) -> Self {
                Self {
                    artifact_filter: Ok(value.artifact_filter),
                    description: Ok(value.description),
                    enabled: Ok(value.enabled),
                    name: Ok(value.name),
                    peer_selector: Ok(value.peer_selector),
                    precedence: Ok(value.precedence),
                    priority: Ok(value.priority),
                    replication_mode: Ok(value.replication_mode),
                    repo_selector: Ok(value.repo_selector),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateUserRequest {
            display_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_active: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            is_admin: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for UpdateUserRequest {
            fn default() -> Self {
                Self {
                    display_name: Ok(Default::default()),
                    email: Ok(Default::default()),
                    is_active: Ok(Default::default()),
                    is_admin: Ok(Default::default()),
                }
            }
        }
        impl UpdateUserRequest {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {e}"));
                self
            }
            pub fn is_active<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_active = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_active: {e}"));
                self
            }
            pub fn is_admin<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_admin = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_admin: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateUserRequest> for super::UpdateUserRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateUserRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    email: value.email?,
                    is_active: value.is_active?,
                    is_admin: value.is_admin?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateUserRequest> for UpdateUserRequest {
            fn from(value: super::UpdateUserRequest) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    email: Ok(value.email),
                    is_active: Ok(value.is_active),
                    is_admin: Ok(value.is_admin),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateVirtualMembersRequest {
            members: ::std::result::Result<
                ::std::vec::Vec<super::VirtualMemberPriority>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateVirtualMembersRequest {
            fn default() -> Self {
                Self {
                    members: Err("no value supplied for members".to_string()),
                }
            }
        }
        impl UpdateVirtualMembersRequest {
            pub fn members<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VirtualMemberPriority>>,
                T::Error: ::std::fmt::Display,
            {
                self.members = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for members: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateVirtualMembersRequest> for super::UpdateVirtualMembersRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateVirtualMembersRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    members: value.members?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateVirtualMembersRequest> for UpdateVirtualMembersRequest {
            fn from(value: super::UpdateVirtualMembersRequest) -> Self {
                Self {
                    members: Ok(value.members),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpsertLicensePolicyRequest {
            action: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            allow_unknown:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            allowed_licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            denied_licenses: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            is_enabled: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for UpsertLicensePolicyRequest {
            fn default() -> Self {
                Self {
                    action: Ok(Default::default()),
                    allow_unknown: Ok(Default::default()),
                    allowed_licenses: Err("no value supplied for allowed_licenses".to_string()),
                    denied_licenses: Err("no value supplied for denied_licenses".to_string()),
                    description: Ok(Default::default()),
                    is_enabled: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                }
            }
        }
        impl UpsertLicensePolicyRequest {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {e}"));
                self
            }
            pub fn allow_unknown<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.allow_unknown = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allow_unknown: {e}"));
                self
            }
            pub fn allowed_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_licenses: {e}")
                });
                self
            }
            pub fn denied_licenses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.denied_licenses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for denied_licenses: {e}")
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UpsertLicensePolicyRequest> for super::UpsertLicensePolicyRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpsertLicensePolicyRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    allow_unknown: value.allow_unknown?,
                    allowed_licenses: value.allowed_licenses?,
                    denied_licenses: value.denied_licenses?,
                    description: value.description?,
                    is_enabled: value.is_enabled?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                })
            }
        }
        impl ::std::convert::From<super::UpsertLicensePolicyRequest> for UpsertLicensePolicyRequest {
            fn from(value: super::UpsertLicensePolicyRequest) -> Self {
                Self {
                    action: Ok(value.action),
                    allow_unknown: Ok(value.allow_unknown),
                    allowed_licenses: Ok(value.allowed_licenses),
                    denied_licenses: Ok(value.denied_licenses),
                    description: Ok(value.description),
                    is_enabled: Ok(value.is_enabled),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpsertScanConfigRequest {
            block_on_policy_violation: ::std::result::Result<bool, ::std::string::String>,
            scan_enabled: ::std::result::Result<bool, ::std::string::String>,
            scan_on_proxy: ::std::result::Result<bool, ::std::string::String>,
            scan_on_upload: ::std::result::Result<bool, ::std::string::String>,
            severity_threshold: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UpsertScanConfigRequest {
            fn default() -> Self {
                Self {
                    block_on_policy_violation: Err(
                        "no value supplied for block_on_policy_violation".to_string(),
                    ),
                    scan_enabled: Err("no value supplied for scan_enabled".to_string()),
                    scan_on_proxy: Err("no value supplied for scan_on_proxy".to_string()),
                    scan_on_upload: Err("no value supplied for scan_on_upload".to_string()),
                    severity_threshold: Err("no value supplied for severity_threshold".to_string()),
                }
            }
        }
        impl UpsertScanConfigRequest {
            pub fn block_on_policy_violation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.block_on_policy_violation = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_on_policy_violation: {e}")
                });
                self
            }
            pub fn scan_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scan_enabled: {e}"));
                self
            }
            pub fn scan_on_proxy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_on_proxy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scan_on_proxy: {e}"));
                self
            }
            pub fn scan_on_upload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.scan_on_upload = value.try_into().map_err(|e| {
                    format!("error converting supplied value for scan_on_upload: {e}")
                });
                self
            }
            pub fn severity_threshold<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.severity_threshold = value.try_into().map_err(|e| {
                    format!("error converting supplied value for severity_threshold: {e}")
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UpsertScanConfigRequest> for super::UpsertScanConfigRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpsertScanConfigRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_on_policy_violation: value.block_on_policy_violation?,
                    scan_enabled: value.scan_enabled?,
                    scan_on_proxy: value.scan_on_proxy?,
                    scan_on_upload: value.scan_on_upload?,
                    severity_threshold: value.severity_threshold?,
                })
            }
        }
        impl ::std::convert::From<super::UpsertScanConfigRequest> for UpsertScanConfigRequest {
            fn from(value: super::UpsertScanConfigRequest) -> Self {
                Self {
                    block_on_policy_violation: Ok(value.block_on_policy_violation),
                    scan_enabled: Ok(value.scan_enabled),
                    scan_on_proxy: Ok(value.scan_on_proxy),
                    scan_on_upload: Ok(value.scan_on_upload),
                    severity_threshold: Ok(value.severity_threshold),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UserListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::AdminUserResponse>,
                ::std::string::String,
            >,
            pagination: ::std::result::Result<super::Pagination, ::std::string::String>,
        }
        impl ::std::default::Default for UserListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    pagination: Err("no value supplied for pagination".to_string()),
                }
            }
        }
        impl UserListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AdminUserResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn pagination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Pagination>,
                T::Error: ::std::fmt::Display,
            {
                self.pagination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pagination: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UserListResponse> for super::UserListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    pagination: value.pagination?,
                })
            }
        }
        impl ::std::convert::From<super::UserListResponse> for UserListResponse {
            fn from(value: super::UserListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    pagination: Ok(value.pagination),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UserResponse {
            display_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_admin: ::std::result::Result<bool, ::std::string::String>,
            totp_enabled: ::std::result::Result<bool, ::std::string::String>,
            username: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UserResponse {
            fn default() -> Self {
                Self {
                    display_name: Ok(Default::default()),
                    email: Err("no value supplied for email".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_admin: Err("no value supplied for is_admin".to_string()),
                    totp_enabled: Err("no value supplied for totp_enabled".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl UserResponse {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_admin<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_admin = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_admin: {e}"));
                self
            }
            pub fn totp_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.totp_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for totp_enabled: {e}"));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<UserResponse> for super::UserResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    email: value.email?,
                    id: value.id?,
                    is_admin: value.is_admin?,
                    totp_enabled: value.totp_enabled?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::UserResponse> for UserResponse {
            fn from(value: super::UserResponse) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    email: Ok(value.email),
                    id: Ok(value.id),
                    is_admin: Ok(value.is_admin),
                    totp_enabled: Ok(value.totp_enabled),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct VirtualMemberPriority {
            member_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for VirtualMemberPriority {
            fn default() -> Self {
                Self {
                    member_key: Err("no value supplied for member_key".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                }
            }
        }
        impl VirtualMemberPriority {
            pub fn member_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.member_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for member_key: {e}"));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<VirtualMemberPriority> for super::VirtualMemberPriority {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VirtualMemberPriority,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    member_key: value.member_key?,
                    priority: value.priority?,
                })
            }
        }
        impl ::std::convert::From<super::VirtualMemberPriority> for VirtualMemberPriority {
            fn from(value: super::VirtualMemberPriority) -> Self {
                Self {
                    member_key: Ok(value.member_key),
                    priority: Ok(value.priority),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct VirtualMemberResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            member_repo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            member_repo_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            member_repo_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            member_repo_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            priority: ::std::result::Result<i32, ::std::string::String>,
        }
        impl ::std::default::Default for VirtualMemberResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    member_repo_id: Err("no value supplied for member_repo_id".to_string()),
                    member_repo_key: Err("no value supplied for member_repo_key".to_string()),
                    member_repo_name: Err("no value supplied for member_repo_name".to_string()),
                    member_repo_type: Err("no value supplied for member_repo_type".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                }
            }
        }
        impl VirtualMemberResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn member_repo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.member_repo_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for member_repo_id: {e}")
                });
                self
            }
            pub fn member_repo_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.member_repo_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for member_repo_key: {e}")
                });
                self
            }
            pub fn member_repo_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.member_repo_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for member_repo_name: {e}")
                });
                self
            }
            pub fn member_repo_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.member_repo_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for member_repo_type: {e}")
                });
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<VirtualMemberResponse> for super::VirtualMemberResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VirtualMemberResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    member_repo_id: value.member_repo_id?,
                    member_repo_key: value.member_repo_key?,
                    member_repo_name: value.member_repo_name?,
                    member_repo_type: value.member_repo_type?,
                    priority: value.priority?,
                })
            }
        }
        impl ::std::convert::From<super::VirtualMemberResponse> for VirtualMemberResponse {
            fn from(value: super::VirtualMemberResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    member_repo_id: Ok(value.member_repo_id),
                    member_repo_key: Ok(value.member_repo_key),
                    member_repo_name: Ok(value.member_repo_name),
                    member_repo_type: Ok(value.member_repo_type),
                    priority: Ok(value.priority),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct VirtualMembersListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::VirtualMemberResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for VirtualMembersListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl VirtualMembersListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VirtualMemberResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<VirtualMembersListResponse> for super::VirtualMembersListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VirtualMembersListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::VirtualMembersListResponse> for VirtualMembersListResponse {
            fn from(value: super::VirtualMembersListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WasmPluginResponse {
            author: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            capabilities: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            display_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            enabled_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            homepage: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            installed_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            license: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            plugin_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            resource_limits: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            source_ref: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            source_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            source_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WasmPluginResponse {
            fn default() -> Self {
                Self {
                    author: Ok(Default::default()),
                    capabilities: Err("no value supplied for capabilities".to_string()),
                    description: Ok(Default::default()),
                    display_name: Err("no value supplied for display_name".to_string()),
                    enabled_at: Ok(Default::default()),
                    homepage: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    installed_at: Err("no value supplied for installed_at".to_string()),
                    license: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    plugin_type: Err("no value supplied for plugin_type".to_string()),
                    resource_limits: Err("no value supplied for resource_limits".to_string()),
                    source_ref: Ok(Default::default()),
                    source_type: Err("no value supplied for source_type".to_string()),
                    source_url: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl WasmPluginResponse {
            pub fn author<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.author = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for author: {e}"));
                self
            }
            pub fn capabilities<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.capabilities = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for capabilities: {e}"));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {e}"));
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for display_name: {e}"));
                self
            }
            pub fn enabled_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.enabled_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled_at: {e}"));
                self
            }
            pub fn homepage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.homepage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for homepage: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn installed_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.installed_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for installed_at: {e}"));
                self
            }
            pub fn license<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.license = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for license: {e}"));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn plugin_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.plugin_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for plugin_type: {e}"));
                self
            }
            pub fn resource_limits<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.resource_limits = value.try_into().map_err(|e| {
                    format!("error converting supplied value for resource_limits: {e}")
                });
                self
            }
            pub fn source_ref<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_ref = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_ref: {e}"));
                self
            }
            pub fn source_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_type: {e}"));
                self
            }
            pub fn source_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.source_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source_url: {e}"));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {e}"));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {e}"));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<WasmPluginResponse> for super::WasmPluginResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WasmPluginResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    author: value.author?,
                    capabilities: value.capabilities?,
                    description: value.description?,
                    display_name: value.display_name?,
                    enabled_at: value.enabled_at?,
                    homepage: value.homepage?,
                    id: value.id?,
                    installed_at: value.installed_at?,
                    license: value.license?,
                    name: value.name?,
                    plugin_type: value.plugin_type?,
                    resource_limits: value.resource_limits?,
                    source_ref: value.source_ref?,
                    source_type: value.source_type?,
                    source_url: value.source_url?,
                    status: value.status?,
                    updated_at: value.updated_at?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::WasmPluginResponse> for WasmPluginResponse {
            fn from(value: super::WasmPluginResponse) -> Self {
                Self {
                    author: Ok(value.author),
                    capabilities: Ok(value.capabilities),
                    description: Ok(value.description),
                    display_name: Ok(value.display_name),
                    enabled_at: Ok(value.enabled_at),
                    homepage: Ok(value.homepage),
                    id: Ok(value.id),
                    installed_at: Ok(value.installed_at),
                    license: Ok(value.license),
                    name: Ok(value.name),
                    plugin_type: Ok(value.plugin_type),
                    resource_limits: Ok(value.resource_limits),
                    source_ref: Ok(value.source_ref),
                    source_type: Ok(value.source_type),
                    source_url: Ok(value.source_url),
                    status: Ok(value.status),
                    updated_at: Ok(value.updated_at),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WebhookListResponse {
            items: ::std::result::Result<
                ::std::vec::Vec<super::WebhookResponse>,
                ::std::string::String,
            >,
            total: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for WebhookListResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    total: Err("no value supplied for total".to_string()),
                }
            }
        }
        impl WebhookListResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {e}"));
                self
            }
            pub fn total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.total = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<WebhookListResponse> for super::WebhookListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    total: value.total?,
                })
            }
        }
        impl ::std::convert::From<super::WebhookListResponse> for WebhookListResponse {
            fn from(value: super::WebhookListResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    total: Ok(value.total),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WebhookResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            events: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            headers: ::std::result::Result<
                ::std::option::Option<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            last_triggered_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            repository_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            url: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WebhookResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    events: Err("no value supplied for events".to_string()),
                    headers: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    last_triggered_at: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    repository_id: Ok(Default::default()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl WebhookResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {e}"));
                self
            }
            pub fn events<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.events = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for events: {e}"));
                self
            }
            pub fn headers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<
                            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                        >,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.headers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for headers: {e}"));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {e}"));
                self
            }
            pub fn last_triggered_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                        ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                T::Error: ::std::fmt::Display,
            {
                self.last_triggered_at = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_triggered_at: {e}")
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {e}"));
                self
            }
            pub fn repository_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.repository_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for repository_id: {e}"));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<WebhookResponse> for super::WebhookResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    events: value.events?,
                    headers: value.headers?,
                    id: value.id?,
                    is_enabled: value.is_enabled?,
                    last_triggered_at: value.last_triggered_at?,
                    name: value.name?,
                    repository_id: value.repository_id?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::WebhookResponse> for WebhookResponse {
            fn from(value: super::WebhookResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    events: Ok(value.events),
                    headers: Ok(value.headers),
                    id: Ok(value.id),
                    is_enabled: Ok(value.is_enabled),
                    last_triggered_at: Ok(value.last_triggered_at),
                    name: Ok(value.name),
                    repository_id: Ok(value.repository_id),
                    url: Ok(value.url),
                }
            }
        }
    }
}
#[derive(Clone, Debug)]
#[doc = "Client for Artifact Keeper API\n\nEnterprise artifact registry supporting 45+ package formats.\n\nVersion: 1.0.0-rc.3"]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    #[doc = r" Create a new client."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    #[doc = r" Construct a new client with an existing `reqwest::Client`,"]
    #[doc = r" allowing more control over its configuration."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "1.0.0-rc.3"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest::Client {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
#[doc = "System administration"]
pub trait ClientAdminExt {
    #[doc = "List backups\n\nSends a `GET` request to `/api/v1/admin/backups`\n\n```ignore\nlet response = client.list_backups()\n    .page(page)\n    .per_page(per_page)\n    .status(status)\n    .type_(type_)\n    .send()\n    .await;\n```"]
    fn list_backups(&self) -> builder::ListBackups<'_>;
    #[doc = "Create backup\n\nSends a `POST` request to `/api/v1/admin/backups`\n\n```ignore\nlet response = client.create_backup()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_backup(&self) -> builder::CreateBackup<'_>;
    #[doc = "Get backup by ID\n\nSends a `GET` request to `/api/v1/admin/backups/{id}`\n\nArguments:\n- `id`: Backup ID\n```ignore\nlet response = client.get_backup()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_backup(&self) -> builder::GetBackup<'_>;
    #[doc = "Delete a backup\n\nSends a `DELETE` request to `/api/v1/admin/backups/{id}`\n\nArguments:\n- `id`: Backup ID\n```ignore\nlet response = client.delete_backup()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_backup(&self) -> builder::DeleteBackup<'_>;
    #[doc = "Cancel a running backup\n\nSends a `POST` request to `/api/v1/admin/backups/{id}/cancel`\n\nArguments:\n- `id`: Backup ID\n```ignore\nlet response = client.cancel_backup()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn cancel_backup(&self) -> builder::CancelBackup<'_>;
    #[doc = "Execute a pending backup\n\nSends a `POST` request to `/api/v1/admin/backups/{id}/execute`\n\nArguments:\n- `id`: Backup ID\n```ignore\nlet response = client.execute_backup()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn execute_backup(&self) -> builder::ExecuteBackup<'_>;
    #[doc = "Restore from backup\n\nSends a `POST` request to `/api/v1/admin/backups/{id}/restore`\n\nArguments:\n- `id`: Backup ID\n- `body`\n```ignore\nlet response = client.restore_backup()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn restore_backup(&self) -> builder::RestoreBackup<'_>;
    #[doc = "Run cleanup tasks\n\nSends a `POST` request to `/api/v1/admin/cleanup`\n\n```ignore\nlet response = client.run_cleanup()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn run_cleanup(&self) -> builder::RunCleanup<'_>;
    #[doc = "Trigger a full Meilisearch reindex of all artifacts and repositories\n\nRequires admin privileges and Meilisearch to be configured.\n\nSends a `POST` request to `/api/v1/admin/reindex`\n\n```ignore\nlet response = client.trigger_reindex()\n    .send()\n    .await;\n```"]
    fn trigger_reindex(&self) -> builder::TriggerReindex<'_>;
    #[doc = "Get system settings\n\nSends a `GET` request to `/api/v1/admin/settings`\n\n```ignore\nlet response = client.get_settings()\n    .send()\n    .await;\n```"]
    fn get_settings(&self) -> builder::GetSettings<'_>;
    #[doc = "Update system settings\n\nSends a `POST` request to `/api/v1/admin/settings`\n\n```ignore\nlet response = client.update_settings()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_settings(&self) -> builder::UpdateSettings<'_>;
    #[doc = "Get system statistics\n\nSends a `GET` request to `/api/v1/admin/stats`\n\n```ignore\nlet response = client.get_system_stats()\n    .send()\n    .await;\n```"]
    fn get_system_stats(&self) -> builder::GetSystemStats<'_>;
    #[doc = "List all remote instances for the authenticated user\n\nSends a `GET` request to `/api/v1/instances`\n\n```ignore\nlet response = client.list_instances()\n    .send()\n    .await;\n```"]
    fn list_instances(&self) -> builder::ListInstances<'_>;
    #[doc = "Create a new remote instance\n\nSends a `POST` request to `/api/v1/instances`\n\n```ignore\nlet response = client.create_instance()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_instance(&self) -> builder::CreateInstance<'_>;
    #[doc = "Delete a remote instance\n\nSends a `DELETE` request to `/api/v1/instances/{id}`\n\nArguments:\n- `id`: Remote instance ID\n```ignore\nlet response = client.delete_instance()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_instance(&self) -> builder::DeleteInstance<'_>;
    #[doc = "Proxy a GET request to a remote instance\n\nSends a `GET` request to `/api/v1/instances/{id}/proxy/{path}`\n\nArguments:\n- `id`: Remote instance ID\n- `path`: Sub-path to proxy\n```ignore\nlet response = client.proxy_get()\n    .id(id)\n    .path(path)\n    .send()\n    .await;\n```"]
    fn proxy_get(&self) -> builder::ProxyGet<'_>;
    #[doc = "Proxy a PUT request to a remote instance\n\nSends a `PUT` request to `/api/v1/instances/{id}/proxy/{path}`\n\nArguments:\n- `id`: Remote instance ID\n- `path`: Sub-path to proxy\n- `body`\n```ignore\nlet response = client.proxy_put()\n    .id(id)\n    .path(path)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn proxy_put(&self) -> builder::ProxyPut<'_>;
    #[doc = "Proxy a POST request to a remote instance\n\nSends a `POST` request to `/api/v1/instances/{id}/proxy/{path}`\n\nArguments:\n- `id`: Remote instance ID\n- `path`: Sub-path to proxy\n- `body`\n```ignore\nlet response = client.proxy_post()\n    .id(id)\n    .path(path)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn proxy_post(&self) -> builder::ProxyPost<'_>;
    #[doc = "Proxy a DELETE request to a remote instance\n\nSends a `DELETE` request to `/api/v1/instances/{id}/proxy/{path}`\n\nArguments:\n- `id`: Remote instance ID\n- `path`: Sub-path to proxy\n```ignore\nlet response = client.proxy_delete()\n    .id(id)\n    .path(path)\n    .send()\n    .await;\n```"]
    fn proxy_delete(&self) -> builder::ProxyDelete<'_>;
}
impl ClientAdminExt for Client {
    fn list_backups(&self) -> builder::ListBackups<'_> {
        builder::ListBackups::new(self)
    }
    fn create_backup(&self) -> builder::CreateBackup<'_> {
        builder::CreateBackup::new(self)
    }
    fn get_backup(&self) -> builder::GetBackup<'_> {
        builder::GetBackup::new(self)
    }
    fn delete_backup(&self) -> builder::DeleteBackup<'_> {
        builder::DeleteBackup::new(self)
    }
    fn cancel_backup(&self) -> builder::CancelBackup<'_> {
        builder::CancelBackup::new(self)
    }
    fn execute_backup(&self) -> builder::ExecuteBackup<'_> {
        builder::ExecuteBackup::new(self)
    }
    fn restore_backup(&self) -> builder::RestoreBackup<'_> {
        builder::RestoreBackup::new(self)
    }
    fn run_cleanup(&self) -> builder::RunCleanup<'_> {
        builder::RunCleanup::new(self)
    }
    fn trigger_reindex(&self) -> builder::TriggerReindex<'_> {
        builder::TriggerReindex::new(self)
    }
    fn get_settings(&self) -> builder::GetSettings<'_> {
        builder::GetSettings::new(self)
    }
    fn update_settings(&self) -> builder::UpdateSettings<'_> {
        builder::UpdateSettings::new(self)
    }
    fn get_system_stats(&self) -> builder::GetSystemStats<'_> {
        builder::GetSystemStats::new(self)
    }
    fn list_instances(&self) -> builder::ListInstances<'_> {
        builder::ListInstances::new(self)
    }
    fn create_instance(&self) -> builder::CreateInstance<'_> {
        builder::CreateInstance::new(self)
    }
    fn delete_instance(&self) -> builder::DeleteInstance<'_> {
        builder::DeleteInstance::new(self)
    }
    fn proxy_get(&self) -> builder::ProxyGet<'_> {
        builder::ProxyGet::new(self)
    }
    fn proxy_put(&self) -> builder::ProxyPut<'_> {
        builder::ProxyPut::new(self)
    }
    fn proxy_post(&self) -> builder::ProxyPost<'_> {
        builder::ProxyPost::new(self)
    }
    fn proxy_delete(&self) -> builder::ProxyDelete<'_> {
        builder::ProxyDelete::new(self)
    }
}
#[doc = "Storage and download analytics"]
pub trait ClientAnalyticsExt {
    #[doc = "GET /api/v1/admin/analytics/artifacts/stale\n\nSends a `GET` request to `/api/v1/admin/analytics/artifacts/stale`\n\n```ignore\nlet response = client.get_stale_artifacts()\n    .days(days)\n    .limit(limit)\n    .send()\n    .await;\n```"]
    fn get_stale_artifacts(&self) -> builder::GetStaleArtifacts<'_>;
    #[doc = "GET /api/v1/admin/analytics/downloads/trend\n\nSends a `GET` request to `/api/v1/admin/analytics/downloads/trend`\n\n```ignore\nlet response = client.get_download_trends()\n    .from(from)\n    .to(to)\n    .send()\n    .await;\n```"]
    fn get_download_trends(&self) -> builder::GetDownloadTrends<'_>;
    #[doc = "GET /api/v1/admin/analytics/repositories/{id}/trend\n\nSends a `GET` request to `/api/v1/admin/analytics/repositories/{id}/trend`\n\nArguments:\n- `id`: Repository ID\n- `from`\n- `to`\n```ignore\nlet response = client.get_repository_trend()\n    .id(id)\n    .from(from)\n    .to(to)\n    .send()\n    .await;\n```"]
    fn get_repository_trend(&self) -> builder::GetRepositoryTrend<'_>;
    #[doc = "POST /api/v1/admin/analytics/snapshot - manually trigger a snapshot\n\nSends a `POST` request to `/api/v1/admin/analytics/snapshot`\n\n```ignore\nlet response = client.capture_snapshot()\n    .send()\n    .await;\n```"]
    fn capture_snapshot(&self) -> builder::CaptureSnapshot<'_>;
    #[doc = "GET /api/v1/admin/analytics/storage/breakdown\n\nSends a `GET` request to `/api/v1/admin/analytics/storage/breakdown`\n\n```ignore\nlet response = client.get_storage_breakdown()\n    .send()\n    .await;\n```"]
    fn get_storage_breakdown(&self) -> builder::GetStorageBreakdown<'_>;
    #[doc = "GET /api/v1/admin/analytics/storage/growth\n\nSends a `GET` request to `/api/v1/admin/analytics/storage/growth`\n\n```ignore\nlet response = client.get_growth_summary()\n    .from(from)\n    .to(to)\n    .send()\n    .await;\n```"]
    fn get_growth_summary(&self) -> builder::GetGrowthSummary<'_>;
    #[doc = "GET /api/v1/admin/analytics/storage/trend\n\nSends a `GET` request to `/api/v1/admin/analytics/storage/trend`\n\n```ignore\nlet response = client.get_storage_trend()\n    .from(from)\n    .to(to)\n    .send()\n    .await;\n```"]
    fn get_storage_trend(&self) -> builder::GetStorageTrend<'_>;
}
impl ClientAnalyticsExt for Client {
    fn get_stale_artifacts(&self) -> builder::GetStaleArtifacts<'_> {
        builder::GetStaleArtifacts::new(self)
    }
    fn get_download_trends(&self) -> builder::GetDownloadTrends<'_> {
        builder::GetDownloadTrends::new(self)
    }
    fn get_repository_trend(&self) -> builder::GetRepositoryTrend<'_> {
        builder::GetRepositoryTrend::new(self)
    }
    fn capture_snapshot(&self) -> builder::CaptureSnapshot<'_> {
        builder::CaptureSnapshot::new(self)
    }
    fn get_storage_breakdown(&self) -> builder::GetStorageBreakdown<'_> {
        builder::GetStorageBreakdown::new(self)
    }
    fn get_growth_summary(&self) -> builder::GetGrowthSummary<'_> {
        builder::GetGrowthSummary::new(self)
    }
    fn get_storage_trend(&self) -> builder::GetStorageTrend<'_> {
        builder::GetStorageTrend::new(self)
    }
}
#[doc = "Promotion approval workflow"]
pub trait ClientApprovalExt {
    #[doc = "List approval history with optional filtering by status or source repository\n\nSends a `GET` request to `/api/v1/approval/history`\n\nArguments:\n- `page`: Page number (1-indexed)\n- `per_page`: Items per page (max 100)\n- `source_repository`: Filter by source repository key\n- `status`: Filter by status (pending, approved, rejected)\n```ignore\nlet response = client.list_approval_history()\n    .page(page)\n    .per_page(per_page)\n    .source_repository(source_repository)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_approval_history(&self) -> builder::ListApprovalHistory<'_>;
    #[doc = "List pending approval requests. Optionally filter by source repository\n\nSends a `GET` request to `/api/v1/approval/pending`\n\nArguments:\n- `page`: Page number (1-indexed)\n- `per_page`: Items per page (max 100)\n- `source_repository`: Filter by source repository key\n```ignore\nlet response = client.list_pending_approvals()\n    .page(page)\n    .per_page(per_page)\n    .source_repository(source_repository)\n    .send()\n    .await;\n```"]
    fn list_pending_approvals(&self) -> builder::ListPendingApprovals<'_>;
    #[doc = "Request approval for promoting an artifact from staging to release\n\nSends a `POST` request to `/api/v1/approval/request`\n\n```ignore\nlet response = client.request_approval()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn request_approval(&self) -> builder::RequestApproval<'_>;
    #[doc = "Get a single approval request by ID\n\nSends a `GET` request to `/api/v1/approval/{id}`\n\nArguments:\n- `id`: Approval request ID\n```ignore\nlet response = client.get_approval()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_approval(&self) -> builder::GetApproval<'_>;
    #[doc = "Approve a pending promotion request. Admin-only\n\nThis copies the artifact from the staging repo to the release repo,\ninserts the new artifact record, records promotion history, and\nupdates the approval status to \"approved\".\n\nSends a `POST` request to `/api/v1/approval/{id}/approve`\n\nArguments:\n- `id`: Approval request ID\n- `body`\n```ignore\nlet response = client.approve_promotion()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn approve_promotion(&self) -> builder::ApprovePromotion<'_>;
    #[doc = "Reject a pending promotion request. Admin-only\n\nSends a `POST` request to `/api/v1/approval/{id}/reject`\n\nArguments:\n- `id`: Approval request ID\n- `body`\n```ignore\nlet response = client.reject_promotion()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn reject_promotion(&self) -> builder::RejectPromotion<'_>;
}
impl ClientApprovalExt for Client {
    fn list_approval_history(&self) -> builder::ListApprovalHistory<'_> {
        builder::ListApprovalHistory::new(self)
    }
    fn list_pending_approvals(&self) -> builder::ListPendingApprovals<'_> {
        builder::ListPendingApprovals::new(self)
    }
    fn request_approval(&self) -> builder::RequestApproval<'_> {
        builder::RequestApproval::new(self)
    }
    fn get_approval(&self) -> builder::GetApproval<'_> {
        builder::GetApproval::new(self)
    }
    fn approve_promotion(&self) -> builder::ApprovePromotion<'_> {
        builder::ApprovePromotion::new(self)
    }
    fn reject_promotion(&self) -> builder::RejectPromotion<'_> {
        builder::RejectPromotion::new(self)
    }
}
#[doc = "Standalone artifact access by ID"]
pub trait ClientArtifactsExt {
    #[doc = "Get artifact by ID\n\nSends a `GET` request to `/api/v1/artifacts/{id}`\n\nArguments:\n- `id`: Artifact ID\n```ignore\nlet response = client.get_artifact()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_artifact(&self) -> builder::GetArtifact<'_>;
    #[doc = "Get artifact metadata by artifact ID\n\nSends a `GET` request to `/api/v1/artifacts/{id}/metadata`\n\nArguments:\n- `id`: Artifact ID\n```ignore\nlet response = client.get_artifact_metadata()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_artifact_metadata(&self) -> builder::GetArtifactMetadata<'_>;
    #[doc = "Get artifact download statistics\n\nSends a `GET` request to `/api/v1/artifacts/{id}/stats`\n\nArguments:\n- `id`: Artifact ID\n```ignore\nlet response = client.get_artifact_stats()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_artifact_stats(&self) -> builder::GetArtifactStats<'_>;
}
impl ClientArtifactsExt for Client {
    fn get_artifact(&self) -> builder::GetArtifact<'_> {
        builder::GetArtifact::new(self)
    }
    fn get_artifact_metadata(&self) -> builder::GetArtifactMetadata<'_> {
        builder::GetArtifactMetadata::new(self)
    }
    fn get_artifact_stats(&self) -> builder::GetArtifactStats<'_> {
        builder::GetArtifactStats::new(self)
    }
}
#[doc = "Authentication and token management"]
pub trait ClientAuthExt {
    #[doc = "Login with credentials\n\nSends a `POST` request to `/api/v1/auth/login`\n\n```ignore\nlet response = client.login()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn login(&self) -> builder::Login<'_>;
    #[doc = "Logout current session\n\nSends a `POST` request to `/api/v1/auth/logout`\n\n```ignore\nlet response = client.logout()\n    .send()\n    .await;\n```"]
    fn logout(&self) -> builder::Logout<'_>;
    #[doc = "Get current user info\n\nSends a `GET` request to `/api/v1/auth/me`\n\n```ignore\nlet response = client.get_current_user()\n    .send()\n    .await;\n```"]
    fn get_current_user(&self) -> builder::GetCurrentUser<'_>;
    #[doc = "Refresh access token\n\nSends a `POST` request to `/api/v1/auth/refresh`\n\n```ignore\nlet response = client.refresh_token()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn refresh_token(&self) -> builder::RefreshToken<'_>;
    #[doc = "Create a short-lived, single-use download/stream ticket for the current user.\nThe ticket can be passed as a `?ticket=` query parameter on endpoints that\ncannot use `Authorization` headers (e.g. `<a>` downloads, `EventSource` SSE)\n\nSends a `POST` request to `/api/v1/auth/ticket`\n\n```ignore\nlet response = client.create_download_ticket()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_download_ticket(&self) -> builder::CreateDownloadTicket<'_>;
    #[doc = "Create a new API token for the current user\n\nSends a `POST` request to `/api/v1/auth/tokens`\n\n```ignore\nlet response = client.create_api_token()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_api_token(&self) -> builder::CreateApiToken<'_>;
    #[doc = "Revoke an API token\n\nSends a `DELETE` request to `/api/v1/auth/tokens/{token_id}`\n\nArguments:\n- `token_id`: ID of the API token to revoke\n```ignore\nlet response = client.revoke_api_token()\n    .token_id(token_id)\n    .send()\n    .await;\n```"]
    fn revoke_api_token(&self) -> builder::RevokeApiToken<'_>;
    #[doc = "Disable TOTP for the authenticated user (requires password and current TOTP code)\n\nSends a `POST` request to `/api/v1/auth/totp/disable`\n\n```ignore\nlet response = client.disable_totp()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn disable_totp(&self) -> builder::DisableTotp<'_>;
    #[doc = "Enable TOTP by verifying the initial code and generating backup codes\n\nSends a `POST` request to `/api/v1/auth/totp/enable`\n\n```ignore\nlet response = client.enable_totp()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn enable_totp(&self) -> builder::EnableTotp<'_>;
    #[doc = "Generate a new TOTP secret and QR code URL for the authenticated user\n\nSends a `POST` request to `/api/v1/auth/totp/setup`\n\n```ignore\nlet response = client.setup_totp()\n    .send()\n    .await;\n```"]
    fn setup_totp(&self) -> builder::SetupTotp<'_>;
    #[doc = "Verify TOTP code during login (exchanges totp_token + code for full auth tokens)\n\nSends a `POST` request to `/api/v1/auth/totp/verify`\n\n```ignore\nlet response = client.verify_totp()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn verify_totp(&self) -> builder::VerifyTotp<'_>;
    #[doc = "Returns whether initial setup (password change) is required\n\nSends a `GET` request to `/api/v1/setup/status`\n\n```ignore\nlet response = client.setup_status()\n    .send()\n    .await;\n```"]
    fn setup_status(&self) -> builder::SetupStatus<'_>;
}
impl ClientAuthExt for Client {
    fn login(&self) -> builder::Login<'_> {
        builder::Login::new(self)
    }
    fn logout(&self) -> builder::Logout<'_> {
        builder::Logout::new(self)
    }
    fn get_current_user(&self) -> builder::GetCurrentUser<'_> {
        builder::GetCurrentUser::new(self)
    }
    fn refresh_token(&self) -> builder::RefreshToken<'_> {
        builder::RefreshToken::new(self)
    }
    fn create_download_ticket(&self) -> builder::CreateDownloadTicket<'_> {
        builder::CreateDownloadTicket::new(self)
    }
    fn create_api_token(&self) -> builder::CreateApiToken<'_> {
        builder::CreateApiToken::new(self)
    }
    fn revoke_api_token(&self) -> builder::RevokeApiToken<'_> {
        builder::RevokeApiToken::new(self)
    }
    fn disable_totp(&self) -> builder::DisableTotp<'_> {
        builder::DisableTotp::new(self)
    }
    fn enable_totp(&self) -> builder::EnableTotp<'_> {
        builder::EnableTotp::new(self)
    }
    fn setup_totp(&self) -> builder::SetupTotp<'_> {
        builder::SetupTotp::new(self)
    }
    fn verify_totp(&self) -> builder::VerifyTotp<'_> {
        builder::VerifyTotp::new(self)
    }
    fn setup_status(&self) -> builder::SetupStatus<'_> {
        builder::SetupStatus::new(self)
    }
}
#[doc = "Build management and tracking"]
pub trait ClientBuildsExt {
    #[doc = "List builds\n\nSends a `GET` request to `/api/v1/builds`\n\n```ignore\nlet response = client.list_builds()\n    .page(page)\n    .per_page(per_page)\n    .search(search)\n    .sort_by(sort_by)\n    .sort_order(sort_order)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_builds(&self) -> builder::ListBuilds<'_>;
    #[doc = "Create a new build (POST /api/v1/builds)\n\nSends a `POST` request to `/api/v1/builds`\n\n```ignore\nlet response = client.create_build()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_build(&self) -> builder::CreateBuild<'_>;
    #[doc = "Get diff between two builds\n\nSends a `GET` request to `/api/v1/builds/diff`\n\n```ignore\nlet response = client.get_build_diff()\n    .build_a(build_a)\n    .build_b(build_b)\n    .send()\n    .await;\n```"]
    fn get_build_diff(&self) -> builder::GetBuildDiff<'_>;
    #[doc = "Get a build by ID\n\nSends a `GET` request to `/api/v1/builds/{id}`\n\nArguments:\n- `id`: Build ID\n```ignore\nlet response = client.get_build()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_build(&self) -> builder::GetBuild<'_>;
    #[doc = "Update build status (PUT /api/v1/builds/:id)\n\nSends a `PUT` request to `/api/v1/builds/{id}`\n\nArguments:\n- `id`: Build ID\n- `body`\n```ignore\nlet response = client.update_build()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_build(&self) -> builder::UpdateBuild<'_>;
    #[doc = "Attach artifacts to a build (POST /api/v1/builds/:id/artifacts)\n\nSends a `POST` request to `/api/v1/builds/{id}/artifacts`\n\nArguments:\n- `id`: Build ID\n- `body`\n```ignore\nlet response = client.add_build_artifacts()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn add_build_artifacts(&self) -> builder::AddBuildArtifacts<'_>;
}
impl ClientBuildsExt for Client {
    fn list_builds(&self) -> builder::ListBuilds<'_> {
        builder::ListBuilds::new(self)
    }
    fn create_build(&self) -> builder::CreateBuild<'_> {
        builder::CreateBuild::new(self)
    }
    fn get_build_diff(&self) -> builder::GetBuildDiff<'_> {
        builder::GetBuildDiff::new(self)
    }
    fn get_build(&self) -> builder::GetBuild<'_> {
        builder::GetBuild::new(self)
    }
    fn update_build(&self) -> builder::UpdateBuild<'_> {
        builder::UpdateBuild::new(self)
    }
    fn add_build_artifacts(&self) -> builder::AddBuildArtifacts<'_> {
        builder::AddBuildArtifacts::new(self)
    }
}
#[doc = "User group management"]
pub trait ClientGroupsExt {
    #[doc = "List groups\n\nSends a `GET` request to `/api/v1/groups`\n\n```ignore\nlet response = client.list_groups()\n    .page(page)\n    .per_page(per_page)\n    .search(search)\n    .send()\n    .await;\n```"]
    fn list_groups(&self) -> builder::ListGroups<'_>;
    #[doc = "Create a group\n\nSends a `POST` request to `/api/v1/groups`\n\n```ignore\nlet response = client.create_group()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_group(&self) -> builder::CreateGroup<'_>;
    #[doc = "Get a group by ID\n\nSends a `GET` request to `/api/v1/groups/{id}`\n\nArguments:\n- `id`: Group ID\n```ignore\nlet response = client.get_group()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_group(&self) -> builder::GetGroup<'_>;
    #[doc = "Update a group\n\nSends a `PUT` request to `/api/v1/groups/{id}`\n\nArguments:\n- `id`: Group ID\n- `body`\n```ignore\nlet response = client.update_group()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_group(&self) -> builder::UpdateGroup<'_>;
    #[doc = "Delete a group\n\nSends a `DELETE` request to `/api/v1/groups/{id}`\n\nArguments:\n- `id`: Group ID\n```ignore\nlet response = client.delete_group()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_group(&self) -> builder::DeleteGroup<'_>;
    #[doc = "Add members to a group\n\nSends a `POST` request to `/api/v1/groups/{id}/members`\n\nArguments:\n- `id`: Group ID\n- `body`\n```ignore\nlet response = client.add_members()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn add_members(&self) -> builder::AddMembers<'_>;
    #[doc = "Remove members from a group\n\nSends a `DELETE` request to `/api/v1/groups/{id}/members`\n\nArguments:\n- `id`: Group ID\n- `body`\n```ignore\nlet response = client.remove_members()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn remove_members(&self) -> builder::RemoveMembers<'_>;
}
impl ClientGroupsExt for Client {
    fn list_groups(&self) -> builder::ListGroups<'_> {
        builder::ListGroups::new(self)
    }
    fn create_group(&self) -> builder::CreateGroup<'_> {
        builder::CreateGroup::new(self)
    }
    fn get_group(&self) -> builder::GetGroup<'_> {
        builder::GetGroup::new(self)
    }
    fn update_group(&self) -> builder::UpdateGroup<'_> {
        builder::UpdateGroup::new(self)
    }
    fn delete_group(&self) -> builder::DeleteGroup<'_> {
        builder::DeleteGroup::new(self)
    }
    fn add_members(&self) -> builder::AddMembers<'_> {
        builder::AddMembers::new(self)
    }
    fn remove_members(&self) -> builder::RemoveMembers<'_> {
        builder::RemoveMembers::new(self)
    }
}
#[doc = "Health and readiness checks"]
pub trait ClientHealthExt {
    #[doc = "Prometheus metrics endpoint.\nRenders all registered metrics from the metrics-exporter-prometheus recorder\n\nSends a `GET` request to `/api/v1/admin/metrics`\n\n```ignore\nlet response = client.metrics()\n    .send()\n    .await;\n```"]
    fn metrics(&self) -> builder::Metrics<'_>;
    #[doc = "Health check endpoint  rich status page for dashboards\n\nChecks database, storage (real write/read probe), optional services (Trivy,\nMeilisearch), and exposes DB connection pool statistics.\n\nSends a `GET` request to `/health`\n\n```ignore\nlet response = client.health_check()\n    .send()\n    .await;\n```"]
    fn health_check(&self) -> builder::HealthCheck<'_>;
    #[doc = "Liveness probe  confirms the process is alive and can serve HTTP\n\nTakes no State parameter. If Axum can route the request and execute this\nfunction, the process is alive. External service failures cannot trigger\npod restarts.\n\nSends a `GET` request to `/livez`\n\n```ignore\nlet response = client.liveness_check()\n    .send()\n    .await;\n```"]
    fn liveness_check(&self) -> builder::LivenessCheck<'_>;
    #[doc = "Readiness probe  is the service ready to accept traffic?\n\nChecks database connectivity, that migrations have run successfully,\nand that initial setup (admin password) is complete.\n\nSends a `GET` request to `/readyz`\n\n```ignore\nlet response = client.readiness_check()\n    .send()\n    .await;\n```"]
    fn readiness_check(&self) -> builder::ReadinessCheck<'_>;
}
impl ClientHealthExt for Client {
    fn metrics(&self) -> builder::Metrics<'_> {
        builder::Metrics::new(self)
    }
    fn health_check(&self) -> builder::HealthCheck<'_> {
        builder::HealthCheck::new(self)
    }
    fn liveness_check(&self) -> builder::LivenessCheck<'_> {
        builder::LivenessCheck::new(self)
    }
    fn readiness_check(&self) -> builder::ReadinessCheck<'_> {
        builder::ReadinessCheck::new(self)
    }
}
#[doc = "Retention policies and cleanup"]
pub trait ClientLifecycleExt {
    #[doc = "GET /api/v1/admin/lifecycle\n\nSends a `GET` request to `/api/v1/admin/lifecycle`\n\n```ignore\nlet response = client.list_lifecycle_policies()\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn list_lifecycle_policies(&self) -> builder::ListLifecyclePolicies<'_>;
    #[doc = "POST /api/v1/admin/lifecycle\n\nSends a `POST` request to `/api/v1/admin/lifecycle`\n\n```ignore\nlet response = client.create_lifecycle_policy()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_lifecycle_policy(&self) -> builder::CreateLifecyclePolicy<'_>;
    #[doc = "POST /api/v1/admin/lifecycle/execute-all\n\nSends a `POST` request to `/api/v1/admin/lifecycle/execute-all`\n\n```ignore\nlet response = client.execute_all_policies()\n    .send()\n    .await;\n```"]
    fn execute_all_policies(&self) -> builder::ExecuteAllPolicies<'_>;
    #[doc = "GET /api/v1/admin/lifecycle/:id\n\nSends a `GET` request to `/api/v1/admin/lifecycle/{id}`\n\nArguments:\n- `id`: Policy ID\n```ignore\nlet response = client.get_lifecycle_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_lifecycle_policy(&self) -> builder::GetLifecyclePolicy<'_>;
    #[doc = "DELETE /api/v1/admin/lifecycle/:id\n\nSends a `DELETE` request to `/api/v1/admin/lifecycle/{id}`\n\nArguments:\n- `id`: Policy ID\n```ignore\nlet response = client.delete_lifecycle_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_lifecycle_policy(&self) -> builder::DeleteLifecyclePolicy<'_>;
    #[doc = "PATCH /api/v1/admin/lifecycle/:id\n\nSends a `PATCH` request to `/api/v1/admin/lifecycle/{id}`\n\nArguments:\n- `id`: Policy ID\n- `body`\n```ignore\nlet response = client.update_lifecycle_policy()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_lifecycle_policy(&self) -> builder::UpdateLifecyclePolicy<'_>;
    #[doc = "POST /api/v1/admin/lifecycle/:id/execute\n\nSends a `POST` request to `/api/v1/admin/lifecycle/{id}/execute`\n\nArguments:\n- `id`: Policy ID\n```ignore\nlet response = client.execute_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn execute_policy(&self) -> builder::ExecutePolicy<'_>;
    #[doc = "POST /api/v1/admin/lifecycle/:id/preview - dry-run\n\nSends a `POST` request to `/api/v1/admin/lifecycle/{id}/preview`\n\nArguments:\n- `id`: Policy ID\n```ignore\nlet response = client.preview_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn preview_policy(&self) -> builder::PreviewPolicy<'_>;
}
impl ClientLifecycleExt for Client {
    fn list_lifecycle_policies(&self) -> builder::ListLifecyclePolicies<'_> {
        builder::ListLifecyclePolicies::new(self)
    }
    fn create_lifecycle_policy(&self) -> builder::CreateLifecyclePolicy<'_> {
        builder::CreateLifecyclePolicy::new(self)
    }
    fn execute_all_policies(&self) -> builder::ExecuteAllPolicies<'_> {
        builder::ExecuteAllPolicies::new(self)
    }
    fn get_lifecycle_policy(&self) -> builder::GetLifecyclePolicy<'_> {
        builder::GetLifecyclePolicy::new(self)
    }
    fn delete_lifecycle_policy(&self) -> builder::DeleteLifecyclePolicy<'_> {
        builder::DeleteLifecyclePolicy::new(self)
    }
    fn update_lifecycle_policy(&self) -> builder::UpdateLifecyclePolicy<'_> {
        builder::UpdateLifecyclePolicy::new(self)
    }
    fn execute_policy(&self) -> builder::ExecutePolicy<'_> {
        builder::ExecutePolicy::new(self)
    }
    fn preview_policy(&self) -> builder::PreviewPolicy<'_> {
        builder::PreviewPolicy::new(self)
    }
}
#[doc = "Data migration and import"]
pub trait ClientMigrationExt {
    #[doc = "List migration jobs\n\nSends a `GET` request to `/api/v1/migrations`\n\n```ignore\nlet response = client.list_migrations()\n    .page(page)\n    .per_page(per_page)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_migrations(&self) -> builder::ListMigrations<'_>;
    #[doc = "Create a new migration job\n\nSends a `POST` request to `/api/v1/migrations`\n\n```ignore\nlet response = client.create_migration()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_migration(&self) -> builder::CreateMigration<'_>;
    #[doc = "List all source connections for the current user\n\nSends a `GET` request to `/api/v1/migrations/connections`\n\n```ignore\nlet response = client.list_connections()\n    .send()\n    .await;\n```"]
    fn list_connections(&self) -> builder::ListConnections<'_>;
    #[doc = "Create a new source connection\n\nSends a `POST` request to `/api/v1/migrations/connections`\n\n```ignore\nlet response = client.create_connection()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_connection(&self) -> builder::CreateConnection<'_>;
    #[doc = "Get a specific source connection\n\nSends a `GET` request to `/api/v1/migrations/connections/{id}`\n\nArguments:\n- `id`: Connection ID\n```ignore\nlet response = client.get_connection()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_connection(&self) -> builder::GetConnection<'_>;
    #[doc = "Delete a source connection\n\nSends a `DELETE` request to `/api/v1/migrations/connections/{id}`\n\nArguments:\n- `id`: Connection ID\n```ignore\nlet response = client.delete_connection()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_connection(&self) -> builder::DeleteConnection<'_>;
    #[doc = "List repositories from Artifactory source\n\nSends a `GET` request to `/api/v1/migrations/connections/{id}/repositories`\n\nArguments:\n- `id`: Connection ID\n```ignore\nlet response = client.list_source_repositories()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn list_source_repositories(&self) -> builder::ListSourceRepositories<'_>;
    #[doc = "Test connection to Artifactory\n\nSends a `POST` request to `/api/v1/migrations/connections/{id}/test`\n\nArguments:\n- `id`: Connection ID\n```ignore\nlet response = client.test_connection()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn test_connection(&self) -> builder::TestConnection<'_>;
    #[doc = "Get a specific migration job\n\nSends a `GET` request to `/api/v1/migrations/{id}`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.get_migration()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_migration(&self) -> builder::GetMigration<'_>;
    #[doc = "Delete a migration job\n\nSends a `DELETE` request to `/api/v1/migrations/{id}`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.delete_migration()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_migration(&self) -> builder::DeleteMigration<'_>;
    #[doc = "Run pre-migration assessment\n\nSends a `POST` request to `/api/v1/migrations/{id}/assess`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.run_assessment()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn run_assessment(&self) -> builder::RunAssessment<'_>;
    #[doc = "Get assessment results\n\nSends a `GET` request to `/api/v1/migrations/{id}/assessment`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.get_assessment()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_assessment(&self) -> builder::GetAssessment<'_>;
    #[doc = "Cancel a migration job\n\nSends a `POST` request to `/api/v1/migrations/{id}/cancel`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.cancel_migration()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn cancel_migration(&self) -> builder::CancelMigration<'_>;
    #[doc = "List migration items for a job\n\nSends a `GET` request to `/api/v1/migrations/{id}/items`\n\nArguments:\n- `id`: Migration job ID\n- `item_type`\n- `page`\n- `per_page`\n- `status`\n```ignore\nlet response = client.list_migration_items()\n    .id(id)\n    .item_type(item_type)\n    .page(page)\n    .per_page(per_page)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_migration_items(&self) -> builder::ListMigrationItems<'_>;
    #[doc = "Pause a migration job\n\nSends a `POST` request to `/api/v1/migrations/{id}/pause`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.pause_migration()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn pause_migration(&self) -> builder::PauseMigration<'_>;
    #[doc = "Get migration report\n\nSends a `GET` request to `/api/v1/migrations/{id}/report`\n\nArguments:\n- `id`: Migration job ID\n- `format`\n```ignore\nlet response = client.get_migration_report()\n    .id(id)\n    .format(format)\n    .send()\n    .await;\n```"]
    fn get_migration_report(&self) -> builder::GetMigrationReport<'_>;
    #[doc = "Resume a paused migration job\n\nSends a `POST` request to `/api/v1/migrations/{id}/resume`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.resume_migration()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn resume_migration(&self) -> builder::ResumeMigration<'_>;
    #[doc = "Start a migration job\n\nSends a `POST` request to `/api/v1/migrations/{id}/start`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.start_migration()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn start_migration(&self) -> builder::StartMigration<'_>;
    #[doc = "Stream migration progress via Server-Sent Events\n\nSends a `GET` request to `/api/v1/migrations/{id}/stream`\n\nArguments:\n- `id`: Migration job ID\n```ignore\nlet response = client.stream_migration_progress()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn stream_migration_progress(&self) -> builder::StreamMigrationProgress<'_>;
}
impl ClientMigrationExt for Client {
    fn list_migrations(&self) -> builder::ListMigrations<'_> {
        builder::ListMigrations::new(self)
    }
    fn create_migration(&self) -> builder::CreateMigration<'_> {
        builder::CreateMigration::new(self)
    }
    fn list_connections(&self) -> builder::ListConnections<'_> {
        builder::ListConnections::new(self)
    }
    fn create_connection(&self) -> builder::CreateConnection<'_> {
        builder::CreateConnection::new(self)
    }
    fn get_connection(&self) -> builder::GetConnection<'_> {
        builder::GetConnection::new(self)
    }
    fn delete_connection(&self) -> builder::DeleteConnection<'_> {
        builder::DeleteConnection::new(self)
    }
    fn list_source_repositories(&self) -> builder::ListSourceRepositories<'_> {
        builder::ListSourceRepositories::new(self)
    }
    fn test_connection(&self) -> builder::TestConnection<'_> {
        builder::TestConnection::new(self)
    }
    fn get_migration(&self) -> builder::GetMigration<'_> {
        builder::GetMigration::new(self)
    }
    fn delete_migration(&self) -> builder::DeleteMigration<'_> {
        builder::DeleteMigration::new(self)
    }
    fn run_assessment(&self) -> builder::RunAssessment<'_> {
        builder::RunAssessment::new(self)
    }
    fn get_assessment(&self) -> builder::GetAssessment<'_> {
        builder::GetAssessment::new(self)
    }
    fn cancel_migration(&self) -> builder::CancelMigration<'_> {
        builder::CancelMigration::new(self)
    }
    fn list_migration_items(&self) -> builder::ListMigrationItems<'_> {
        builder::ListMigrationItems::new(self)
    }
    fn pause_migration(&self) -> builder::PauseMigration<'_> {
        builder::PauseMigration::new(self)
    }
    fn get_migration_report(&self) -> builder::GetMigrationReport<'_> {
        builder::GetMigrationReport::new(self)
    }
    fn resume_migration(&self) -> builder::ResumeMigration<'_> {
        builder::ResumeMigration::new(self)
    }
    fn start_migration(&self) -> builder::StartMigration<'_> {
        builder::StartMigration::new(self)
    }
    fn stream_migration_progress(&self) -> builder::StreamMigrationProgress<'_> {
        builder::StreamMigrationProgress::new(self)
    }
}
#[doc = "Health monitoring and alerts"]
pub trait ClientMonitoringExt {
    #[doc = "GET /api/v1/admin/monitoring/alerts\n\nSends a `GET` request to `/api/v1/admin/monitoring/alerts`\n\n```ignore\nlet response = client.get_alert_states()\n    .send()\n    .await;\n```"]
    fn get_alert_states(&self) -> builder::GetAlertStates<'_>;
    #[doc = "POST /api/v1/admin/monitoring/alerts/suppress\n\nSends a `POST` request to `/api/v1/admin/monitoring/alerts/suppress`\n\n```ignore\nlet response = client.suppress_alert()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn suppress_alert(&self) -> builder::SuppressAlert<'_>;
    #[doc = "POST /api/v1/admin/monitoring/check - manually trigger health checks\n\nSends a `POST` request to `/api/v1/admin/monitoring/check`\n\n```ignore\nlet response = client.run_health_check()\n    .send()\n    .await;\n```"]
    fn run_health_check(&self) -> builder::RunHealthCheck<'_>;
    #[doc = "GET /api/v1/admin/monitoring/health-log\n\nSends a `GET` request to `/api/v1/admin/monitoring/health-log`\n\n```ignore\nlet response = client.get_health_log()\n    .limit(limit)\n    .service(service)\n    .send()\n    .await;\n```"]
    fn get_health_log(&self) -> builder::GetHealthLog<'_>;
}
impl ClientMonitoringExt for Client {
    fn get_alert_states(&self) -> builder::GetAlertStates<'_> {
        builder::GetAlertStates::new(self)
    }
    fn suppress_alert(&self) -> builder::SuppressAlert<'_> {
        builder::SuppressAlert::new(self)
    }
    fn run_health_check(&self) -> builder::RunHealthCheck<'_> {
        builder::RunHealthCheck::new(self)
    }
    fn get_health_log(&self) -> builder::GetHealthLog<'_> {
        builder::GetHealthLog::new(self)
    }
}
#[doc = "Package discovery and version listing"]
pub trait ClientPackagesExt {
    #[doc = "List packages\n\nSends a `GET` request to `/api/v1/packages`\n\n```ignore\nlet response = client.list_packages()\n    .format(format)\n    .page(page)\n    .per_page(per_page)\n    .repository_key(repository_key)\n    .search(search)\n    .send()\n    .await;\n```"]
    fn list_packages(&self) -> builder::ListPackages<'_>;
    #[doc = "Get a package by ID\n\nSends a `GET` request to `/api/v1/packages/{id}`\n\nArguments:\n- `id`: Package ID\n```ignore\nlet response = client.get_package()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_package(&self) -> builder::GetPackage<'_>;
    #[doc = "Get package versions\n\nSends a `GET` request to `/api/v1/packages/{id}/versions`\n\nArguments:\n- `id`: Package ID\n```ignore\nlet response = client.get_package_versions()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_package_versions(&self) -> builder::GetPackageVersions<'_>;
}
impl ClientPackagesExt for Client {
    fn list_packages(&self) -> builder::ListPackages<'_> {
        builder::ListPackages::new(self)
    }
    fn get_package(&self) -> builder::GetPackage<'_> {
        builder::GetPackage::new(self)
    }
    fn get_package_versions(&self) -> builder::GetPackageVersions<'_> {
        builder::GetPackageVersions::new(self)
    }
}
#[doc = "Peer instance label management"]
pub trait ClientPeerInstanceLabelsExt {
    #[doc = "List all labels on a peer instance\n\nSends a `GET` request to `/api/v1/peers/{id}/labels`\n\nArguments:\n- `id`: Peer instance ID\n```ignore\nlet response = client.list_labels()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn list_labels(&self) -> builder::ListLabels<'_>;
    #[doc = "Set all labels on a peer instance (replaces existing)\n\nSends a `PUT` request to `/api/v1/peers/{id}/labels`\n\nArguments:\n- `id`: Peer instance ID\n- `body`\n```ignore\nlet response = client.set_labels()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn set_labels(&self) -> builder::SetLabels<'_>;
    #[doc = "Add or update a single label on a peer instance\n\nSends a `POST` request to `/api/v1/peers/{id}/labels/{label_key}`\n\nArguments:\n- `id`: Peer instance ID\n- `label_key`: Label key to set\n- `body`\n```ignore\nlet response = client.add_label()\n    .id(id)\n    .label_key(label_key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn add_label(&self) -> builder::AddLabel<'_>;
    #[doc = "Delete a label by key from a peer instance\n\nSends a `DELETE` request to `/api/v1/peers/{id}/labels/{label_key}`\n\nArguments:\n- `id`: Peer instance ID\n- `label_key`: Label key to remove\n```ignore\nlet response = client.delete_label()\n    .id(id)\n    .label_key(label_key)\n    .send()\n    .await;\n```"]
    fn delete_label(&self) -> builder::DeleteLabel<'_>;
}
impl ClientPeerInstanceLabelsExt for Client {
    fn list_labels(&self) -> builder::ListLabels<'_> {
        builder::ListLabels::new(self)
    }
    fn set_labels(&self) -> builder::SetLabels<'_> {
        builder::SetLabels::new(self)
    }
    fn add_label(&self) -> builder::AddLabel<'_> {
        builder::AddLabel::new(self)
    }
    fn delete_label(&self) -> builder::DeleteLabel<'_> {
        builder::DeleteLabel::new(self)
    }
}
#[doc = "Peer replication and sync"]
pub trait ClientPeersExt {
    #[doc = "List peer instances\n\nSends a `GET` request to `/api/v1/peers`\n\n```ignore\nlet response = client.list_peers()\n    .page(page)\n    .per_page(per_page)\n    .region(region)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_peers(&self) -> builder::ListPeers<'_>;
    #[doc = "Register new peer instance\n\nSends a `POST` request to `/api/v1/peers`\n\n```ignore\nlet response = client.register_peer()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn register_peer(&self) -> builder::RegisterPeer<'_>;
    #[doc = "POST /api/v1/peers/announce\n\nSends a `POST` request to `/api/v1/peers/announce`\n\n```ignore\nlet response = client.announce_peer()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn announce_peer(&self) -> builder::AnnouncePeer<'_>;
    #[doc = "GET /api/v1/peers/identity\n\nSends a `GET` request to `/api/v1/peers/identity`\n\n```ignore\nlet response = client.get_identity()\n    .send()\n    .await;\n```"]
    fn get_identity(&self) -> builder::GetIdentity<'_>;
    #[doc = "Get peer instance details\n\nSends a `GET` request to `/api/v1/peers/{id}`\n\nArguments:\n- `id`: Peer instance ID\n```ignore\nlet response = client.get_peer()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_peer(&self) -> builder::GetPeer<'_>;
    #[doc = "Unregister peer instance\n\nSends a `DELETE` request to `/api/v1/peers/{id}`\n\nArguments:\n- `id`: Peer instance ID\n```ignore\nlet response = client.unregister_peer()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn unregister_peer(&self) -> builder::UnregisterPeer<'_>;
    #[doc = "GET /api/v1/peers/:id/chunks/:artifact_id\n\nSends a `GET` request to `/api/v1/peers/{id}/chunks/{artifact_id}`\n\nArguments:\n- `id`: Peer instance ID\n- `artifact_id`: Artifact ID\n```ignore\nlet response = client.get_chunk_availability()\n    .id(id)\n    .artifact_id(artifact_id)\n    .send()\n    .await;\n```"]
    fn get_chunk_availability(&self) -> builder::GetChunkAvailability<'_>;
    #[doc = "PUT /api/v1/peers/:id/chunks/:artifact_id\n\nSends a `PUT` request to `/api/v1/peers/{id}/chunks/{artifact_id}`\n\nArguments:\n- `id`: Peer instance ID\n- `artifact_id`: Artifact ID\n- `body`\n```ignore\nlet response = client.update_chunk_availability()\n    .id(id)\n    .artifact_id(artifact_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_chunk_availability(&self) -> builder::UpdateChunkAvailability<'_>;
    #[doc = "GET /api/v1/peers/:id/chunks/:artifact_id/peers\n\nSends a `GET` request to `/api/v1/peers/{id}/chunks/{artifact_id}/peers`\n\nArguments:\n- `id`: Peer instance ID\n- `artifact_id`: Artifact ID\n```ignore\nlet response = client.get_peers_with_chunks()\n    .id(id)\n    .artifact_id(artifact_id)\n    .send()\n    .await;\n```"]
    fn get_peers_with_chunks(&self) -> builder::GetPeersWithChunks<'_>;
    #[doc = "GET /api/v1/peers/:id/chunks/:artifact_id/scored-peers\n\nSends a `GET` request to `/api/v1/peers/{id}/chunks/{artifact_id}/scored-peers`\n\nArguments:\n- `id`: Peer instance ID\n- `artifact_id`: Artifact ID\n```ignore\nlet response = client.get_scored_peers()\n    .id(id)\n    .artifact_id(artifact_id)\n    .send()\n    .await;\n```"]
    fn get_scored_peers(&self) -> builder::GetScoredPeers<'_>;
    #[doc = "GET /api/v1/peers/:id/connections\n\nSends a `GET` request to `/api/v1/peers/{id}/connections`\n\nArguments:\n- `id`: Peer instance ID\n- `status`: Filter peers by status (active, probing, unreachable, disabled)\n```ignore\nlet response = client.list_peer_connections()\n    .id(id)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_peer_connections(&self) -> builder::ListPeerConnections<'_>;
    #[doc = "GET /api/v1/peers/:id/connections/discover\n\nSends a `GET` request to `/api/v1/peers/{id}/connections/discover`\n\nArguments:\n- `id`: Peer instance ID\n```ignore\nlet response = client.discover_peers()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn discover_peers(&self) -> builder::DiscoverPeers<'_>;
    #[doc = "POST /api/v1/peers/:id/connections/probe\n\nSends a `POST` request to `/api/v1/peers/{id}/connections/probe`\n\nArguments:\n- `id`: Peer instance ID\n- `body`\n```ignore\nlet response = client.probe_peer()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn probe_peer(&self) -> builder::ProbePeer<'_>;
    #[doc = "POST /api/v1/peers/:id/connections/:target_id/unreachable\n\nSends a `POST` request to `/api/v1/peers/{id}/connections/{target_id}/unreachable`\n\nArguments:\n- `id`: Peer instance ID\n- `target_id`: Target peer ID to mark unreachable\n```ignore\nlet response = client.mark_unreachable()\n    .id(id)\n    .target_id(target_id)\n    .send()\n    .await;\n```"]
    fn mark_unreachable(&self) -> builder::MarkUnreachable<'_>;
    #[doc = "Heartbeat from peer instance\n\nSends a `POST` request to `/api/v1/peers/{id}/heartbeat`\n\nArguments:\n- `id`: Peer instance ID\n- `body`\n```ignore\nlet response = client.heartbeat()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn heartbeat(&self) -> builder::Heartbeat<'_>;
    #[doc = "PUT /api/v1/peers/:id/network-profile\n\nSends a `PUT` request to `/api/v1/peers/{id}/network-profile`\n\nArguments:\n- `id`: Peer instance ID\n- `body`\n```ignore\nlet response = client.update_network_profile()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_network_profile(&self) -> builder::UpdateNetworkProfile<'_>;
    #[doc = "Get assigned repositories for peer instance\n\nSends a `GET` request to `/api/v1/peers/{id}/repositories`\n\nArguments:\n- `id`: Peer instance ID\n```ignore\nlet response = client.get_assigned_repos()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_assigned_repos(&self) -> builder::GetAssignedRepos<'_>;
    #[doc = "Assign repository to peer instance\n\nSends a `POST` request to `/api/v1/peers/{id}/repositories`\n\nArguments:\n- `id`: Peer instance ID\n- `body`\n```ignore\nlet response = client.assign_repo()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn assign_repo(&self) -> builder::AssignRepo<'_>;
    #[doc = "Unassign repository from peer instance\n\nSends a `DELETE` request to `/api/v1/peers/{id}/repositories/{repo_id}`\n\nArguments:\n- `id`: Peer instance ID\n- `repo_id`: Repository ID\n```ignore\nlet response = client.unassign_repo()\n    .id(id)\n    .repo_id(repo_id)\n    .send()\n    .await;\n```"]
    fn unassign_repo(&self) -> builder::UnassignRepo<'_>;
    #[doc = "Trigger sync for peer instance\n\nSends a `POST` request to `/api/v1/peers/{id}/sync`\n\nArguments:\n- `id`: Peer instance ID\n```ignore\nlet response = client.trigger_sync()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn trigger_sync(&self) -> builder::TriggerSync<'_>;
    #[doc = "Get pending sync tasks for peer instance\n\nSends a `GET` request to `/api/v1/peers/{id}/sync/tasks`\n\nArguments:\n- `id`: Peer instance ID\n- `page`\n- `per_page`\n- `region`\n- `status`\n```ignore\nlet response = client.get_sync_tasks()\n    .id(id)\n    .page(page)\n    .per_page(per_page)\n    .region(region)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn get_sync_tasks(&self) -> builder::GetSyncTasks<'_>;
    #[doc = "POST /api/v1/peers/:id/transfer/init\n\nSends a `POST` request to `/api/v1/peers/{id}/transfer/init`\n\nArguments:\n- `id`: Peer instance ID\n- `body`\n```ignore\nlet response = client.init_transfer()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn init_transfer(&self) -> builder::InitTransfer<'_>;
    #[doc = "GET /api/v1/peers/:id/transfer/:session_id\n\nSends a `GET` request to `/api/v1/peers/{id}/transfer/{session_id}`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n```ignore\nlet response = client.get_session()\n    .id(id)\n    .session_id(session_id)\n    .send()\n    .await;\n```"]
    fn get_session(&self) -> builder::GetSession<'_>;
    #[doc = "POST /api/v1/peers/:id/transfer/:session_id/chunk/:chunk_index/complete\n\nSends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/chunk/{chunk_index}/complete`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n- `chunk_index`: Chunk index\n- `body`\n```ignore\nlet response = client.complete_chunk()\n    .id(id)\n    .session_id(session_id)\n    .chunk_index(chunk_index)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn complete_chunk(&self) -> builder::CompleteChunk<'_>;
    #[doc = "POST /api/v1/peers/:id/transfer/:session_id/chunk/:chunk_index/fail\n\nSends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/chunk/{chunk_index}/fail`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n- `chunk_index`: Chunk index\n- `body`\n```ignore\nlet response = client.fail_chunk()\n    .id(id)\n    .session_id(session_id)\n    .chunk_index(chunk_index)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn fail_chunk(&self) -> builder::FailChunk<'_>;
    #[doc = "POST /api/v1/peers/:id/transfer/:session_id/chunk/:chunk_index/retry\n\nSends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/chunk/{chunk_index}/retry`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n- `chunk_index`: Chunk index\n```ignore\nlet response = client.retry_chunk()\n    .id(id)\n    .session_id(session_id)\n    .chunk_index(chunk_index)\n    .send()\n    .await;\n```"]
    fn retry_chunk(&self) -> builder::RetryChunk<'_>;
    #[doc = "GET /api/v1/peers/:id/transfer/:session_id/chunks\n\nSends a `GET` request to `/api/v1/peers/{id}/transfer/{session_id}/chunks`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n```ignore\nlet response = client.get_chunk_manifest()\n    .id(id)\n    .session_id(session_id)\n    .send()\n    .await;\n```"]
    fn get_chunk_manifest(&self) -> builder::GetChunkManifest<'_>;
    #[doc = "POST /api/v1/peers/:id/transfer/:session_id/complete\n\nSends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/complete`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n```ignore\nlet response = client.complete_session()\n    .id(id)\n    .session_id(session_id)\n    .send()\n    .await;\n```"]
    fn complete_session(&self) -> builder::CompleteSession<'_>;
    #[doc = "POST /api/v1/peers/:id/transfer/:session_id/fail\n\nSends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/fail`\n\nArguments:\n- `id`: Peer instance ID\n- `session_id`: Transfer session ID\n- `body`\n```ignore\nlet response = client.fail_session()\n    .id(id)\n    .session_id(session_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn fail_session(&self) -> builder::FailSession<'_>;
    #[doc = "List all sync policies\n\nSends a `GET` request to `/api/v1/sync-policies`\n\n```ignore\nlet response = client.list_sync_policies()\n    .send()\n    .await;\n```"]
    fn list_sync_policies(&self) -> builder::ListSyncPolicies<'_>;
    #[doc = "Create a new sync policy\n\nSends a `POST` request to `/api/v1/sync-policies`\n\n```ignore\nlet response = client.create_sync_policy()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_sync_policy(&self) -> builder::CreateSyncPolicy<'_>;
    #[doc = "Force re-evaluate all sync policies\n\nSends a `POST` request to `/api/v1/sync-policies/evaluate`\n\n```ignore\nlet response = client.evaluate_policies()\n    .send()\n    .await;\n```"]
    fn evaluate_policies(&self) -> builder::EvaluatePolicies<'_>;
    #[doc = "Preview what a policy would match (dry-run)\n\nSends a `POST` request to `/api/v1/sync-policies/preview`\n\n```ignore\nlet response = client.preview_sync_policy()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn preview_sync_policy(&self) -> builder::PreviewSyncPolicy<'_>;
    #[doc = "Get a sync policy by ID\n\nSends a `GET` request to `/api/v1/sync-policies/{id}`\n\nArguments:\n- `id`: Sync policy ID\n```ignore\nlet response = client.get_sync_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_sync_policy(&self) -> builder::GetSyncPolicy<'_>;
    #[doc = "Update a sync policy\n\nSends a `PUT` request to `/api/v1/sync-policies/{id}`\n\nArguments:\n- `id`: Sync policy ID\n- `body`\n```ignore\nlet response = client.update_sync_policy()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_sync_policy(&self) -> builder::UpdateSyncPolicy<'_>;
    #[doc = "Delete a sync policy\n\nSends a `DELETE` request to `/api/v1/sync-policies/{id}`\n\nArguments:\n- `id`: Sync policy ID\n```ignore\nlet response = client.delete_sync_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_sync_policy(&self) -> builder::DeleteSyncPolicy<'_>;
    #[doc = "Toggle a sync policy (enable/disable)\n\nSends a `POST` request to `/api/v1/sync-policies/{id}/toggle`\n\nArguments:\n- `id`: Sync policy ID\n- `body`\n```ignore\nlet response = client.toggle_policy()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn toggle_policy(&self) -> builder::TogglePolicy<'_>;
}
impl ClientPeersExt for Client {
    fn list_peers(&self) -> builder::ListPeers<'_> {
        builder::ListPeers::new(self)
    }
    fn register_peer(&self) -> builder::RegisterPeer<'_> {
        builder::RegisterPeer::new(self)
    }
    fn announce_peer(&self) -> builder::AnnouncePeer<'_> {
        builder::AnnouncePeer::new(self)
    }
    fn get_identity(&self) -> builder::GetIdentity<'_> {
        builder::GetIdentity::new(self)
    }
    fn get_peer(&self) -> builder::GetPeer<'_> {
        builder::GetPeer::new(self)
    }
    fn unregister_peer(&self) -> builder::UnregisterPeer<'_> {
        builder::UnregisterPeer::new(self)
    }
    fn get_chunk_availability(&self) -> builder::GetChunkAvailability<'_> {
        builder::GetChunkAvailability::new(self)
    }
    fn update_chunk_availability(&self) -> builder::UpdateChunkAvailability<'_> {
        builder::UpdateChunkAvailability::new(self)
    }
    fn get_peers_with_chunks(&self) -> builder::GetPeersWithChunks<'_> {
        builder::GetPeersWithChunks::new(self)
    }
    fn get_scored_peers(&self) -> builder::GetScoredPeers<'_> {
        builder::GetScoredPeers::new(self)
    }
    fn list_peer_connections(&self) -> builder::ListPeerConnections<'_> {
        builder::ListPeerConnections::new(self)
    }
    fn discover_peers(&self) -> builder::DiscoverPeers<'_> {
        builder::DiscoverPeers::new(self)
    }
    fn probe_peer(&self) -> builder::ProbePeer<'_> {
        builder::ProbePeer::new(self)
    }
    fn mark_unreachable(&self) -> builder::MarkUnreachable<'_> {
        builder::MarkUnreachable::new(self)
    }
    fn heartbeat(&self) -> builder::Heartbeat<'_> {
        builder::Heartbeat::new(self)
    }
    fn update_network_profile(&self) -> builder::UpdateNetworkProfile<'_> {
        builder::UpdateNetworkProfile::new(self)
    }
    fn get_assigned_repos(&self) -> builder::GetAssignedRepos<'_> {
        builder::GetAssignedRepos::new(self)
    }
    fn assign_repo(&self) -> builder::AssignRepo<'_> {
        builder::AssignRepo::new(self)
    }
    fn unassign_repo(&self) -> builder::UnassignRepo<'_> {
        builder::UnassignRepo::new(self)
    }
    fn trigger_sync(&self) -> builder::TriggerSync<'_> {
        builder::TriggerSync::new(self)
    }
    fn get_sync_tasks(&self) -> builder::GetSyncTasks<'_> {
        builder::GetSyncTasks::new(self)
    }
    fn init_transfer(&self) -> builder::InitTransfer<'_> {
        builder::InitTransfer::new(self)
    }
    fn get_session(&self) -> builder::GetSession<'_> {
        builder::GetSession::new(self)
    }
    fn complete_chunk(&self) -> builder::CompleteChunk<'_> {
        builder::CompleteChunk::new(self)
    }
    fn fail_chunk(&self) -> builder::FailChunk<'_> {
        builder::FailChunk::new(self)
    }
    fn retry_chunk(&self) -> builder::RetryChunk<'_> {
        builder::RetryChunk::new(self)
    }
    fn get_chunk_manifest(&self) -> builder::GetChunkManifest<'_> {
        builder::GetChunkManifest::new(self)
    }
    fn complete_session(&self) -> builder::CompleteSession<'_> {
        builder::CompleteSession::new(self)
    }
    fn fail_session(&self) -> builder::FailSession<'_> {
        builder::FailSession::new(self)
    }
    fn list_sync_policies(&self) -> builder::ListSyncPolicies<'_> {
        builder::ListSyncPolicies::new(self)
    }
    fn create_sync_policy(&self) -> builder::CreateSyncPolicy<'_> {
        builder::CreateSyncPolicy::new(self)
    }
    fn evaluate_policies(&self) -> builder::EvaluatePolicies<'_> {
        builder::EvaluatePolicies::new(self)
    }
    fn preview_sync_policy(&self) -> builder::PreviewSyncPolicy<'_> {
        builder::PreviewSyncPolicy::new(self)
    }
    fn get_sync_policy(&self) -> builder::GetSyncPolicy<'_> {
        builder::GetSyncPolicy::new(self)
    }
    fn update_sync_policy(&self) -> builder::UpdateSyncPolicy<'_> {
        builder::UpdateSyncPolicy::new(self)
    }
    fn delete_sync_policy(&self) -> builder::DeleteSyncPolicy<'_> {
        builder::DeleteSyncPolicy::new(self)
    }
    fn toggle_policy(&self) -> builder::TogglePolicy<'_> {
        builder::TogglePolicy::new(self)
    }
}
#[doc = "RBAC permission management"]
pub trait ClientPermissionsExt {
    #[doc = "List permissions\n\nSends a `GET` request to `/api/v1/permissions`\n\n```ignore\nlet response = client.list_permissions()\n    .page(page)\n    .per_page(per_page)\n    .principal_id(principal_id)\n    .principal_type(principal_type)\n    .target_id(target_id)\n    .target_type(target_type)\n    .send()\n    .await;\n```"]
    fn list_permissions(&self) -> builder::ListPermissions<'_>;
    #[doc = "Create a permission\n\nSends a `POST` request to `/api/v1/permissions`\n\n```ignore\nlet response = client.create_permission()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_permission(&self) -> builder::CreatePermission<'_>;
    #[doc = "Get a permission by ID\n\nSends a `GET` request to `/api/v1/permissions/{id}`\n\nArguments:\n- `id`: Permission ID\n```ignore\nlet response = client.get_permission()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_permission(&self) -> builder::GetPermission<'_>;
    #[doc = "Update a permission\n\nSends a `PUT` request to `/api/v1/permissions/{id}`\n\nArguments:\n- `id`: Permission ID\n- `body`\n```ignore\nlet response = client.update_permission()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_permission(&self) -> builder::UpdatePermission<'_>;
    #[doc = "Delete a permission\n\nSends a `DELETE` request to `/api/v1/permissions/{id}`\n\nArguments:\n- `id`: Permission ID\n```ignore\nlet response = client.delete_permission()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_permission(&self) -> builder::DeletePermission<'_>;
}
impl ClientPermissionsExt for Client {
    fn list_permissions(&self) -> builder::ListPermissions<'_> {
        builder::ListPermissions::new(self)
    }
    fn create_permission(&self) -> builder::CreatePermission<'_> {
        builder::CreatePermission::new(self)
    }
    fn get_permission(&self) -> builder::GetPermission<'_> {
        builder::GetPermission::new(self)
    }
    fn update_permission(&self) -> builder::UpdatePermission<'_> {
        builder::UpdatePermission::new(self)
    }
    fn delete_permission(&self) -> builder::DeletePermission<'_> {
        builder::DeletePermission::new(self)
    }
}
#[doc = "WASM plugin lifecycle"]
pub trait ClientPluginsExt {
    #[doc = "List all format handlers (T039)\n\nSends a `GET` request to `/api/v1/formats`\n\n```ignore\nlet response = client.list_format_handlers()\n    .enabled(enabled)\n    .type_(type_)\n    .send()\n    .await;\n```"]
    fn list_format_handlers(&self) -> builder::ListFormatHandlers<'_>;
    #[doc = "Get a format handler by key (T040)\n\nSends a `GET` request to `/api/v1/formats/{format_key}`\n\nArguments:\n- `format_key`: Format handler key\n```ignore\nlet response = client.get_format_handler()\n    .format_key(format_key)\n    .send()\n    .await;\n```"]
    fn get_format_handler(&self) -> builder::GetFormatHandler<'_>;
    #[doc = "Disable a format handler (T042)\n\nSends a `POST` request to `/api/v1/formats/{format_key}/disable`\n\nArguments:\n- `format_key`: Format handler key\n```ignore\nlet response = client.disable_format_handler()\n    .format_key(format_key)\n    .send()\n    .await;\n```"]
    fn disable_format_handler(&self) -> builder::DisableFormatHandler<'_>;
    #[doc = "Enable a format handler (T041)\n\nSends a `POST` request to `/api/v1/formats/{format_key}/enable`\n\nArguments:\n- `format_key`: Format handler key\n```ignore\nlet response = client.enable_format_handler()\n    .format_key(format_key)\n    .send()\n    .await;\n```"]
    fn enable_format_handler(&self) -> builder::EnableFormatHandler<'_>;
    #[doc = "Test a format handler with sample content (T062)\n\nSends a `POST` request to `/api/v1/formats/{format_key}/test`\n\nArguments:\n- `format_key`: Format handler key\n- `body`\n```ignore\nlet response = client.test_format_handler()\n    .format_key(format_key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn test_format_handler(&self) -> builder::TestFormatHandler<'_>;
    #[doc = "List installed plugins\n\nSends a `GET` request to `/api/v1/plugins`\n\n```ignore\nlet response = client.list_plugins()\n    .status(status)\n    .type_(type_)\n    .send()\n    .await;\n```"]
    fn list_plugins(&self) -> builder::ListPlugins<'_>;
    #[doc = "Install a plugin from a Git repository (T021)\n\nSends a `POST` request to `/api/v1/plugins/install/git`\n\n```ignore\nlet response = client.install_from_git()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn install_from_git(&self) -> builder::InstallFromGit<'_>;
    #[doc = "Install a plugin from local filesystem path (T063)\nThis endpoint is intended for development use only\n\nSends a `POST` request to `/api/v1/plugins/install/local`\n\n```ignore\nlet response = client.install_from_local()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn install_from_local(&self) -> builder::InstallFromLocal<'_>;
    #[doc = "Get plugin details\n\nSends a `GET` request to `/api/v1/plugins/{id}`\n\nArguments:\n- `id`: Plugin ID\n```ignore\nlet response = client.get_plugin()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_plugin(&self) -> builder::GetPlugin<'_>;
    #[doc = "Uninstall plugin\n\nSends a `DELETE` request to `/api/v1/plugins/{id}`\n\nArguments:\n- `id`: Plugin ID\n```ignore\nlet response = client.uninstall_plugin()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn uninstall_plugin(&self) -> builder::UninstallPlugin<'_>;
    #[doc = "Get plugin configuration\n\nSends a `GET` request to `/api/v1/plugins/{id}/config`\n\nArguments:\n- `id`: Plugin ID\n```ignore\nlet response = client.get_plugin_config()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_plugin_config(&self) -> builder::GetPluginConfig<'_>;
    #[doc = "Update plugin configuration\n\nSends a `POST` request to `/api/v1/plugins/{id}/config`\n\nArguments:\n- `id`: Plugin ID\n- `body`\n```ignore\nlet response = client.update_plugin_config()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_plugin_config(&self) -> builder::UpdatePluginConfig<'_>;
    #[doc = "Disable plugin\n\nSends a `POST` request to `/api/v1/plugins/{id}/disable`\n\nArguments:\n- `id`: Plugin ID\n```ignore\nlet response = client.disable_plugin()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn disable_plugin(&self) -> builder::DisablePlugin<'_>;
    #[doc = "Enable plugin\n\nSends a `POST` request to `/api/v1/plugins/{id}/enable`\n\nArguments:\n- `id`: Plugin ID\n```ignore\nlet response = client.enable_plugin()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn enable_plugin(&self) -> builder::EnablePlugin<'_>;
    #[doc = "Get plugin events (T026)\n\nSends a `GET` request to `/api/v1/plugins/{id}/events`\n\nArguments:\n- `id`: Plugin ID\n- `limit`\n```ignore\nlet response = client.get_plugin_events()\n    .id(id)\n    .limit(limit)\n    .send()\n    .await;\n```"]
    fn get_plugin_events(&self) -> builder::GetPluginEvents<'_>;
    #[doc = "Reload a plugin (hot-reload) (T048)\n\nSends a `POST` request to `/api/v1/plugins/{id}/reload`\n\nArguments:\n- `id`: Plugin ID\n```ignore\nlet response = client.reload_plugin()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn reload_plugin(&self) -> builder::ReloadPlugin<'_>;
}
impl ClientPluginsExt for Client {
    fn list_format_handlers(&self) -> builder::ListFormatHandlers<'_> {
        builder::ListFormatHandlers::new(self)
    }
    fn get_format_handler(&self) -> builder::GetFormatHandler<'_> {
        builder::GetFormatHandler::new(self)
    }
    fn disable_format_handler(&self) -> builder::DisableFormatHandler<'_> {
        builder::DisableFormatHandler::new(self)
    }
    fn enable_format_handler(&self) -> builder::EnableFormatHandler<'_> {
        builder::EnableFormatHandler::new(self)
    }
    fn test_format_handler(&self) -> builder::TestFormatHandler<'_> {
        builder::TestFormatHandler::new(self)
    }
    fn list_plugins(&self) -> builder::ListPlugins<'_> {
        builder::ListPlugins::new(self)
    }
    fn install_from_git(&self) -> builder::InstallFromGit<'_> {
        builder::InstallFromGit::new(self)
    }
    fn install_from_local(&self) -> builder::InstallFromLocal<'_> {
        builder::InstallFromLocal::new(self)
    }
    fn get_plugin(&self) -> builder::GetPlugin<'_> {
        builder::GetPlugin::new(self)
    }
    fn uninstall_plugin(&self) -> builder::UninstallPlugin<'_> {
        builder::UninstallPlugin::new(self)
    }
    fn get_plugin_config(&self) -> builder::GetPluginConfig<'_> {
        builder::GetPluginConfig::new(self)
    }
    fn update_plugin_config(&self) -> builder::UpdatePluginConfig<'_> {
        builder::UpdatePluginConfig::new(self)
    }
    fn disable_plugin(&self) -> builder::DisablePlugin<'_> {
        builder::DisablePlugin::new(self)
    }
    fn enable_plugin(&self) -> builder::EnablePlugin<'_> {
        builder::EnablePlugin::new(self)
    }
    fn get_plugin_events(&self) -> builder::GetPluginEvents<'_> {
        builder::GetPluginEvents::new(self)
    }
    fn reload_plugin(&self) -> builder::ReloadPlugin<'_> {
        builder::ReloadPlugin::new(self)
    }
}
#[doc = "Staging-to-release artifact promotion"]
pub trait ClientPromotionExt {
    #[doc = "List all promotion rules\n\nSends a `GET` request to `/api/v1/promotion-rules`\n\n```ignore\nlet response = client.list_rules()\n    .source_repo_id(source_repo_id)\n    .send()\n    .await;\n```"]
    fn list_rules(&self) -> builder::ListRules<'_>;
    #[doc = "Create a promotion rule\n\nSends a `POST` request to `/api/v1/promotion-rules`\n\n```ignore\nlet response = client.create_rule()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_rule(&self) -> builder::CreateRule<'_>;
    #[doc = "Get a promotion rule by ID\n\nSends a `GET` request to `/api/v1/promotion-rules/{id}`\n\nArguments:\n- `id`: Promotion rule ID\n```ignore\nlet response = client.get_rule()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_rule(&self) -> builder::GetRule<'_>;
    #[doc = "Update a promotion rule\n\nSends a `PUT` request to `/api/v1/promotion-rules/{id}`\n\nArguments:\n- `id`: Promotion rule ID\n- `body`\n```ignore\nlet response = client.update_rule()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_rule(&self) -> builder::UpdateRule<'_>;
    #[doc = "Delete a promotion rule\n\nSends a `DELETE` request to `/api/v1/promotion-rules/{id}`\n\nArguments:\n- `id`: Promotion rule ID\n```ignore\nlet response = client.delete_rule()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_rule(&self) -> builder::DeleteRule<'_>;
    #[doc = "Dry-run evaluate a rule against all artifacts in its source repository\n\nSends a `POST` request to `/api/v1/promotion-rules/{id}/evaluate`\n\nArguments:\n- `id`: Promotion rule ID to evaluate\n```ignore\nlet response = client.evaluate_rule()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn evaluate_rule(&self) -> builder::EvaluateRule<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/promotion/repositories/{key}/artifacts/{artifact_id}/promote`\n\nArguments:\n- `key`: Source repository key\n- `artifact_id`: Artifact ID to promote\n- `body`\n```ignore\nlet response = client.promote_artifact()\n    .key(key)\n    .artifact_id(artifact_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn promote_artifact(&self) -> builder::PromoteArtifact<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/promotion/repositories/{key}/artifacts/{artifact_id}/reject`\n\nArguments:\n- `key`: Source repository key\n- `artifact_id`: Artifact ID to reject\n- `body`\n```ignore\nlet response = client.reject_artifact()\n    .key(key)\n    .artifact_id(artifact_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn reject_artifact(&self) -> builder::RejectArtifact<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/promotion/repositories/{key}/promote`\n\nArguments:\n- `key`: Source repository key\n- `body`\n```ignore\nlet response = client.promote_artifacts_bulk()\n    .key(key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn promote_artifacts_bulk(&self) -> builder::PromoteArtifactsBulk<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/promotion/repositories/{key}/promotion-history`\n\nArguments:\n- `key`: Repository key\n- `artifact_id`: Filter by artifact ID\n- `page`: Page number (1-indexed)\n- `per_page`: Items per page (max 100)\n- `status`: Filter by status (promoted, rejected, pending_approval)\n```ignore\nlet response = client.promotion_history()\n    .key(key)\n    .artifact_id(artifact_id)\n    .page(page)\n    .per_page(per_page)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn promotion_history(&self) -> builder::PromotionHistory<'_>;
}
impl ClientPromotionExt for Client {
    fn list_rules(&self) -> builder::ListRules<'_> {
        builder::ListRules::new(self)
    }
    fn create_rule(&self) -> builder::CreateRule<'_> {
        builder::CreateRule::new(self)
    }
    fn get_rule(&self) -> builder::GetRule<'_> {
        builder::GetRule::new(self)
    }
    fn update_rule(&self) -> builder::UpdateRule<'_> {
        builder::UpdateRule::new(self)
    }
    fn delete_rule(&self) -> builder::DeleteRule<'_> {
        builder::DeleteRule::new(self)
    }
    fn evaluate_rule(&self) -> builder::EvaluateRule<'_> {
        builder::EvaluateRule::new(self)
    }
    fn promote_artifact(&self) -> builder::PromoteArtifact<'_> {
        builder::PromoteArtifact::new(self)
    }
    fn reject_artifact(&self) -> builder::RejectArtifact<'_> {
        builder::RejectArtifact::new(self)
    }
    fn promote_artifacts_bulk(&self) -> builder::PromoteArtifactsBulk<'_> {
        builder::PromoteArtifactsBulk::new(self)
    }
    fn promotion_history(&self) -> builder::PromotionHistory<'_> {
        builder::PromotionHistory::new(self)
    }
}
#[doc = "Artifact health scoring and quality gates"]
pub trait ClientQualityExt {
    #[doc = "Sends a `GET` request to `/api/v1/quality/checks`\n\n```ignore\nlet response = client.list_checks()\n    .artifact_id(artifact_id)\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn list_checks(&self) -> builder::ListChecks<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/quality/checks/trigger`\n\n```ignore\nlet response = client.trigger_checks()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn trigger_checks(&self) -> builder::TriggerChecks<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/checks/{id}`\n\nArguments:\n- `id`: Check result ID\n```ignore\nlet response = client.get_check()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_check(&self) -> builder::GetCheck<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/checks/{id}/issues`\n\nArguments:\n- `id`: Check result ID\n```ignore\nlet response = client.list_check_issues()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn list_check_issues(&self) -> builder::ListCheckIssues<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/gates`\n\n```ignore\nlet response = client.list_gates()\n    .send()\n    .await;\n```"]
    fn list_gates(&self) -> builder::ListGates<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/quality/gates`\n\n```ignore\nlet response = client.create_gate()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_gate(&self) -> builder::CreateGate<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/quality/gates/evaluate/{artifact_id}`\n\nArguments:\n- `artifact_id`: Artifact ID to evaluate\n- `repository_id`\n```ignore\nlet response = client.evaluate_gate()\n    .artifact_id(artifact_id)\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn evaluate_gate(&self) -> builder::EvaluateGate<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/gates/{id}`\n\nArguments:\n- `id`: Quality gate ID\n```ignore\nlet response = client.get_gate()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_gate(&self) -> builder::GetGate<'_>;
    #[doc = "Sends a `PUT` request to `/api/v1/quality/gates/{id}`\n\nArguments:\n- `id`: Quality gate ID\n- `body`\n```ignore\nlet response = client.update_gate()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_gate(&self) -> builder::UpdateGate<'_>;
    #[doc = "Sends a `DELETE` request to `/api/v1/quality/gates/{id}`\n\nArguments:\n- `id`: Quality gate ID\n```ignore\nlet response = client.delete_gate()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_gate(&self) -> builder::DeleteGate<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/health/artifacts/{artifact_id}`\n\nArguments:\n- `artifact_id`: Artifact ID\n```ignore\nlet response = client.get_artifact_health()\n    .artifact_id(artifact_id)\n    .send()\n    .await;\n```"]
    fn get_artifact_health(&self) -> builder::GetArtifactHealth<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/health/dashboard`\n\n```ignore\nlet response = client.get_health_dashboard()\n    .send()\n    .await;\n```"]
    fn get_health_dashboard(&self) -> builder::GetHealthDashboard<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/quality/health/repositories/{key}`\n\nArguments:\n- `key`: Repository key\n```ignore\nlet response = client.get_repo_health()\n    .key(key)\n    .send()\n    .await;\n```"]
    fn get_repo_health(&self) -> builder::GetRepoHealth<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/quality/issues/{id}/suppress`\n\nArguments:\n- `id`: Issue ID\n- `body`\n```ignore\nlet response = client.suppress_issue()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn suppress_issue(&self) -> builder::SuppressIssue<'_>;
    #[doc = "Sends a `DELETE` request to `/api/v1/quality/issues/{id}/suppress`\n\nArguments:\n- `id`: Issue ID\n```ignore\nlet response = client.unsuppress_issue()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn unsuppress_issue(&self) -> builder::UnsuppressIssue<'_>;
}
impl ClientQualityExt for Client {
    fn list_checks(&self) -> builder::ListChecks<'_> {
        builder::ListChecks::new(self)
    }
    fn trigger_checks(&self) -> builder::TriggerChecks<'_> {
        builder::TriggerChecks::new(self)
    }
    fn get_check(&self) -> builder::GetCheck<'_> {
        builder::GetCheck::new(self)
    }
    fn list_check_issues(&self) -> builder::ListCheckIssues<'_> {
        builder::ListCheckIssues::new(self)
    }
    fn list_gates(&self) -> builder::ListGates<'_> {
        builder::ListGates::new(self)
    }
    fn create_gate(&self) -> builder::CreateGate<'_> {
        builder::CreateGate::new(self)
    }
    fn evaluate_gate(&self) -> builder::EvaluateGate<'_> {
        builder::EvaluateGate::new(self)
    }
    fn get_gate(&self) -> builder::GetGate<'_> {
        builder::GetGate::new(self)
    }
    fn update_gate(&self) -> builder::UpdateGate<'_> {
        builder::UpdateGate::new(self)
    }
    fn delete_gate(&self) -> builder::DeleteGate<'_> {
        builder::DeleteGate::new(self)
    }
    fn get_artifact_health(&self) -> builder::GetArtifactHealth<'_> {
        builder::GetArtifactHealth::new(self)
    }
    fn get_health_dashboard(&self) -> builder::GetHealthDashboard<'_> {
        builder::GetHealthDashboard::new(self)
    }
    fn get_repo_health(&self) -> builder::GetRepoHealth<'_> {
        builder::GetRepoHealth::new(self)
    }
    fn suppress_issue(&self) -> builder::SuppressIssue<'_> {
        builder::SuppressIssue::new(self)
    }
    fn unsuppress_issue(&self) -> builder::UnsuppressIssue<'_> {
        builder::UnsuppressIssue::new(self)
    }
}
#[doc = "Repository CRUD and artifact operations"]
pub trait ClientRepositoriesExt {
    #[doc = "List repositories\n\nSends a `GET` request to `/api/v1/repositories`\n\n```ignore\nlet response = client.list_repositories()\n    .format(format)\n    .page(page)\n    .per_page(per_page)\n    .q(q)\n    .type_(type_)\n    .send()\n    .await;\n```"]
    fn list_repositories(&self) -> builder::ListRepositories<'_>;
    #[doc = "Create a new repository\n\nSends a `POST` request to `/api/v1/repositories`\n\n```ignore\nlet response = client.create_repository()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_repository(&self) -> builder::CreateRepository<'_>;
    #[doc = "Get repository details\n\nSends a `GET` request to `/api/v1/repositories/{key}`\n\nArguments:\n- `key`: Repository key\n```ignore\nlet response = client.get_repository()\n    .key(key)\n    .send()\n    .await;\n```"]
    fn get_repository(&self) -> builder::GetRepository<'_>;
    #[doc = "Delete repository\n\nSends a `DELETE` request to `/api/v1/repositories/{key}`\n\nArguments:\n- `key`: Repository key\n```ignore\nlet response = client.delete_repository()\n    .key(key)\n    .send()\n    .await;\n```"]
    fn delete_repository(&self) -> builder::DeleteRepository<'_>;
    #[doc = "Update repository\n\nSends a `PATCH` request to `/api/v1/repositories/{key}`\n\nArguments:\n- `key`: Repository key\n- `body`\n```ignore\nlet response = client.update_repository()\n    .key(key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_repository(&self) -> builder::UpdateRepository<'_>;
    #[doc = "List artifacts in repository\n\nSends a `GET` request to `/api/v1/repositories/{key}/artifacts`\n\nArguments:\n- `key`: Repository key\n- `page`\n- `path_prefix`\n- `per_page`\n- `q`\n```ignore\nlet response = client.list_artifacts()\n    .key(key)\n    .page(page)\n    .path_prefix(path_prefix)\n    .per_page(per_page)\n    .q(q)\n    .send()\n    .await;\n```"]
    fn list_artifacts(&self) -> builder::ListArtifacts<'_>;
    #[doc = "Get artifact metadata\n\nSends a `GET` request to `/api/v1/repositories/{key}/artifacts/{path}`\n\nArguments:\n- `key`: Repository key\n- `path`: Artifact path\n```ignore\nlet response = client.get_repository_artifact_metadata()\n    .key(key)\n    .path(path)\n    .send()\n    .await;\n```"]
    fn get_repository_artifact_metadata(&self) -> builder::GetRepositoryArtifactMetadata<'_>;
    #[doc = "Upload artifact\n\nSends a `PUT` request to `/api/v1/repositories/{key}/artifacts/{path}`\n\nArguments:\n- `key`: Repository key\n- `path`: Artifact path\n- `body`\n```ignore\nlet response = client.upload_artifact()\n    .key(key)\n    .path(path)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn upload_artifact(&self) -> builder::UploadArtifact<'_>;
    #[doc = "Delete artifact\n\nSends a `DELETE` request to `/api/v1/repositories/{key}/artifacts/{path}`\n\nArguments:\n- `key`: Repository key\n- `path`: Artifact path\n```ignore\nlet response = client.delete_artifact()\n    .key(key)\n    .path(path)\n    .send()\n    .await;\n```"]
    fn delete_artifact(&self) -> builder::DeleteArtifact<'_>;
    #[doc = "Download artifact\n\nSends a `GET` request to `/api/v1/repositories/{key}/download/{path}`\n\nArguments:\n- `key`: Repository key\n- `path`: Artifact path\n```ignore\nlet response = client.download_artifact()\n    .key(key)\n    .path(path)\n    .send()\n    .await;\n```"]
    fn download_artifact(&self) -> builder::DownloadArtifact<'_>;
    #[doc = "List virtual repository members\n\nSends a `GET` request to `/api/v1/repositories/{key}/members`\n\nArguments:\n- `key`: Repository key\n```ignore\nlet response = client.list_virtual_members()\n    .key(key)\n    .send()\n    .await;\n```"]
    fn list_virtual_members(&self) -> builder::ListVirtualMembers<'_>;
    #[doc = "Update priorities for all members (bulk reorder)\n\nSends a `PUT` request to `/api/v1/repositories/{key}/members`\n\nArguments:\n- `key`: Repository key\n- `body`\n```ignore\nlet response = client.update_virtual_members()\n    .key(key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_virtual_members(&self) -> builder::UpdateVirtualMembers<'_>;
    #[doc = "Add a member to a virtual repository\n\nSends a `POST` request to `/api/v1/repositories/{key}/members`\n\nArguments:\n- `key`: Repository key\n- `body`\n```ignore\nlet response = client.add_virtual_member()\n    .key(key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn add_virtual_member(&self) -> builder::AddVirtualMember<'_>;
    #[doc = "Remove a member from a virtual repository\n\nSends a `DELETE` request to `/api/v1/repositories/{key}/members/{member_key}`\n\nArguments:\n- `key`: Repository key\n- `member_key`: Member repository key\n```ignore\nlet response = client.remove_virtual_member()\n    .key(key)\n    .member_key(member_key)\n    .send()\n    .await;\n```"]
    fn remove_virtual_member(&self) -> builder::RemoveVirtualMember<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/tree`\n\nArguments:\n- `include_metadata`: Whether to include metadata in the response\n- `path`: Path prefix to browse within the repository\n- `repository_key`: Repository key to browse\n```ignore\nlet response = client.get_tree()\n    .include_metadata(include_metadata)\n    .path(path)\n    .repository_key(repository_key)\n    .send()\n    .await;\n```"]
    fn get_tree(&self) -> builder::GetTree<'_>;
}
impl ClientRepositoriesExt for Client {
    fn list_repositories(&self) -> builder::ListRepositories<'_> {
        builder::ListRepositories::new(self)
    }
    fn create_repository(&self) -> builder::CreateRepository<'_> {
        builder::CreateRepository::new(self)
    }
    fn get_repository(&self) -> builder::GetRepository<'_> {
        builder::GetRepository::new(self)
    }
    fn delete_repository(&self) -> builder::DeleteRepository<'_> {
        builder::DeleteRepository::new(self)
    }
    fn update_repository(&self) -> builder::UpdateRepository<'_> {
        builder::UpdateRepository::new(self)
    }
    fn list_artifacts(&self) -> builder::ListArtifacts<'_> {
        builder::ListArtifacts::new(self)
    }
    fn get_repository_artifact_metadata(&self) -> builder::GetRepositoryArtifactMetadata<'_> {
        builder::GetRepositoryArtifactMetadata::new(self)
    }
    fn upload_artifact(&self) -> builder::UploadArtifact<'_> {
        builder::UploadArtifact::new(self)
    }
    fn delete_artifact(&self) -> builder::DeleteArtifact<'_> {
        builder::DeleteArtifact::new(self)
    }
    fn download_artifact(&self) -> builder::DownloadArtifact<'_> {
        builder::DownloadArtifact::new(self)
    }
    fn list_virtual_members(&self) -> builder::ListVirtualMembers<'_> {
        builder::ListVirtualMembers::new(self)
    }
    fn update_virtual_members(&self) -> builder::UpdateVirtualMembers<'_> {
        builder::UpdateVirtualMembers::new(self)
    }
    fn add_virtual_member(&self) -> builder::AddVirtualMember<'_> {
        builder::AddVirtualMember::new(self)
    }
    fn remove_virtual_member(&self) -> builder::RemoveVirtualMember<'_> {
        builder::RemoveVirtualMember::new(self)
    }
    fn get_tree(&self) -> builder::GetTree<'_> {
        builder::GetTree::new(self)
    }
}
#[doc = "Repository label management"]
pub trait ClientRepositoryLabelsExt {
    #[doc = "List all labels on a repository\n\nSends a `GET` request to `/api/v1/repositories/{key}/labels`\n\nArguments:\n- `key`: Repository key\n```ignore\nlet response = client.list_repo_labels()\n    .key(key)\n    .send()\n    .await;\n```"]
    fn list_repo_labels(&self) -> builder::ListRepoLabels<'_>;
    #[doc = "Set all labels on a repository (replaces existing)\n\nSends a `PUT` request to `/api/v1/repositories/{key}/labels`\n\nArguments:\n- `key`: Repository key\n- `body`\n```ignore\nlet response = client.set_repo_labels()\n    .key(key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn set_repo_labels(&self) -> builder::SetRepoLabels<'_>;
    #[doc = "Add or update a single label\n\nSends a `POST` request to `/api/v1/repositories/{key}/labels/{label_key}`\n\nArguments:\n- `key`: Repository key\n- `label_key`: Label key to set\n- `body`\n```ignore\nlet response = client.add_repo_label()\n    .key(key)\n    .label_key(label_key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn add_repo_label(&self) -> builder::AddRepoLabel<'_>;
    #[doc = "Delete a label by key\n\nSends a `DELETE` request to `/api/v1/repositories/{key}/labels/{label_key}`\n\nArguments:\n- `key`: Repository key\n- `label_key`: Label key to remove\n```ignore\nlet response = client.delete_repo_label()\n    .key(key)\n    .label_key(label_key)\n    .send()\n    .await;\n```"]
    fn delete_repo_label(&self) -> builder::DeleteRepoLabel<'_>;
}
impl ClientRepositoryLabelsExt for Client {
    fn list_repo_labels(&self) -> builder::ListRepoLabels<'_> {
        builder::ListRepoLabels::new(self)
    }
    fn set_repo_labels(&self) -> builder::SetRepoLabels<'_> {
        builder::SetRepoLabels::new(self)
    }
    fn add_repo_label(&self) -> builder::AddRepoLabel<'_> {
        builder::AddRepoLabel::new(self)
    }
    fn delete_repo_label(&self) -> builder::DeleteRepoLabel<'_> {
        builder::DeleteRepoLabel::new(self)
    }
}
#[doc = "Software Bill of Materials"]
pub trait ClientSbomExt {
    #[doc = "List SBOMs with optional filters\n\nSends a `GET` request to `/api/v1/sbom`\n\n```ignore\nlet response = client.list_sboms()\n    .artifact_id(artifact_id)\n    .format(format)\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn list_sboms(&self) -> builder::ListSboms<'_>;
    #[doc = "Generate an SBOM for an artifact\n\nSends a `POST` request to `/api/v1/sbom`\n\n```ignore\nlet response = client.generate_sbom()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn generate_sbom(&self) -> builder::GenerateSbom<'_>;
    #[doc = "Get SBOM by artifact ID\n\nSends a `GET` request to `/api/v1/sbom/by-artifact/{artifact_id}`\n\nArguments:\n- `artifact_id`: Artifact ID\n```ignore\nlet response = client.get_sbom_by_artifact()\n    .artifact_id(artifact_id)\n    .send()\n    .await;\n```"]
    fn get_sbom_by_artifact(&self) -> builder::GetSbomByArtifact<'_>;
    #[doc = "Check license compliance against policies\n\nSends a `POST` request to `/api/v1/sbom/check-compliance`\n\n```ignore\nlet response = client.check_license_compliance()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn check_license_compliance(&self) -> builder::CheckLicenseCompliance<'_>;
    #[doc = "Get CVE history for an artifact\n\nSends a `GET` request to `/api/v1/sbom/cve/history/{artifact_id}`\n\nArguments:\n- `artifact_id`: Artifact ID\n```ignore\nlet response = client.get_cve_history()\n    .artifact_id(artifact_id)\n    .send()\n    .await;\n```"]
    fn get_cve_history(&self) -> builder::GetCveHistory<'_>;
    #[doc = "Update CVE status\n\nSends a `POST` request to `/api/v1/sbom/cve/status/{id}`\n\nArguments:\n- `id`: CVE history entry ID\n- `body`\n```ignore\nlet response = client.update_cve_status()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_cve_status(&self) -> builder::UpdateCveStatus<'_>;
    #[doc = "Get CVE trends and statistics\n\nSends a `GET` request to `/api/v1/sbom/cve/trends`\n\n```ignore\nlet response = client.get_cve_trends()\n    .days(days)\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn get_cve_trends(&self) -> builder::GetCveTrends<'_>;
    #[doc = "List all license policies\n\nSends a `GET` request to `/api/v1/sbom/license-policies`\n\n```ignore\nlet response = client.list_license_policies()\n    .send()\n    .await;\n```"]
    fn list_license_policies(&self) -> builder::ListLicensePolicies<'_>;
    #[doc = "Create or update a license policy\n\nSends a `POST` request to `/api/v1/sbom/license-policies`\n\n```ignore\nlet response = client.upsert_license_policy()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn upsert_license_policy(&self) -> builder::UpsertLicensePolicy<'_>;
    #[doc = "Get a license policy by ID\n\nSends a `GET` request to `/api/v1/sbom/license-policies/{id}`\n\nArguments:\n- `id`: License policy ID\n```ignore\nlet response = client.get_license_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_license_policy(&self) -> builder::GetLicensePolicy<'_>;
    #[doc = "Delete a license policy\n\nSends a `DELETE` request to `/api/v1/sbom/license-policies/{id}`\n\nArguments:\n- `id`: License policy ID\n```ignore\nlet response = client.delete_license_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_license_policy(&self) -> builder::DeleteLicensePolicy<'_>;
    #[doc = "Get SBOM by ID with full content\n\nSends a `GET` request to `/api/v1/sbom/{id}`\n\nArguments:\n- `id`: SBOM ID\n```ignore\nlet response = client.get_sbom()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_sbom(&self) -> builder::GetSbom<'_>;
    #[doc = "Delete an SBOM\n\nSends a `DELETE` request to `/api/v1/sbom/{id}`\n\nArguments:\n- `id`: SBOM ID\n```ignore\nlet response = client.delete_sbom()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_sbom(&self) -> builder::DeleteSbom<'_>;
    #[doc = "Get components of an SBOM\n\nSends a `GET` request to `/api/v1/sbom/{id}/components`\n\nArguments:\n- `id`: SBOM ID\n```ignore\nlet response = client.get_sbom_components()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_sbom_components(&self) -> builder::GetSbomComponents<'_>;
    #[doc = "Convert an SBOM to a different format\n\nSends a `POST` request to `/api/v1/sbom/{id}/convert`\n\nArguments:\n- `id`: SBOM ID\n- `body`\n```ignore\nlet response = client.convert_sbom()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn convert_sbom(&self) -> builder::ConvertSbom<'_>;
}
impl ClientSbomExt for Client {
    fn list_sboms(&self) -> builder::ListSboms<'_> {
        builder::ListSboms::new(self)
    }
    fn generate_sbom(&self) -> builder::GenerateSbom<'_> {
        builder::GenerateSbom::new(self)
    }
    fn get_sbom_by_artifact(&self) -> builder::GetSbomByArtifact<'_> {
        builder::GetSbomByArtifact::new(self)
    }
    fn check_license_compliance(&self) -> builder::CheckLicenseCompliance<'_> {
        builder::CheckLicenseCompliance::new(self)
    }
    fn get_cve_history(&self) -> builder::GetCveHistory<'_> {
        builder::GetCveHistory::new(self)
    }
    fn update_cve_status(&self) -> builder::UpdateCveStatus<'_> {
        builder::UpdateCveStatus::new(self)
    }
    fn get_cve_trends(&self) -> builder::GetCveTrends<'_> {
        builder::GetCveTrends::new(self)
    }
    fn list_license_policies(&self) -> builder::ListLicensePolicies<'_> {
        builder::ListLicensePolicies::new(self)
    }
    fn upsert_license_policy(&self) -> builder::UpsertLicensePolicy<'_> {
        builder::UpsertLicensePolicy::new(self)
    }
    fn get_license_policy(&self) -> builder::GetLicensePolicy<'_> {
        builder::GetLicensePolicy::new(self)
    }
    fn delete_license_policy(&self) -> builder::DeleteLicensePolicy<'_> {
        builder::DeleteLicensePolicy::new(self)
    }
    fn get_sbom(&self) -> builder::GetSbom<'_> {
        builder::GetSbom::new(self)
    }
    fn delete_sbom(&self) -> builder::DeleteSbom<'_> {
        builder::DeleteSbom::new(self)
    }
    fn get_sbom_components(&self) -> builder::GetSbomComponents<'_> {
        builder::GetSbomComponents::new(self)
    }
    fn convert_sbom(&self) -> builder::ConvertSbom<'_> {
        builder::ConvertSbom::new(self)
    }
}
#[doc = "Full-text search and filtering"]
pub trait ClientSearchExt {
    #[doc = "Sends a `GET` request to `/api/v1/search/advanced`\n\n```ignore\nlet response = client.advanced_search()\n    .created_after(created_after)\n    .created_before(created_before)\n    .format(format)\n    .max_size(max_size)\n    .min_size(min_size)\n    .name(name)\n    .page(page)\n    .path(path)\n    .per_page(per_page)\n    .query(query)\n    .repository_key(repository_key)\n    .sort_by(sort_by)\n    .sort_order(sort_order)\n    .version(version)\n    .send()\n    .await;\n```"]
    fn advanced_search(&self) -> builder::AdvancedSearch<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/search/checksum`\n\n```ignore\nlet response = client.checksum_search()\n    .algorithm(algorithm)\n    .checksum(checksum)\n    .send()\n    .await;\n```"]
    fn checksum_search(&self) -> builder::ChecksumSearch<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/search/quick`\n\n```ignore\nlet response = client.quick_search()\n    .limit(limit)\n    .q(q)\n    .types(types)\n    .send()\n    .await;\n```"]
    fn quick_search(&self) -> builder::QuickSearch<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/search/recent`\n\n```ignore\nlet response = client.recent()\n    .limit(limit)\n    .send()\n    .await;\n```"]
    fn recent(&self) -> builder::Recent<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/search/suggest`\n\n```ignore\nlet response = client.suggest()\n    .limit(limit)\n    .prefix(prefix)\n    .send()\n    .await;\n```"]
    fn suggest(&self) -> builder::Suggest<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/search/trending`\n\n```ignore\nlet response = client.trending()\n    .days(days)\n    .limit(limit)\n    .send()\n    .await;\n```"]
    fn trending(&self) -> builder::Trending<'_>;
}
impl ClientSearchExt for Client {
    fn advanced_search(&self) -> builder::AdvancedSearch<'_> {
        builder::AdvancedSearch::new(self)
    }
    fn checksum_search(&self) -> builder::ChecksumSearch<'_> {
        builder::ChecksumSearch::new(self)
    }
    fn quick_search(&self) -> builder::QuickSearch<'_> {
        builder::QuickSearch::new(self)
    }
    fn recent(&self) -> builder::Recent<'_> {
        builder::Recent::new(self)
    }
    fn suggest(&self) -> builder::Suggest<'_> {
        builder::Suggest::new(self)
    }
    fn trending(&self) -> builder::Trending<'_> {
        builder::Trending::new(self)
    }
}
#[doc = "Security policies and scanning"]
pub trait ClientSecurityExt {
    #[doc = "Update analysis (triage) for a finding\n\nSends a `PUT` request to `/api/v1/dependency-track/analysis`\n\n```ignore\nlet response = client.update_analysis()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_analysis(&self) -> builder::UpdateAnalysis<'_>;
    #[doc = "Get portfolio-level metrics\n\nSends a `GET` request to `/api/v1/dependency-track/metrics/portfolio`\n\n```ignore\nlet response = client.get_portfolio_metrics()\n    .send()\n    .await;\n```"]
    fn get_portfolio_metrics(&self) -> builder::GetPortfolioMetrics<'_>;
    #[doc = "List all policies\n\nSends a `GET` request to `/api/v1/dependency-track/policies`\n\n```ignore\nlet response = client.list_dependency_track_policies()\n    .send()\n    .await;\n```"]
    fn list_dependency_track_policies(&self) -> builder::ListDependencyTrackPolicies<'_>;
    #[doc = "List all Dependency-Track projects\n\nSends a `GET` request to `/api/v1/dependency-track/projects`\n\n```ignore\nlet response = client.list_projects()\n    .send()\n    .await;\n```"]
    fn list_projects(&self) -> builder::ListProjects<'_>;
    #[doc = "Get project findings by project UUID\n\nSends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}`\n\nArguments:\n- `project_uuid`: Project UUID\n```ignore\nlet response = client.get_project()\n    .project_uuid(project_uuid)\n    .send()\n    .await;\n```"]
    fn get_project(&self) -> builder::GetProject<'_>;
    #[doc = "Get components for a project\n\nSends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/components`\n\nArguments:\n- `project_uuid`: Project UUID\n```ignore\nlet response = client.get_project_components()\n    .project_uuid(project_uuid)\n    .send()\n    .await;\n```"]
    fn get_project_components(&self) -> builder::GetProjectComponents<'_>;
    #[doc = "Get vulnerability findings for a project\n\nSends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/findings`\n\nArguments:\n- `project_uuid`: Project UUID\n```ignore\nlet response = client.get_project_findings()\n    .project_uuid(project_uuid)\n    .send()\n    .await;\n```"]
    fn get_project_findings(&self) -> builder::GetProjectFindings<'_>;
    #[doc = "Get metrics for a project\n\nSends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/metrics`\n\nArguments:\n- `project_uuid`: Project UUID\n```ignore\nlet response = client.get_project_metrics()\n    .project_uuid(project_uuid)\n    .send()\n    .await;\n```"]
    fn get_project_metrics(&self) -> builder::GetProjectMetrics<'_>;
    #[doc = "Get metrics history for a project\n\nSends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/metrics/history`\n\nArguments:\n- `project_uuid`: Project UUID\n- `days`\n```ignore\nlet response = client.get_project_metrics_history()\n    .project_uuid(project_uuid)\n    .days(days)\n    .send()\n    .await;\n```"]
    fn get_project_metrics_history(&self) -> builder::GetProjectMetricsHistory<'_>;
    #[doc = "Get policy violations for a project\n\nSends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/violations`\n\nArguments:\n- `project_uuid`: Project UUID\n```ignore\nlet response = client.get_project_violations()\n    .project_uuid(project_uuid)\n    .send()\n    .await;\n```"]
    fn get_project_violations(&self) -> builder::GetProjectViolations<'_>;
    #[doc = "Get Dependency-Track integration status\n\nSends a `GET` request to `/api/v1/dependency-track/status`\n\n```ignore\nlet response = client.dt_status()\n    .send()\n    .await;\n```"]
    fn dt_status(&self) -> builder::DtStatus<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/security`\n\nArguments:\n- `key`: Repository key\n```ignore\nlet response = client.get_repo_security()\n    .key(key)\n    .send()\n    .await;\n```"]
    fn get_repo_security(&self) -> builder::GetRepoSecurity<'_>;
    #[doc = "Sends a `PUT` request to `/api/v1/repositories/{key}/security`\n\nArguments:\n- `key`: Repository key\n- `body`\n```ignore\nlet response = client.update_repo_security()\n    .key(key)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_repo_security(&self) -> builder::UpdateRepoSecurity<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/security/scans`\n\nArguments:\n- `key`: Repository key\n- `artifact_id`\n- `page`\n- `per_page`\n- `repository_id`\n- `status`\n```ignore\nlet response = client.list_repo_scans()\n    .key(key)\n    .artifact_id(artifact_id)\n    .page(page)\n    .per_page(per_page)\n    .repository_id(repository_id)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_repo_scans(&self) -> builder::ListRepoScans<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/artifacts/{artifact_id}/scans`\n\nArguments:\n- `artifact_id`: Artifact ID\n- `page`: Page number (default: 1)\n- `per_page`: Items per page (default: 20, max: 100)\n- `status`: Filter by scan status\n```ignore\nlet response = client.list_artifact_scans()\n    .artifact_id(artifact_id)\n    .page(page)\n    .per_page(per_page)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_artifact_scans(&self) -> builder::ListArtifactScans<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/configs`\n\n```ignore\nlet response = client.list_scan_configs()\n    .send()\n    .await;\n```"]
    fn list_scan_configs(&self) -> builder::ListScanConfigs<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/dashboard`\n\n```ignore\nlet response = client.get_dashboard()\n    .send()\n    .await;\n```"]
    fn get_dashboard(&self) -> builder::GetDashboard<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/security/findings/{id}/acknowledge`\n\nArguments:\n- `id`: Finding ID\n- `body`\n```ignore\nlet response = client.acknowledge_finding()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn acknowledge_finding(&self) -> builder::AcknowledgeFinding<'_>;
    #[doc = "Sends a `DELETE` request to `/api/v1/security/findings/{id}/acknowledge`\n\nArguments:\n- `id`: Finding ID\n```ignore\nlet response = client.revoke_acknowledgment()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn revoke_acknowledgment(&self) -> builder::RevokeAcknowledgment<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/policies`\n\n```ignore\nlet response = client.list_policies()\n    .send()\n    .await;\n```"]
    fn list_policies(&self) -> builder::ListPolicies<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/security/policies`\n\n```ignore\nlet response = client.create_policy()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_policy(&self) -> builder::CreatePolicy<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/policies/{id}`\n\nArguments:\n- `id`: Policy ID\n```ignore\nlet response = client.get_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_policy(&self) -> builder::GetPolicy<'_>;
    #[doc = "Sends a `PUT` request to `/api/v1/security/policies/{id}`\n\nArguments:\n- `id`: Policy ID\n- `body`\n```ignore\nlet response = client.update_policy()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_policy(&self) -> builder::UpdatePolicy<'_>;
    #[doc = "Sends a `DELETE` request to `/api/v1/security/policies/{id}`\n\nArguments:\n- `id`: Policy ID\n```ignore\nlet response = client.delete_policy()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_policy(&self) -> builder::DeletePolicy<'_>;
    #[doc = "Sends a `POST` request to `/api/v1/security/scan`\n\n```ignore\nlet response = client.trigger_scan()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn trigger_scan(&self) -> builder::TriggerScan<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/scans`\n\n```ignore\nlet response = client.list_scans()\n    .artifact_id(artifact_id)\n    .page(page)\n    .per_page(per_page)\n    .repository_id(repository_id)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_scans(&self) -> builder::ListScans<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/scans/{id}`\n\nArguments:\n- `id`: Scan result ID\n```ignore\nlet response = client.get_scan()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_scan(&self) -> builder::GetScan<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/scans/{id}/findings`\n\nArguments:\n- `id`: Scan result ID\n- `page`\n- `per_page`\n```ignore\nlet response = client.list_findings()\n    .id(id)\n    .page(page)\n    .per_page(per_page)\n    .send()\n    .await;\n```"]
    fn list_findings(&self) -> builder::ListFindings<'_>;
    #[doc = "Sends a `GET` request to `/api/v1/security/scores`\n\n```ignore\nlet response = client.get_all_scores()\n    .send()\n    .await;\n```"]
    fn get_all_scores(&self) -> builder::GetAllScores<'_>;
}
impl ClientSecurityExt for Client {
    fn update_analysis(&self) -> builder::UpdateAnalysis<'_> {
        builder::UpdateAnalysis::new(self)
    }
    fn get_portfolio_metrics(&self) -> builder::GetPortfolioMetrics<'_> {
        builder::GetPortfolioMetrics::new(self)
    }
    fn list_dependency_track_policies(&self) -> builder::ListDependencyTrackPolicies<'_> {
        builder::ListDependencyTrackPolicies::new(self)
    }
    fn list_projects(&self) -> builder::ListProjects<'_> {
        builder::ListProjects::new(self)
    }
    fn get_project(&self) -> builder::GetProject<'_> {
        builder::GetProject::new(self)
    }
    fn get_project_components(&self) -> builder::GetProjectComponents<'_> {
        builder::GetProjectComponents::new(self)
    }
    fn get_project_findings(&self) -> builder::GetProjectFindings<'_> {
        builder::GetProjectFindings::new(self)
    }
    fn get_project_metrics(&self) -> builder::GetProjectMetrics<'_> {
        builder::GetProjectMetrics::new(self)
    }
    fn get_project_metrics_history(&self) -> builder::GetProjectMetricsHistory<'_> {
        builder::GetProjectMetricsHistory::new(self)
    }
    fn get_project_violations(&self) -> builder::GetProjectViolations<'_> {
        builder::GetProjectViolations::new(self)
    }
    fn dt_status(&self) -> builder::DtStatus<'_> {
        builder::DtStatus::new(self)
    }
    fn get_repo_security(&self) -> builder::GetRepoSecurity<'_> {
        builder::GetRepoSecurity::new(self)
    }
    fn update_repo_security(&self) -> builder::UpdateRepoSecurity<'_> {
        builder::UpdateRepoSecurity::new(self)
    }
    fn list_repo_scans(&self) -> builder::ListRepoScans<'_> {
        builder::ListRepoScans::new(self)
    }
    fn list_artifact_scans(&self) -> builder::ListArtifactScans<'_> {
        builder::ListArtifactScans::new(self)
    }
    fn list_scan_configs(&self) -> builder::ListScanConfigs<'_> {
        builder::ListScanConfigs::new(self)
    }
    fn get_dashboard(&self) -> builder::GetDashboard<'_> {
        builder::GetDashboard::new(self)
    }
    fn acknowledge_finding(&self) -> builder::AcknowledgeFinding<'_> {
        builder::AcknowledgeFinding::new(self)
    }
    fn revoke_acknowledgment(&self) -> builder::RevokeAcknowledgment<'_> {
        builder::RevokeAcknowledgment::new(self)
    }
    fn list_policies(&self) -> builder::ListPolicies<'_> {
        builder::ListPolicies::new(self)
    }
    fn create_policy(&self) -> builder::CreatePolicy<'_> {
        builder::CreatePolicy::new(self)
    }
    fn get_policy(&self) -> builder::GetPolicy<'_> {
        builder::GetPolicy::new(self)
    }
    fn update_policy(&self) -> builder::UpdatePolicy<'_> {
        builder::UpdatePolicy::new(self)
    }
    fn delete_policy(&self) -> builder::DeletePolicy<'_> {
        builder::DeletePolicy::new(self)
    }
    fn trigger_scan(&self) -> builder::TriggerScan<'_> {
        builder::TriggerScan::new(self)
    }
    fn list_scans(&self) -> builder::ListScans<'_> {
        builder::ListScans::new(self)
    }
    fn get_scan(&self) -> builder::GetScan<'_> {
        builder::GetScan::new(self)
    }
    fn list_findings(&self) -> builder::ListFindings<'_> {
        builder::ListFindings::new(self)
    }
    fn get_all_scores(&self) -> builder::GetAllScores<'_> {
        builder::GetAllScores::new(self)
    }
}
#[doc = "Signing key management"]
pub trait ClientSigningExt {
    #[doc = "List all signing keys, optionally filtered by repository\n\nSends a `GET` request to `/api/v1/signing/keys`\n\nArguments:\n- `repository_id`: Filter by repository ID\n```ignore\nlet response = client.list_keys()\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn list_keys(&self) -> builder::ListKeys<'_>;
    #[doc = "Create a new signing key\n\nSends a `POST` request to `/api/v1/signing/keys`\n\n```ignore\nlet response = client.create_key()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_key(&self) -> builder::CreateKey<'_>;
    #[doc = "Get a signing key by ID\n\nSends a `GET` request to `/api/v1/signing/keys/{key_id}`\n\nArguments:\n- `key_id`: Signing key ID\n```ignore\nlet response = client.get_key()\n    .key_id(key_id)\n    .send()\n    .await;\n```"]
    fn get_key(&self) -> builder::GetKey<'_>;
    #[doc = "Delete a signing key\n\nSends a `DELETE` request to `/api/v1/signing/keys/{key_id}`\n\nArguments:\n- `key_id`: Signing key ID\n```ignore\nlet response = client.delete_key()\n    .key_id(key_id)\n    .send()\n    .await;\n```"]
    fn delete_key(&self) -> builder::DeleteKey<'_>;
    #[doc = "Get the public key in PEM format (for client import)\n\nSends a `GET` request to `/api/v1/signing/keys/{key_id}/public`\n\nArguments:\n- `key_id`: Signing key ID\n```ignore\nlet response = client.get_public_key()\n    .key_id(key_id)\n    .send()\n    .await;\n```"]
    fn get_public_key(&self) -> builder::GetPublicKey<'_>;
    #[doc = "Revoke (deactivate) a signing key\n\nSends a `POST` request to `/api/v1/signing/keys/{key_id}/revoke`\n\nArguments:\n- `key_id`: Signing key ID\n```ignore\nlet response = client.revoke_key()\n    .key_id(key_id)\n    .send()\n    .await;\n```"]
    fn revoke_key(&self) -> builder::RevokeKey<'_>;
    #[doc = "Rotate a signing key  generates new key, deactivates old one\n\nSends a `POST` request to `/api/v1/signing/keys/{key_id}/rotate`\n\nArguments:\n- `key_id`: Signing key ID to rotate\n```ignore\nlet response = client.rotate_key()\n    .key_id(key_id)\n    .send()\n    .await;\n```"]
    fn rotate_key(&self) -> builder::RotateKey<'_>;
    #[doc = "Get signing configuration for a repository\n\nSends a `GET` request to `/api/v1/signing/repositories/{repo_id}/config`\n\nArguments:\n- `repo_id`: Repository ID\n```ignore\nlet response = client.get_repo_signing_config()\n    .repo_id(repo_id)\n    .send()\n    .await;\n```"]
    fn get_repo_signing_config(&self) -> builder::GetRepoSigningConfig<'_>;
    #[doc = "Update signing configuration for a repository\n\nSends a `POST` request to `/api/v1/signing/repositories/{repo_id}/config`\n\nArguments:\n- `repo_id`: Repository ID\n- `body`\n```ignore\nlet response = client.update_repo_signing_config()\n    .repo_id(repo_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_repo_signing_config(&self) -> builder::UpdateRepoSigningConfig<'_>;
    #[doc = "Get the public key for a repository (convenience endpoint)\n\nSends a `GET` request to `/api/v1/signing/repositories/{repo_id}/public-key`\n\nArguments:\n- `repo_id`: Repository ID\n```ignore\nlet response = client.get_repo_public_key()\n    .repo_id(repo_id)\n    .send()\n    .await;\n```"]
    fn get_repo_public_key(&self) -> builder::GetRepoPublicKey<'_>;
}
impl ClientSigningExt for Client {
    fn list_keys(&self) -> builder::ListKeys<'_> {
        builder::ListKeys::new(self)
    }
    fn create_key(&self) -> builder::CreateKey<'_> {
        builder::CreateKey::new(self)
    }
    fn get_key(&self) -> builder::GetKey<'_> {
        builder::GetKey::new(self)
    }
    fn delete_key(&self) -> builder::DeleteKey<'_> {
        builder::DeleteKey::new(self)
    }
    fn get_public_key(&self) -> builder::GetPublicKey<'_> {
        builder::GetPublicKey::new(self)
    }
    fn revoke_key(&self) -> builder::RevokeKey<'_> {
        builder::RevokeKey::new(self)
    }
    fn rotate_key(&self) -> builder::RotateKey<'_> {
        builder::RotateKey::new(self)
    }
    fn get_repo_signing_config(&self) -> builder::GetRepoSigningConfig<'_> {
        builder::GetRepoSigningConfig::new(self)
    }
    fn update_repo_signing_config(&self) -> builder::UpdateRepoSigningConfig<'_> {
        builder::UpdateRepoSigningConfig::new(self)
    }
    fn get_repo_public_key(&self) -> builder::GetRepoPublicKey<'_> {
        builder::GetRepoPublicKey::new(self)
    }
}
#[doc = "Single sign-on configuration"]
pub trait ClientSsoExt {
    #[doc = "List all LDAP provider configurations\n\nSends a `GET` request to `/api/v1/admin/sso/ldap`\n\n```ignore\nlet response = client.list_ldap()\n    .send()\n    .await;\n```"]
    fn list_ldap(&self) -> builder::ListLdap<'_>;
    #[doc = "Create a new LDAP provider configuration\n\nSends a `POST` request to `/api/v1/admin/sso/ldap`\n\n```ignore\nlet response = client.create_ldap()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_ldap(&self) -> builder::CreateLdap<'_>;
    #[doc = "Get LDAP provider configuration by ID\n\nSends a `GET` request to `/api/v1/admin/sso/ldap/{id}`\n\nArguments:\n- `id`: LDAP configuration ID\n```ignore\nlet response = client.get_ldap()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_ldap(&self) -> builder::GetLdap<'_>;
    #[doc = "Update an LDAP provider configuration\n\nSends a `PUT` request to `/api/v1/admin/sso/ldap/{id}`\n\nArguments:\n- `id`: LDAP configuration ID\n- `body`\n```ignore\nlet response = client.update_ldap()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_ldap(&self) -> builder::UpdateLdap<'_>;
    #[doc = "Delete an LDAP provider configuration\n\nSends a `DELETE` request to `/api/v1/admin/sso/ldap/{id}`\n\nArguments:\n- `id`: LDAP configuration ID\n```ignore\nlet response = client.delete_ldap()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_ldap(&self) -> builder::DeleteLdap<'_>;
    #[doc = "Test an LDAP provider connection\n\nSends a `POST` request to `/api/v1/admin/sso/ldap/{id}/test`\n\nArguments:\n- `id`: LDAP configuration ID\n```ignore\nlet response = client.test_ldap()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn test_ldap(&self) -> builder::TestLdap<'_>;
    #[doc = "Toggle an LDAP provider enabled/disabled\n\nSends a `PATCH` request to `/api/v1/admin/sso/ldap/{id}/toggle`\n\nArguments:\n- `id`: LDAP configuration ID\n- `body`\n```ignore\nlet response = client.toggle_ldap()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn toggle_ldap(&self) -> builder::ToggleLdap<'_>;
    #[doc = "List all OIDC provider configurations\n\nSends a `GET` request to `/api/v1/admin/sso/oidc`\n\n```ignore\nlet response = client.list_oidc()\n    .send()\n    .await;\n```"]
    fn list_oidc(&self) -> builder::ListOidc<'_>;
    #[doc = "Create a new OIDC provider configuration\n\nSends a `POST` request to `/api/v1/admin/sso/oidc`\n\n```ignore\nlet response = client.create_oidc()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_oidc(&self) -> builder::CreateOidc<'_>;
    #[doc = "Get OIDC provider configuration by ID\n\nSends a `GET` request to `/api/v1/admin/sso/oidc/{id}`\n\nArguments:\n- `id`: OIDC configuration ID\n```ignore\nlet response = client.get_oidc()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_oidc(&self) -> builder::GetOidc<'_>;
    #[doc = "Update an OIDC provider configuration\n\nSends a `PUT` request to `/api/v1/admin/sso/oidc/{id}`\n\nArguments:\n- `id`: OIDC configuration ID\n- `body`\n```ignore\nlet response = client.update_oidc()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_oidc(&self) -> builder::UpdateOidc<'_>;
    #[doc = "Delete an OIDC provider configuration\n\nSends a `DELETE` request to `/api/v1/admin/sso/oidc/{id}`\n\nArguments:\n- `id`: OIDC configuration ID\n```ignore\nlet response = client.delete_oidc()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_oidc(&self) -> builder::DeleteOidc<'_>;
    #[doc = "Toggle an OIDC provider enabled/disabled\n\nSends a `PATCH` request to `/api/v1/admin/sso/oidc/{id}/toggle`\n\nArguments:\n- `id`: OIDC configuration ID\n- `body`\n```ignore\nlet response = client.toggle_oidc()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn toggle_oidc(&self) -> builder::ToggleOidc<'_>;
    #[doc = "List all enabled SSO providers (admin view)\n\nSends a `GET` request to `/api/v1/admin/sso/providers`\n\n```ignore\nlet response = client.list_sso_providers_admin()\n    .send()\n    .await;\n```"]
    fn list_sso_providers_admin(&self) -> builder::ListSsoProvidersAdmin<'_>;
    #[doc = "List all SAML provider configurations\n\nSends a `GET` request to `/api/v1/admin/sso/saml`\n\n```ignore\nlet response = client.list_saml()\n    .send()\n    .await;\n```"]
    fn list_saml(&self) -> builder::ListSaml<'_>;
    #[doc = "Create a new SAML provider configuration\n\nSends a `POST` request to `/api/v1/admin/sso/saml`\n\n```ignore\nlet response = client.create_saml()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_saml(&self) -> builder::CreateSaml<'_>;
    #[doc = "Get SAML provider configuration by ID\n\nSends a `GET` request to `/api/v1/admin/sso/saml/{id}`\n\nArguments:\n- `id`: SAML configuration ID\n```ignore\nlet response = client.get_saml()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_saml(&self) -> builder::GetSaml<'_>;
    #[doc = "Update a SAML provider configuration\n\nSends a `PUT` request to `/api/v1/admin/sso/saml/{id}`\n\nArguments:\n- `id`: SAML configuration ID\n- `body`\n```ignore\nlet response = client.update_saml()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_saml(&self) -> builder::UpdateSaml<'_>;
    #[doc = "Delete a SAML provider configuration\n\nSends a `DELETE` request to `/api/v1/admin/sso/saml/{id}`\n\nArguments:\n- `id`: SAML configuration ID\n```ignore\nlet response = client.delete_saml()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_saml(&self) -> builder::DeleteSaml<'_>;
    #[doc = "Toggle a SAML provider enabled/disabled\n\nSends a `PATCH` request to `/api/v1/admin/sso/saml/{id}/toggle`\n\nArguments:\n- `id`: SAML configuration ID\n- `body`\n```ignore\nlet response = client.toggle_saml()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn toggle_saml(&self) -> builder::ToggleSaml<'_>;
    #[doc = "Exchange a short-lived code for access and refresh tokens\n\nSends a `POST` request to `/api/v1/auth/sso/exchange`\n\n```ignore\nlet response = client.exchange_code()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn exchange_code(&self) -> builder::ExchangeCode<'_>;
    #[doc = "Authenticate via LDAP\n\nSends a `POST` request to `/api/v1/auth/sso/ldap/{id}/login`\n\nArguments:\n- `id`: LDAP provider configuration ID\n- `body`\n```ignore\nlet response = client.ldap_login()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ldap_login(&self) -> builder::LdapLogin<'_>;
    #[doc = "Handle OIDC authorization callback\n\nSends a `GET` request to `/api/v1/auth/sso/oidc/{id}/callback`\n\nArguments:\n- `id`: OIDC provider configuration ID\n- `code`\n- `state`\n```ignore\nlet response = client.oidc_callback()\n    .id(id)\n    .code(code)\n    .state(state)\n    .send()\n    .await;\n```"]
    fn oidc_callback(&self) -> builder::OidcCallback<'_>;
    #[doc = "Initiate OIDC login redirect\n\nSends a `GET` request to `/api/v1/auth/sso/oidc/{id}/login`\n\nArguments:\n- `id`: OIDC provider configuration ID\n```ignore\nlet response = client.oidc_login()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn oidc_login(&self) -> builder::OidcLogin<'_>;
    #[doc = "List all enabled SSO providers\n\nSends a `GET` request to `/api/v1/auth/sso/providers`\n\n```ignore\nlet response = client.list_providers()\n    .send()\n    .await;\n```"]
    fn list_providers(&self) -> builder::ListProviders<'_>;
    #[doc = "Handle SAML Assertion Consumer Service (ACS) callback\n\nSends a `POST` request to `/api/v1/auth/sso/saml/{id}/acs`\n\nArguments:\n- `id`: SAML provider configuration ID\n- `body`\n```ignore\nlet response = client.saml_acs()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn saml_acs(&self) -> builder::SamlAcs<'_>;
    #[doc = "Initiate SAML login redirect\n\nSends a `GET` request to `/api/v1/auth/sso/saml/{id}/login`\n\nArguments:\n- `id`: SAML provider configuration ID\n```ignore\nlet response = client.saml_login()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn saml_login(&self) -> builder::SamlLogin<'_>;
}
impl ClientSsoExt for Client {
    fn list_ldap(&self) -> builder::ListLdap<'_> {
        builder::ListLdap::new(self)
    }
    fn create_ldap(&self) -> builder::CreateLdap<'_> {
        builder::CreateLdap::new(self)
    }
    fn get_ldap(&self) -> builder::GetLdap<'_> {
        builder::GetLdap::new(self)
    }
    fn update_ldap(&self) -> builder::UpdateLdap<'_> {
        builder::UpdateLdap::new(self)
    }
    fn delete_ldap(&self) -> builder::DeleteLdap<'_> {
        builder::DeleteLdap::new(self)
    }
    fn test_ldap(&self) -> builder::TestLdap<'_> {
        builder::TestLdap::new(self)
    }
    fn toggle_ldap(&self) -> builder::ToggleLdap<'_> {
        builder::ToggleLdap::new(self)
    }
    fn list_oidc(&self) -> builder::ListOidc<'_> {
        builder::ListOidc::new(self)
    }
    fn create_oidc(&self) -> builder::CreateOidc<'_> {
        builder::CreateOidc::new(self)
    }
    fn get_oidc(&self) -> builder::GetOidc<'_> {
        builder::GetOidc::new(self)
    }
    fn update_oidc(&self) -> builder::UpdateOidc<'_> {
        builder::UpdateOidc::new(self)
    }
    fn delete_oidc(&self) -> builder::DeleteOidc<'_> {
        builder::DeleteOidc::new(self)
    }
    fn toggle_oidc(&self) -> builder::ToggleOidc<'_> {
        builder::ToggleOidc::new(self)
    }
    fn list_sso_providers_admin(&self) -> builder::ListSsoProvidersAdmin<'_> {
        builder::ListSsoProvidersAdmin::new(self)
    }
    fn list_saml(&self) -> builder::ListSaml<'_> {
        builder::ListSaml::new(self)
    }
    fn create_saml(&self) -> builder::CreateSaml<'_> {
        builder::CreateSaml::new(self)
    }
    fn get_saml(&self) -> builder::GetSaml<'_> {
        builder::GetSaml::new(self)
    }
    fn update_saml(&self) -> builder::UpdateSaml<'_> {
        builder::UpdateSaml::new(self)
    }
    fn delete_saml(&self) -> builder::DeleteSaml<'_> {
        builder::DeleteSaml::new(self)
    }
    fn toggle_saml(&self) -> builder::ToggleSaml<'_> {
        builder::ToggleSaml::new(self)
    }
    fn exchange_code(&self) -> builder::ExchangeCode<'_> {
        builder::ExchangeCode::new(self)
    }
    fn ldap_login(&self) -> builder::LdapLogin<'_> {
        builder::LdapLogin::new(self)
    }
    fn oidc_callback(&self) -> builder::OidcCallback<'_> {
        builder::OidcCallback::new(self)
    }
    fn oidc_login(&self) -> builder::OidcLogin<'_> {
        builder::OidcLogin::new(self)
    }
    fn list_providers(&self) -> builder::ListProviders<'_> {
        builder::ListProviders::new(self)
    }
    fn saml_acs(&self) -> builder::SamlAcs<'_> {
        builder::SamlAcs::new(self)
    }
    fn saml_login(&self) -> builder::SamlLogin<'_> {
        builder::SamlLogin::new(self)
    }
}
#[doc = "Crash reporting and telemetry"]
pub trait ClientTelemetryExt {
    #[doc = "GET /api/v1/admin/telemetry/crashes\n\nSends a `GET` request to `/api/v1/admin/telemetry/crashes`\n\n```ignore\nlet response = client.list_crashes()\n    .page(page)\n    .per_page(per_page)\n    .send()\n    .await;\n```"]
    fn list_crashes(&self) -> builder::ListCrashes<'_>;
    #[doc = "GET /api/v1/admin/telemetry/crashes/pending\n\nSends a `GET` request to `/api/v1/admin/telemetry/crashes/pending`\n\n```ignore\nlet response = client.list_pending_crashes()\n    .send()\n    .await;\n```"]
    fn list_pending_crashes(&self) -> builder::ListPendingCrashes<'_>;
    #[doc = "POST /api/v1/admin/telemetry/crashes/submit\n\nSends a `POST` request to `/api/v1/admin/telemetry/crashes/submit`\n\n```ignore\nlet response = client.submit_crashes()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn submit_crashes(&self) -> builder::SubmitCrashes<'_>;
    #[doc = "GET /api/v1/admin/telemetry/crashes/:id\n\nSends a `GET` request to `/api/v1/admin/telemetry/crashes/{id}`\n\nArguments:\n- `id`: Crash report ID\n```ignore\nlet response = client.get_crash()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_crash(&self) -> builder::GetCrash<'_>;
    #[doc = "DELETE /api/v1/admin/telemetry/crashes/:id\n\nSends a `DELETE` request to `/api/v1/admin/telemetry/crashes/{id}`\n\nArguments:\n- `id`: Crash report ID\n```ignore\nlet response = client.delete_crash()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_crash(&self) -> builder::DeleteCrash<'_>;
    #[doc = "GET /api/v1/admin/telemetry/settings\n\nSends a `GET` request to `/api/v1/admin/telemetry/settings`\n\n```ignore\nlet response = client.get_telemetry_settings()\n    .send()\n    .await;\n```"]
    fn get_telemetry_settings(&self) -> builder::GetTelemetrySettings<'_>;
    #[doc = "POST /api/v1/admin/telemetry/settings\n\nSends a `POST` request to `/api/v1/admin/telemetry/settings`\n\n```ignore\nlet response = client.update_telemetry_settings()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_telemetry_settings(&self) -> builder::UpdateTelemetrySettings<'_>;
}
impl ClientTelemetryExt for Client {
    fn list_crashes(&self) -> builder::ListCrashes<'_> {
        builder::ListCrashes::new(self)
    }
    fn list_pending_crashes(&self) -> builder::ListPendingCrashes<'_> {
        builder::ListPendingCrashes::new(self)
    }
    fn submit_crashes(&self) -> builder::SubmitCrashes<'_> {
        builder::SubmitCrashes::new(self)
    }
    fn get_crash(&self) -> builder::GetCrash<'_> {
        builder::GetCrash::new(self)
    }
    fn delete_crash(&self) -> builder::DeleteCrash<'_> {
        builder::DeleteCrash::new(self)
    }
    fn get_telemetry_settings(&self) -> builder::GetTelemetrySettings<'_> {
        builder::GetTelemetrySettings::new(self)
    }
    fn update_telemetry_settings(&self) -> builder::UpdateTelemetrySettings<'_> {
        builder::UpdateTelemetrySettings::new(self)
    }
}
#[doc = "User management and API tokens"]
pub trait ClientUsersExt {
    #[doc = "List users\n\nSends a `GET` request to `/api/v1/users`\n\n```ignore\nlet response = client.list_users()\n    .is_active(is_active)\n    .is_admin(is_admin)\n    .page(page)\n    .per_page(per_page)\n    .search(search)\n    .send()\n    .await;\n```"]
    fn list_users(&self) -> builder::ListUsers<'_>;
    #[doc = "Create user\n\nSends a `POST` request to `/api/v1/users`\n\n```ignore\nlet response = client.create_user()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_user(&self) -> builder::CreateUser<'_>;
    #[doc = "Get user details\n\nSends a `GET` request to `/api/v1/users/{id}`\n\nArguments:\n- `id`: User ID\n```ignore\nlet response = client.get_user()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_user(&self) -> builder::GetUser<'_>;
    #[doc = "Delete user\n\nSends a `DELETE` request to `/api/v1/users/{id}`\n\nArguments:\n- `id`: User ID\n```ignore\nlet response = client.delete_user()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_user(&self) -> builder::DeleteUser<'_>;
    #[doc = "Update user\n\nSends a `PATCH` request to `/api/v1/users/{id}`\n\nArguments:\n- `id`: User ID\n- `body`\n```ignore\nlet response = client.update_user()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn update_user(&self) -> builder::UpdateUser<'_>;
    #[doc = "Change user password\n\nSends a `POST` request to `/api/v1/users/{id}/password`\n\nArguments:\n- `id`: User ID\n- `body`\n```ignore\nlet response = client.change_password()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn change_password(&self) -> builder::ChangePassword<'_>;
    #[doc = "Reset user password (admin only)\nGenerates a new temporary password and sets must_change_password=true\n\nSends a `POST` request to `/api/v1/users/{id}/password/reset`\n\nArguments:\n- `id`: User ID\n```ignore\nlet response = client.reset_password()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn reset_password(&self) -> builder::ResetPassword<'_>;
    #[doc = "Get user roles\n\nSends a `GET` request to `/api/v1/users/{id}/roles`\n\nArguments:\n- `id`: User ID\n```ignore\nlet response = client.get_user_roles()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_user_roles(&self) -> builder::GetUserRoles<'_>;
    #[doc = "Assign role to user\n\nSends a `POST` request to `/api/v1/users/{id}/roles`\n\nArguments:\n- `id`: User ID\n- `body`\n```ignore\nlet response = client.assign_role()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn assign_role(&self) -> builder::AssignRole<'_>;
    #[doc = "Revoke role from user\n\nSends a `DELETE` request to `/api/v1/users/{id}/roles/{role_id}`\n\nArguments:\n- `id`: User ID\n- `role_id`: Role ID\n```ignore\nlet response = client.revoke_role()\n    .id(id)\n    .role_id(role_id)\n    .send()\n    .await;\n```"]
    fn revoke_role(&self) -> builder::RevokeRole<'_>;
    #[doc = "List user's API tokens\n\nSends a `GET` request to `/api/v1/users/{id}/tokens`\n\nArguments:\n- `id`: User ID\n```ignore\nlet response = client.list_user_tokens()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn list_user_tokens(&self) -> builder::ListUserTokens<'_>;
    #[doc = "Create API token\n\nSends a `POST` request to `/api/v1/users/{id}/tokens`\n\nArguments:\n- `id`: User ID\n- `body`\n```ignore\nlet response = client.create_user_api_token()\n    .id(id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_user_api_token(&self) -> builder::CreateUserApiToken<'_>;
    #[doc = "Revoke API token\n\nSends a `DELETE` request to `/api/v1/users/{id}/tokens/{token_id}`\n\nArguments:\n- `id`: User ID\n- `token_id`: API token ID\n```ignore\nlet response = client.revoke_user_api_token()\n    .id(id)\n    .token_id(token_id)\n    .send()\n    .await;\n```"]
    fn revoke_user_api_token(&self) -> builder::RevokeUserApiToken<'_>;
}
impl ClientUsersExt for Client {
    fn list_users(&self) -> builder::ListUsers<'_> {
        builder::ListUsers::new(self)
    }
    fn create_user(&self) -> builder::CreateUser<'_> {
        builder::CreateUser::new(self)
    }
    fn get_user(&self) -> builder::GetUser<'_> {
        builder::GetUser::new(self)
    }
    fn delete_user(&self) -> builder::DeleteUser<'_> {
        builder::DeleteUser::new(self)
    }
    fn update_user(&self) -> builder::UpdateUser<'_> {
        builder::UpdateUser::new(self)
    }
    fn change_password(&self) -> builder::ChangePassword<'_> {
        builder::ChangePassword::new(self)
    }
    fn reset_password(&self) -> builder::ResetPassword<'_> {
        builder::ResetPassword::new(self)
    }
    fn get_user_roles(&self) -> builder::GetUserRoles<'_> {
        builder::GetUserRoles::new(self)
    }
    fn assign_role(&self) -> builder::AssignRole<'_> {
        builder::AssignRole::new(self)
    }
    fn revoke_role(&self) -> builder::RevokeRole<'_> {
        builder::RevokeRole::new(self)
    }
    fn list_user_tokens(&self) -> builder::ListUserTokens<'_> {
        builder::ListUserTokens::new(self)
    }
    fn create_user_api_token(&self) -> builder::CreateUserApiToken<'_> {
        builder::CreateUserApiToken::new(self)
    }
    fn revoke_user_api_token(&self) -> builder::RevokeUserApiToken<'_> {
        builder::RevokeUserApiToken::new(self)
    }
}
#[doc = "Event webhook management"]
pub trait ClientWebhooksExt {
    #[doc = "List webhooks\n\nSends a `GET` request to `/api/v1/webhooks`\n\n```ignore\nlet response = client.list_webhooks()\n    .enabled(enabled)\n    .page(page)\n    .per_page(per_page)\n    .repository_id(repository_id)\n    .send()\n    .await;\n```"]
    fn list_webhooks(&self) -> builder::ListWebhooks<'_>;
    #[doc = "Create webhook\n\nSends a `POST` request to `/api/v1/webhooks`\n\n```ignore\nlet response = client.create_webhook()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn create_webhook(&self) -> builder::CreateWebhook<'_>;
    #[doc = "Get webhook by ID\n\nSends a `GET` request to `/api/v1/webhooks/{id}`\n\nArguments:\n- `id`: Webhook ID\n```ignore\nlet response = client.get_webhook()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn get_webhook(&self) -> builder::GetWebhook<'_>;
    #[doc = "Delete webhook\n\nSends a `DELETE` request to `/api/v1/webhooks/{id}`\n\nArguments:\n- `id`: Webhook ID\n```ignore\nlet response = client.delete_webhook()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn delete_webhook(&self) -> builder::DeleteWebhook<'_>;
    #[doc = "List webhook deliveries\n\nSends a `GET` request to `/api/v1/webhooks/{id}/deliveries`\n\nArguments:\n- `id`: Webhook ID\n- `page`\n- `per_page`\n- `status`\n```ignore\nlet response = client.list_deliveries()\n    .id(id)\n    .page(page)\n    .per_page(per_page)\n    .status(status)\n    .send()\n    .await;\n```"]
    fn list_deliveries(&self) -> builder::ListDeliveries<'_>;
    #[doc = "Redeliver a failed webhook\n\nSends a `POST` request to `/api/v1/webhooks/{id}/deliveries/{delivery_id}/redeliver`\n\nArguments:\n- `id`: Webhook ID\n- `delivery_id`: Delivery ID\n```ignore\nlet response = client.redeliver()\n    .id(id)\n    .delivery_id(delivery_id)\n    .send()\n    .await;\n```"]
    fn redeliver(&self) -> builder::Redeliver<'_>;
    #[doc = "Disable webhook\n\nSends a `POST` request to `/api/v1/webhooks/{id}/disable`\n\nArguments:\n- `id`: Webhook ID\n```ignore\nlet response = client.disable_webhook()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn disable_webhook(&self) -> builder::DisableWebhook<'_>;
    #[doc = "Enable webhook\n\nSends a `POST` request to `/api/v1/webhooks/{id}/enable`\n\nArguments:\n- `id`: Webhook ID\n```ignore\nlet response = client.enable_webhook()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn enable_webhook(&self) -> builder::EnableWebhook<'_>;
    #[doc = "Test webhook by sending a test payload\n\nSends a `POST` request to `/api/v1/webhooks/{id}/test`\n\nArguments:\n- `id`: Webhook ID\n```ignore\nlet response = client.test_webhook()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn test_webhook(&self) -> builder::TestWebhook<'_>;
}
impl ClientWebhooksExt for Client {
    fn list_webhooks(&self) -> builder::ListWebhooks<'_> {
        builder::ListWebhooks::new(self)
    }
    fn create_webhook(&self) -> builder::CreateWebhook<'_> {
        builder::CreateWebhook::new(self)
    }
    fn get_webhook(&self) -> builder::GetWebhook<'_> {
        builder::GetWebhook::new(self)
    }
    fn delete_webhook(&self) -> builder::DeleteWebhook<'_> {
        builder::DeleteWebhook::new(self)
    }
    fn list_deliveries(&self) -> builder::ListDeliveries<'_> {
        builder::ListDeliveries::new(self)
    }
    fn redeliver(&self) -> builder::Redeliver<'_> {
        builder::Redeliver::new(self)
    }
    fn disable_webhook(&self) -> builder::DisableWebhook<'_> {
        builder::DisableWebhook::new(self)
    }
    fn enable_webhook(&self) -> builder::EnableWebhook<'_> {
        builder::EnableWebhook::new(self)
    }
    fn test_webhook(&self) -> builder::TestWebhook<'_> {
        builder::TestWebhook::new(self)
    }
}
#[doc = r" Types for composing operation parameters."]
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        ByteStream, ClientHooks, ClientInfo, Error, OperationInfo, RequestBuilderExt,
        ResponseValue, encode_path,
    };
    #[doc = "Builder for [`ClientAnalyticsExt::get_stale_artifacts`]\n\n[`ClientAnalyticsExt::get_stale_artifacts`]: super::ClientAnalyticsExt::get_stale_artifacts"]
    #[derive(Debug, Clone)]
    pub struct GetStaleArtifacts<'a> {
        client: &'a super::Client,
        days: Result<Option<i32>, String>,
        limit: Result<Option<i64>, String>,
    }
    impl<'a> GetStaleArtifacts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                days: Ok(None),
                limit: Ok(None),
            }
        }
        pub fn days<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.days = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for days failed".to_string());
            self
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/analytics/artifacts/stale`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::StaleArtifact>>, Error<()>> {
            let Self {
                client,
                days,
                limit,
            } = self;
            let days = days.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/analytics/artifacts/stale", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("days", &days))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_stale_artifacts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAnalyticsExt::get_download_trends`]\n\n[`ClientAnalyticsExt::get_download_trends`]: super::ClientAnalyticsExt::get_download_trends"]
    #[derive(Debug, Clone)]
    pub struct GetDownloadTrends<'a> {
        client: &'a super::Client,
        from: Result<Option<::std::string::String>, String>,
        to: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetDownloadTrends<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                from: Ok(None),
                to: Ok(None),
            }
        }
        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.from = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for from failed".to_string()
            });
            self
        }
        pub fn to<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.to = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for to failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/analytics/downloads/trend`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DownloadTrend>>, Error<()>> {
            let Self { client, from, to } = self;
            let from = from.map_err(Error::InvalidRequest)?;
            let to = to.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/analytics/downloads/trend", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("from", &from))
                .query(&progenitor_client::QueryParam::new("to", &to))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_download_trends",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAnalyticsExt::get_repository_trend`]\n\n[`ClientAnalyticsExt::get_repository_trend`]: super::ClientAnalyticsExt::get_repository_trend"]
    #[derive(Debug, Clone)]
    pub struct GetRepositoryTrend<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        from: Result<Option<::std::string::String>, String>,
        to: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetRepositoryTrend<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                from: Ok(None),
                to: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.from = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for from failed".to_string()
            });
            self
        }
        pub fn to<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.to = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for to failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/analytics/repositories/{id}/trend`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::RepositorySnapshot>>, Error<()>> {
            let Self {
                client,
                id,
                from,
                to,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let to = to.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/analytics/repositories/{}/trend",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("from", &from))
                .query(&progenitor_client::QueryParam::new("to", &to))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_repository_trend",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAnalyticsExt::capture_snapshot`]\n\n[`ClientAnalyticsExt::capture_snapshot`]: super::ClientAnalyticsExt::capture_snapshot"]
    #[derive(Debug, Clone)]
    pub struct CaptureSnapshot<'a> {
        client: &'a super::Client,
    }
    impl<'a> CaptureSnapshot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/analytics/snapshot`"]
        pub async fn send(self) -> Result<ResponseValue<types::StorageSnapshot>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/analytics/snapshot", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "capture_snapshot",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAnalyticsExt::get_storage_breakdown`]\n\n[`ClientAnalyticsExt::get_storage_breakdown`]: super::ClientAnalyticsExt::get_storage_breakdown"]
    #[derive(Debug, Clone)]
    pub struct GetStorageBreakdown<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetStorageBreakdown<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/analytics/storage/breakdown`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::RepositoryStorageBreakdown>>, Error<()>>
        {
            let Self { client } = self;
            let url = format!(
                "{}/api/v1/admin/analytics/storage/breakdown",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_storage_breakdown",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAnalyticsExt::get_growth_summary`]\n\n[`ClientAnalyticsExt::get_growth_summary`]: super::ClientAnalyticsExt::get_growth_summary"]
    #[derive(Debug, Clone)]
    pub struct GetGrowthSummary<'a> {
        client: &'a super::Client,
        from: Result<Option<::std::string::String>, String>,
        to: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetGrowthSummary<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                from: Ok(None),
                to: Ok(None),
            }
        }
        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.from = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for from failed".to_string()
            });
            self
        }
        pub fn to<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.to = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for to failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/analytics/storage/growth`"]
        pub async fn send(self) -> Result<ResponseValue<types::GrowthSummary>, Error<()>> {
            let Self { client, from, to } = self;
            let from = from.map_err(Error::InvalidRequest)?;
            let to = to.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/analytics/storage/growth", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("from", &from))
                .query(&progenitor_client::QueryParam::new("to", &to))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_growth_summary",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAnalyticsExt::get_storage_trend`]\n\n[`ClientAnalyticsExt::get_storage_trend`]: super::ClientAnalyticsExt::get_storage_trend"]
    #[derive(Debug, Clone)]
    pub struct GetStorageTrend<'a> {
        client: &'a super::Client,
        from: Result<Option<::std::string::String>, String>,
        to: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetStorageTrend<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                from: Ok(None),
                to: Ok(None),
            }
        }
        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.from = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for from failed".to_string()
            });
            self
        }
        pub fn to<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.to = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for to failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/analytics/storage/trend`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::StorageSnapshot>>, Error<()>> {
            let Self { client, from, to } = self;
            let from = from.map_err(Error::InvalidRequest)?;
            let to = to.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/analytics/storage/trend", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("from", &from))
                .query(&progenitor_client::QueryParam::new("to", &to))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_storage_trend",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::list_backups`]\n\n[`ClientAdminExt::list_backups`]: super::ClientAdminExt::list_backups"]
    #[derive(Debug, Clone)]
    pub struct ListBackups<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        status: Result<Option<::std::string::String>, String>,
        type_: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListBackups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                status: Ok(None),
                type_: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.type_ = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for type_ failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/backups`"]
        pub async fn send(self) -> Result<ResponseValue<types::BackupListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                status,
                type_,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/backups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .query(&progenitor_client::QueryParam::new("type", &type_))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_backups",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::create_backup`]\n\n[`ClientAdminExt::create_backup`]: super::ClientAdminExt::create_backup"]
    #[derive(Debug, Clone)]
    pub struct CreateBackup<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateBackupRequest, String>,
    }
    impl<'a> CreateBackup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateBackupRequest>,
            <V as std::convert::TryInto<types::CreateBackupRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateBackupRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateBackupRequest,
                ) -> types::builder::CreateBackupRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/backups`"]
        pub async fn send(self) -> Result<ResponseValue<types::BackupResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateBackupRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/backups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_backup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::get_backup`]\n\n[`ClientAdminExt::get_backup`]: super::ClientAdminExt::get_backup"]
    #[derive(Debug, Clone)]
    pub struct GetBackup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetBackup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/backups/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::BackupResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/backups/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_backup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::delete_backup`]\n\n[`ClientAdminExt::delete_backup`]: super::ClientAdminExt::delete_backup"]
    #[derive(Debug, Clone)]
    pub struct DeleteBackup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteBackup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/admin/backups/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/backups/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_backup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::cancel_backup`]\n\n[`ClientAdminExt::cancel_backup`]: super::ClientAdminExt::cancel_backup"]
    #[derive(Debug, Clone)]
    pub struct CancelBackup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> CancelBackup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/backups/{id}/cancel`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/backups/{}/cancel",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "cancel_backup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::execute_backup`]\n\n[`ClientAdminExt::execute_backup`]: super::ClientAdminExt::execute_backup"]
    #[derive(Debug, Clone)]
    pub struct ExecuteBackup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ExecuteBackup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/backups/{id}/execute`"]
        pub async fn send(self) -> Result<ResponseValue<types::BackupResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/backups/{}/execute",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "execute_backup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::restore_backup`]\n\n[`ClientAdminExt::restore_backup`]: super::ClientAdminExt::restore_backup"]
    #[derive(Debug, Clone)]
    pub struct RestoreBackup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::RestoreRequest, String>,
    }
    impl<'a> RestoreBackup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RestoreRequest>,
            <V as std::convert::TryInto<types::RestoreRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `RestoreRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::RestoreRequest) -> types::builder::RestoreRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/backups/{id}/restore`"]
        pub async fn send(self) -> Result<ResponseValue<types::RestoreResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::RestoreRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/backups/{}/restore",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "restore_backup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::run_cleanup`]\n\n[`ClientAdminExt::run_cleanup`]: super::ClientAdminExt::run_cleanup"]
    #[derive(Debug, Clone)]
    pub struct RunCleanup<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CleanupRequest, String>,
    }
    impl<'a> RunCleanup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CleanupRequest>,
            <V as std::convert::TryInto<types::CleanupRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CleanupRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::CleanupRequest) -> types::builder::CleanupRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/cleanup`"]
        pub async fn send(self) -> Result<ResponseValue<types::CleanupResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CleanupRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/cleanup", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "run_cleanup",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::list_lifecycle_policies`]\n\n[`ClientLifecycleExt::list_lifecycle_policies`]: super::ClientLifecycleExt::list_lifecycle_policies"]
    #[derive(Debug, Clone)]
    pub struct ListLifecyclePolicies<'a> {
        client: &'a super::Client,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> ListLifecyclePolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                repository_id: Ok(None),
            }
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/lifecycle`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::LifecyclePolicy>>, Error<()>> {
            let Self {
                client,
                repository_id,
            } = self;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/lifecycle", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_lifecycle_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::create_lifecycle_policy`]\n\n[`ClientLifecycleExt::create_lifecycle_policy`]: super::ClientLifecycleExt::create_lifecycle_policy"]
    #[derive(Debug, Clone)]
    pub struct CreateLifecyclePolicy<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreatePolicyRequest, String>,
    }
    impl<'a> CreateLifecyclePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePolicyRequest>,
            <V as std::convert::TryInto<types::CreatePolicyRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreatePolicyRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreatePolicyRequest,
                ) -> types::builder::CreatePolicyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/lifecycle`"]
        pub async fn send(self) -> Result<ResponseValue<types::LifecyclePolicy>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreatePolicyRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/lifecycle", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_lifecycle_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::execute_all_policies`]\n\n[`ClientLifecycleExt::execute_all_policies`]: super::ClientLifecycleExt::execute_all_policies"]
    #[derive(Debug, Clone)]
    pub struct ExecuteAllPolicies<'a> {
        client: &'a super::Client,
    }
    impl<'a> ExecuteAllPolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/lifecycle/execute-all`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::PolicyExecutionResult>>, Error<()>>
        {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/lifecycle/execute-all", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "execute_all_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::get_lifecycle_policy`]\n\n[`ClientLifecycleExt::get_lifecycle_policy`]: super::ClientLifecycleExt::get_lifecycle_policy"]
    #[derive(Debug, Clone)]
    pub struct GetLifecyclePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetLifecyclePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/lifecycle/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::LifecyclePolicy>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/lifecycle/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_lifecycle_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::delete_lifecycle_policy`]\n\n[`ClientLifecycleExt::delete_lifecycle_policy`]: super::ClientLifecycleExt::delete_lifecycle_policy"]
    #[derive(Debug, Clone)]
    pub struct DeleteLifecyclePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteLifecyclePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/admin/lifecycle/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/lifecycle/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_lifecycle_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::update_lifecycle_policy`]\n\n[`ClientLifecycleExt::update_lifecycle_policy`]: super::ClientLifecycleExt::update_lifecycle_policy"]
    #[derive(Debug, Clone)]
    pub struct UpdateLifecyclePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdatePolicyRequest, String>,
    }
    impl<'a> UpdateLifecyclePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdatePolicyRequest>,
            <V as std::convert::TryInto<types::UpdatePolicyRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdatePolicyRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdatePolicyRequest,
                ) -> types::builder::UpdatePolicyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/api/v1/admin/lifecycle/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::LifecyclePolicy>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdatePolicyRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/lifecycle/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_lifecycle_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::execute_policy`]\n\n[`ClientLifecycleExt::execute_policy`]: super::ClientLifecycleExt::execute_policy"]
    #[derive(Debug, Clone)]
    pub struct ExecutePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ExecutePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/lifecycle/{id}/execute`"]
        pub async fn send(self) -> Result<ResponseValue<types::PolicyExecutionResult>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/lifecycle/{}/execute",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "execute_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientLifecycleExt::preview_policy`]\n\n[`ClientLifecycleExt::preview_policy`]: super::ClientLifecycleExt::preview_policy"]
    #[derive(Debug, Clone)]
    pub struct PreviewPolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> PreviewPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/lifecycle/{id}/preview`"]
        pub async fn send(self) -> Result<ResponseValue<types::PolicyExecutionResult>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/lifecycle/{}/preview",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "preview_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientHealthExt::metrics`]\n\n[`ClientHealthExt::metrics`]: super::ClientHealthExt::metrics"]
    #[derive(Debug, Clone)]
    pub struct Metrics<'a> {
        client: &'a super::Client,
    }
    impl<'a> Metrics<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/metrics`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/metrics", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "metrics",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMonitoringExt::get_alert_states`]\n\n[`ClientMonitoringExt::get_alert_states`]: super::ClientMonitoringExt::get_alert_states"]
    #[derive(Debug, Clone)]
    pub struct GetAlertStates<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetAlertStates<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/monitoring/alerts`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::AlertState>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/monitoring/alerts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_alert_states",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMonitoringExt::suppress_alert`]\n\n[`ClientMonitoringExt::suppress_alert`]: super::ClientMonitoringExt::suppress_alert"]
    #[derive(Debug, Clone)]
    pub struct SuppressAlert<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SuppressRequest, String>,
    }
    impl<'a> SuppressAlert<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SuppressRequest>,
            <V as std::convert::TryInto<types::SuppressRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SuppressRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SuppressRequest) -> types::builder::SuppressRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/monitoring/alerts/suppress`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SuppressRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/monitoring/alerts/suppress", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "suppress_alert",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMonitoringExt::run_health_check`]\n\n[`ClientMonitoringExt::run_health_check`]: super::ClientMonitoringExt::run_health_check"]
    #[derive(Debug, Clone)]
    pub struct RunHealthCheck<'a> {
        client: &'a super::Client,
    }
    impl<'a> RunHealthCheck<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/monitoring/check`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ServiceHealthEntry>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/monitoring/check", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "run_health_check",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMonitoringExt::get_health_log`]\n\n[`ClientMonitoringExt::get_health_log`]: super::ClientMonitoringExt::get_health_log"]
    #[derive(Debug, Clone)]
    pub struct GetHealthLog<'a> {
        client: &'a super::Client,
        limit: Result<Option<i64>, String>,
        service: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetHealthLog<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                service: Ok(None),
            }
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        pub fn service<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.service = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for service failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/monitoring/health-log`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ServiceHealthEntry>>, Error<()>> {
            let Self {
                client,
                limit,
                service,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let service = service.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/monitoring/health-log", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("service", &service))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_health_log",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::trigger_reindex`]\n\n[`ClientAdminExt::trigger_reindex`]: super::ClientAdminExt::trigger_reindex"]
    #[derive(Debug, Clone)]
    pub struct TriggerReindex<'a> {
        client: &'a super::Client,
    }
    impl<'a> TriggerReindex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/reindex`"]
        pub async fn send(self) -> Result<ResponseValue<types::ReindexResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/reindex", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "trigger_reindex",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::get_settings`]\n\n[`ClientAdminExt::get_settings`]: super::ClientAdminExt::get_settings"]
    #[derive(Debug, Clone)]
    pub struct GetSettings<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/settings`"]
        pub async fn send(self) -> Result<ResponseValue<types::SystemSettings>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/settings", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_settings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::update_settings`]\n\n[`ClientAdminExt::update_settings`]: super::ClientAdminExt::update_settings"]
    #[derive(Debug, Clone)]
    pub struct UpdateSettings<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SystemSettings, String>,
    }
    impl<'a> UpdateSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemSettings>,
            <V as std::convert::TryInto<types::SystemSettings>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SystemSettings` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SystemSettings) -> types::builder::SystemSettings,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/settings`"]
        pub async fn send(self) -> Result<ResponseValue<types::SystemSettings>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SystemSettings::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/settings", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_settings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::list_ldap`]\n\n[`ClientSsoExt::list_ldap`]: super::ClientSsoExt::list_ldap"]
    #[derive(Debug, Clone)]
    pub struct ListLdap<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/ldap`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::LdapConfigResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/sso/ldap", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::create_ldap`]\n\n[`ClientSsoExt::create_ldap`]: super::ClientSsoExt::create_ldap"]
    #[derive(Debug, Clone)]
    pub struct CreateLdap<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateLdapConfigRequest, String>,
    }
    impl<'a> CreateLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateLdapConfigRequest>,
            <V as std::convert::TryInto<types::CreateLdapConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateLdapConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateLdapConfigRequest,
                ) -> types::builder::CreateLdapConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/sso/ldap`"]
        pub async fn send(self) -> Result<ResponseValue<types::LdapConfigResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateLdapConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/sso/ldap", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::get_ldap`]\n\n[`ClientSsoExt::get_ldap`]: super::ClientSsoExt::get_ldap"]
    #[derive(Debug, Clone)]
    pub struct GetLdap<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/ldap/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::LdapConfigResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/ldap/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::update_ldap`]\n\n[`ClientSsoExt::update_ldap`]: super::ClientSsoExt::update_ldap"]
    #[derive(Debug, Clone)]
    pub struct UpdateLdap<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateLdapConfigRequest, String>,
    }
    impl<'a> UpdateLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateLdapConfigRequest>,
            <V as std::convert::TryInto<types::UpdateLdapConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateLdapConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateLdapConfigRequest,
                ) -> types::builder::UpdateLdapConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/admin/sso/ldap/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::LdapConfigResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateLdapConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/ldap/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::delete_ldap`]\n\n[`ClientSsoExt::delete_ldap`]: super::ClientSsoExt::delete_ldap"]
    #[derive(Debug, Clone)]
    pub struct DeleteLdap<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/admin/sso/ldap/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/ldap/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::test_ldap`]\n\n[`ClientSsoExt::test_ldap`]: super::ClientSsoExt::test_ldap"]
    #[derive(Debug, Clone)]
    pub struct TestLdap<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> TestLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/sso/ldap/{id}/test`"]
        pub async fn send(self) -> Result<ResponseValue<types::LdapTestResult>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/ldap/{}/test",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "test_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::toggle_ldap`]\n\n[`ClientSsoExt::toggle_ldap`]: super::ClientSsoExt::toggle_ldap"]
    #[derive(Debug, Clone)]
    pub struct ToggleLdap<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ToggleRequest, String>,
    }
    impl<'a> ToggleLdap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ToggleRequest>,
            <V as std::convert::TryInto<types::ToggleRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ToggleRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ToggleRequest) -> types::builder::ToggleRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/api/v1/admin/sso/ldap/{id}/toggle`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ToggleRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/ldap/{}/toggle",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "toggle_ldap",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::list_oidc`]\n\n[`ClientSsoExt::list_oidc`]: super::ClientSsoExt::list_oidc"]
    #[derive(Debug, Clone)]
    pub struct ListOidc<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListOidc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/oidc`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::OidcConfigResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/sso/oidc", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_oidc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::create_oidc`]\n\n[`ClientSsoExt::create_oidc`]: super::ClientSsoExt::create_oidc"]
    #[derive(Debug, Clone)]
    pub struct CreateOidc<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateOidcConfigRequest, String>,
    }
    impl<'a> CreateOidc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateOidcConfigRequest>,
            <V as std::convert::TryInto<types::CreateOidcConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateOidcConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateOidcConfigRequest,
                ) -> types::builder::CreateOidcConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/sso/oidc`"]
        pub async fn send(self) -> Result<ResponseValue<types::OidcConfigResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateOidcConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/sso/oidc", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_oidc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::get_oidc`]\n\n[`ClientSsoExt::get_oidc`]: super::ClientSsoExt::get_oidc"]
    #[derive(Debug, Clone)]
    pub struct GetOidc<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetOidc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/oidc/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::OidcConfigResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/oidc/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_oidc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::update_oidc`]\n\n[`ClientSsoExt::update_oidc`]: super::ClientSsoExt::update_oidc"]
    #[derive(Debug, Clone)]
    pub struct UpdateOidc<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateOidcConfigRequest, String>,
    }
    impl<'a> UpdateOidc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateOidcConfigRequest>,
            <V as std::convert::TryInto<types::UpdateOidcConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateOidcConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateOidcConfigRequest,
                ) -> types::builder::UpdateOidcConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/admin/sso/oidc/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::OidcConfigResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateOidcConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/oidc/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_oidc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::delete_oidc`]\n\n[`ClientSsoExt::delete_oidc`]: super::ClientSsoExt::delete_oidc"]
    #[derive(Debug, Clone)]
    pub struct DeleteOidc<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteOidc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/admin/sso/oidc/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/oidc/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_oidc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::toggle_oidc`]\n\n[`ClientSsoExt::toggle_oidc`]: super::ClientSsoExt::toggle_oidc"]
    #[derive(Debug, Clone)]
    pub struct ToggleOidc<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ToggleRequest, String>,
    }
    impl<'a> ToggleOidc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ToggleRequest>,
            <V as std::convert::TryInto<types::ToggleRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ToggleRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ToggleRequest) -> types::builder::ToggleRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/api/v1/admin/sso/oidc/{id}/toggle`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ToggleRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/oidc/{}/toggle",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "toggle_oidc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::list_sso_providers_admin`]\n\n[`ClientSsoExt::list_sso_providers_admin`]: super::ClientSsoExt::list_sso_providers_admin"]
    #[derive(Debug, Clone)]
    pub struct ListSsoProvidersAdmin<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListSsoProvidersAdmin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/providers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SsoProviderInfo>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/sso/providers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_sso_providers_admin",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::list_saml`]\n\n[`ClientSsoExt::list_saml`]: super::ClientSsoExt::list_saml"]
    #[derive(Debug, Clone)]
    pub struct ListSaml<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/saml`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SamlConfigResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/sso/saml", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::create_saml`]\n\n[`ClientSsoExt::create_saml`]: super::ClientSsoExt::create_saml"]
    #[derive(Debug, Clone)]
    pub struct CreateSaml<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateSamlConfigRequest, String>,
    }
    impl<'a> CreateSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSamlConfigRequest>,
            <V as std::convert::TryInto<types::CreateSamlConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateSamlConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateSamlConfigRequest,
                ) -> types::builder::CreateSamlConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/sso/saml`"]
        pub async fn send(self) -> Result<ResponseValue<types::SamlConfigResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateSamlConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/sso/saml", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::get_saml`]\n\n[`ClientSsoExt::get_saml`]: super::ClientSsoExt::get_saml"]
    #[derive(Debug, Clone)]
    pub struct GetSaml<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/sso/saml/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SamlConfigResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/saml/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::update_saml`]\n\n[`ClientSsoExt::update_saml`]: super::ClientSsoExt::update_saml"]
    #[derive(Debug, Clone)]
    pub struct UpdateSaml<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateSamlConfigRequest, String>,
    }
    impl<'a> UpdateSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateSamlConfigRequest>,
            <V as std::convert::TryInto<types::UpdateSamlConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateSamlConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateSamlConfigRequest,
                ) -> types::builder::UpdateSamlConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/admin/sso/saml/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SamlConfigResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateSamlConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/saml/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::delete_saml`]\n\n[`ClientSsoExt::delete_saml`]: super::ClientSsoExt::delete_saml"]
    #[derive(Debug, Clone)]
    pub struct DeleteSaml<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/admin/sso/saml/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/saml/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::toggle_saml`]\n\n[`ClientSsoExt::toggle_saml`]: super::ClientSsoExt::toggle_saml"]
    #[derive(Debug, Clone)]
    pub struct ToggleSaml<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ToggleRequest, String>,
    }
    impl<'a> ToggleSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ToggleRequest>,
            <V as std::convert::TryInto<types::ToggleRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ToggleRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ToggleRequest) -> types::builder::ToggleRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/api/v1/admin/sso/saml/{id}/toggle`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ToggleRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/sso/saml/{}/toggle",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "toggle_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::get_system_stats`]\n\n[`ClientAdminExt::get_system_stats`]: super::ClientAdminExt::get_system_stats"]
    #[derive(Debug, Clone)]
    pub struct GetSystemStats<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetSystemStats<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/stats`"]
        pub async fn send(self) -> Result<ResponseValue<types::SystemStats>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/stats", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_system_stats",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::list_crashes`]\n\n[`ClientTelemetryExt::list_crashes`]: super::ClientTelemetryExt::list_crashes"]
    #[derive(Debug, Clone)]
    pub struct ListCrashes<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
    }
    impl<'a> ListCrashes<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/telemetry/crashes`"]
        pub async fn send(self) -> Result<ResponseValue<types::CrashListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/telemetry/crashes", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_crashes",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::list_pending_crashes`]\n\n[`ClientTelemetryExt::list_pending_crashes`]: super::ClientTelemetryExt::list_pending_crashes"]
    #[derive(Debug, Clone)]
    pub struct ListPendingCrashes<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListPendingCrashes<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/telemetry/crashes/pending`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::CrashReport>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/telemetry/crashes/pending", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_pending_crashes",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::submit_crashes`]\n\n[`ClientTelemetryExt::submit_crashes`]: super::ClientTelemetryExt::submit_crashes"]
    #[derive(Debug, Clone)]
    pub struct SubmitCrashes<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SubmitCrashesRequest, String>,
    }
    impl<'a> SubmitCrashes<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SubmitCrashesRequest>,
            <V as std::convert::TryInto<types::SubmitCrashesRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SubmitCrashesRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::SubmitCrashesRequest,
                ) -> types::builder::SubmitCrashesRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/telemetry/crashes/submit`"]
        pub async fn send(self) -> Result<ResponseValue<types::SubmitResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SubmitCrashesRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/telemetry/crashes/submit", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "submit_crashes",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::get_crash`]\n\n[`ClientTelemetryExt::get_crash`]: super::ClientTelemetryExt::get_crash"]
    #[derive(Debug, Clone)]
    pub struct GetCrash<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetCrash<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/telemetry/crashes/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::CrashReport>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/telemetry/crashes/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_crash",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::delete_crash`]\n\n[`ClientTelemetryExt::delete_crash`]: super::ClientTelemetryExt::delete_crash"]
    #[derive(Debug, Clone)]
    pub struct DeleteCrash<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteCrash<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/admin/telemetry/crashes/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/admin/telemetry/crashes/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_crash",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::get_telemetry_settings`]\n\n[`ClientTelemetryExt::get_telemetry_settings`]: super::ClientTelemetryExt::get_telemetry_settings"]
    #[derive(Debug, Clone)]
    pub struct GetTelemetrySettings<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetTelemetrySettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/admin/telemetry/settings`"]
        pub async fn send(self) -> Result<ResponseValue<types::TelemetrySettings>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/admin/telemetry/settings", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_telemetry_settings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientTelemetryExt::update_telemetry_settings`]\n\n[`ClientTelemetryExt::update_telemetry_settings`]: super::ClientTelemetryExt::update_telemetry_settings"]
    #[derive(Debug, Clone)]
    pub struct UpdateTelemetrySettings<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TelemetrySettings, String>,
    }
    impl<'a> UpdateTelemetrySettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TelemetrySettings>,
            <V as std::convert::TryInto<types::TelemetrySettings>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TelemetrySettings` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TelemetrySettings,
                ) -> types::builder::TelemetrySettings,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/admin/telemetry/settings`"]
        pub async fn send(self) -> Result<ResponseValue<types::TelemetrySettings>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TelemetrySettings::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/admin/telemetry/settings", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_telemetry_settings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientApprovalExt::list_approval_history`]\n\n[`ClientApprovalExt::list_approval_history`]: super::ClientApprovalExt::list_approval_history"]
    #[derive(Debug, Clone)]
    pub struct ListApprovalHistory<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        source_repository: Result<Option<::std::string::String>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListApprovalHistory<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                source_repository: Ok(None),
                status: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn source_repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.source_repository = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for source_repository failed"
                    .to_string()
            });
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/approval/history`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApprovalListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                source_repository,
                status,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let source_repository = source_repository.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/approval/history", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "source_repository",
                    &source_repository,
                ))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_approval_history",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientApprovalExt::list_pending_approvals`]\n\n[`ClientApprovalExt::list_pending_approvals`]: super::ClientApprovalExt::list_pending_approvals"]
    #[derive(Debug, Clone)]
    pub struct ListPendingApprovals<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        source_repository: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListPendingApprovals<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                source_repository: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn source_repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.source_repository = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for source_repository failed"
                    .to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/approval/pending`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApprovalListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                source_repository,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let source_repository = source_repository.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/approval/pending", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "source_repository",
                    &source_repository,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_pending_approvals",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientApprovalExt::request_approval`]\n\n[`ClientApprovalExt::request_approval`]: super::ClientApprovalExt::request_approval"]
    #[derive(Debug, Clone)]
    pub struct RequestApproval<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ApprovalRequest, String>,
    }
    impl<'a> RequestApproval<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ApprovalRequest>,
            <V as std::convert::TryInto<types::ApprovalRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ApprovalRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ApprovalRequest) -> types::builder::ApprovalRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/approval/request`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApprovalResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::ApprovalRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/approval/request", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "request_approval",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientApprovalExt::get_approval`]\n\n[`ClientApprovalExt::get_approval`]: super::ClientApprovalExt::get_approval"]
    #[derive(Debug, Clone)]
    pub struct GetApproval<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetApproval<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/approval/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApprovalResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/approval/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_approval",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientApprovalExt::approve_promotion`]\n\n[`ClientApprovalExt::approve_promotion`]: super::ClientApprovalExt::approve_promotion"]
    #[derive(Debug, Clone)]
    pub struct ApprovePromotion<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ReviewRequest, String>,
    }
    impl<'a> ApprovePromotion<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ReviewRequest>,
            <V as std::convert::TryInto<types::ReviewRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ReviewRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ReviewRequest) -> types::builder::ReviewRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/approval/{id}/approve`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApprovalResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ReviewRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/approval/{}/approve",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "approve_promotion",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientApprovalExt::reject_promotion`]\n\n[`ClientApprovalExt::reject_promotion`]: super::ClientApprovalExt::reject_promotion"]
    #[derive(Debug, Clone)]
    pub struct RejectPromotion<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ReviewRequest, String>,
    }
    impl<'a> RejectPromotion<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ReviewRequest>,
            <V as std::convert::TryInto<types::ReviewRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ReviewRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ReviewRequest) -> types::builder::ReviewRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/approval/{id}/reject`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApprovalResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ReviewRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/approval/{}/reject",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "reject_promotion",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientArtifactsExt::get_artifact`]\n\n[`ClientArtifactsExt::get_artifact`]: super::ClientArtifactsExt::get_artifact"]
    #[derive(Debug, Clone)]
    pub struct GetArtifact<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/artifacts/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ArtifactResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/artifacts/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientArtifactsExt::get_artifact_metadata`]\n\n[`ClientArtifactsExt::get_artifact_metadata`]: super::ClientArtifactsExt::get_artifact_metadata"]
    #[derive(Debug, Clone)]
    pub struct GetArtifactMetadata<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetArtifactMetadata<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/artifacts/{id}/metadata`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ArtifactMetadataResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/artifacts/{}/metadata",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_artifact_metadata",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientArtifactsExt::get_artifact_stats`]\n\n[`ClientArtifactsExt::get_artifact_stats`]: super::ClientArtifactsExt::get_artifact_stats"]
    #[derive(Debug, Clone)]
    pub struct GetArtifactStats<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetArtifactStats<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/artifacts/{id}/stats`"]
        pub async fn send(self) -> Result<ResponseValue<types::ArtifactStatsResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/artifacts/{}/stats",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_artifact_stats",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::login`]\n\n[`ClientAuthExt::login`]: super::ClientAuthExt::login"]
    #[derive(Debug, Clone)]
    pub struct Login<'a> {
        client: &'a super::Client,
        body: Result<types::builder::LoginRequest, String>,
    }
    impl<'a> Login<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::LoginRequest>,
            <V as std::convert::TryInto<types::LoginRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `LoginRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::LoginRequest) -> types::builder::LoginRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/login`"]
        pub async fn send(self) -> Result<ResponseValue<types::LoginResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::LoginRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/login", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "login",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::logout`]\n\n[`ClientAuthExt::logout`]: super::ClientAuthExt::logout"]
    #[derive(Debug, Clone)]
    pub struct Logout<'a> {
        client: &'a super::Client,
    }
    impl<'a> Logout<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/logout`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/auth/logout", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "logout",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::get_current_user`]\n\n[`ClientAuthExt::get_current_user`]: super::ClientAuthExt::get_current_user"]
    #[derive(Debug, Clone)]
    pub struct GetCurrentUser<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetCurrentUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/auth/me`"]
        pub async fn send(self) -> Result<ResponseValue<types::UserResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/auth/me", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_current_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::refresh_token`]\n\n[`ClientAuthExt::refresh_token`]: super::ClientAuthExt::refresh_token"]
    #[derive(Debug, Clone)]
    pub struct RefreshToken<'a> {
        client: &'a super::Client,
        body: Result<types::builder::RefreshTokenRequest, String>,
    }
    impl<'a> RefreshToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshTokenRequest>,
            <V as std::convert::TryInto<types::RefreshTokenRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `RefreshTokenRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::RefreshTokenRequest,
                ) -> types::builder::RefreshTokenRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/refresh`"]
        pub async fn send(self) -> Result<ResponseValue<types::LoginResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::RefreshTokenRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/refresh", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "refresh_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::exchange_code`]\n\n[`ClientSsoExt::exchange_code`]: super::ClientSsoExt::exchange_code"]
    #[derive(Debug, Clone)]
    pub struct ExchangeCode<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ExchangeCodeRequest, String>,
    }
    impl<'a> ExchangeCode<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExchangeCodeRequest>,
            <V as std::convert::TryInto<types::ExchangeCodeRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ExchangeCodeRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::ExchangeCodeRequest,
                ) -> types::builder::ExchangeCodeRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/sso/exchange`"]
        pub async fn send(self) -> Result<ResponseValue<types::ExchangeCodeResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::ExchangeCodeRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/sso/exchange", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "exchange_code",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::ldap_login`]\n\n[`ClientSsoExt::ldap_login`]: super::ClientSsoExt::ldap_login"]
    #[derive(Debug, Clone)]
    pub struct LdapLogin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::LdapLoginRequest, String>,
    }
    impl<'a> LdapLogin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::LdapLoginRequest>,
            <V as std::convert::TryInto<types::LdapLoginRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `LdapLoginRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::LdapLoginRequest,
                ) -> types::builder::LdapLoginRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/sso/ldap/{id}/login`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::LdapLoginRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/auth/sso/ldap/{}/login",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ldap_login",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::oidc_callback`]\n\n[`ClientSsoExt::oidc_callback`]: super::ClientSsoExt::oidc_callback"]
    #[derive(Debug, Clone)]
    pub struct OidcCallback<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        code: Result<::std::string::String, String>,
        state: Result<::std::string::String, String>,
    }
    impl<'a> OidcCallback<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                code: Err("code was not initialized".to_string()),
                state: Err("state was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn code<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.code = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for code failed".to_string()
            });
            self
        }
        pub fn state<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.state = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for state failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/auth/sso/oidc/{id}/callback`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self {
                client,
                id,
                code,
                state,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let code = code.map_err(Error::InvalidRequest)?;
            let state = state.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/auth/sso/oidc/{}/callback",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .query(&progenitor_client::QueryParam::new("code", &code))
                .query(&progenitor_client::QueryParam::new("state", &state))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "oidc_callback",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::oidc_login`]\n\n[`ClientSsoExt::oidc_login`]: super::ClientSsoExt::oidc_login"]
    #[derive(Debug, Clone)]
    pub struct OidcLogin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> OidcLogin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/auth/sso/oidc/{id}/login`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/auth/sso/oidc/{}/login",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "oidc_login",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::list_providers`]\n\n[`ClientSsoExt::list_providers`]: super::ClientSsoExt::list_providers"]
    #[derive(Debug, Clone)]
    pub struct ListProviders<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListProviders<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/auth/sso/providers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SsoProviderInfo>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/auth/sso/providers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_providers",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::saml_acs`]\n\n[`ClientSsoExt::saml_acs`]: super::ClientSsoExt::saml_acs"]
    #[derive(Debug, Clone)]
    pub struct SamlAcs<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::SamlAcsForm, String>,
    }
    impl<'a> SamlAcs<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SamlAcsForm>,
            <V as std::convert::TryInto<types::SamlAcsForm>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SamlAcsForm` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SamlAcsForm) -> types::builder::SamlAcsForm,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/sso/saml/{id}/acs`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SamlAcsForm::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/auth/sso/saml/{}/acs",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .form_urlencoded(&body)?
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "saml_acs",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSsoExt::saml_login`]\n\n[`ClientSsoExt::saml_login`]: super::ClientSsoExt::saml_login"]
    #[derive(Debug, Clone)]
    pub struct SamlLogin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> SamlLogin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/auth/sso/saml/{id}/login`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/auth/sso/saml/{}/login",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "saml_login",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::create_download_ticket`]\n\n[`ClientAuthExt::create_download_ticket`]: super::ClientAuthExt::create_download_ticket"]
    #[derive(Debug, Clone)]
    pub struct CreateDownloadTicket<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateTicketRequest, String>,
    }
    impl<'a> CreateDownloadTicket<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateTicketRequest>,
            <V as std::convert::TryInto<types::CreateTicketRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateTicketRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateTicketRequest,
                ) -> types::builder::CreateTicketRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/ticket`"]
        pub async fn send(self) -> Result<ResponseValue<types::TicketResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateTicketRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/ticket", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_download_ticket",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::create_api_token`]\n\n[`ClientAuthExt::create_api_token`]: super::ClientAuthExt::create_api_token"]
    #[derive(Debug, Clone)]
    pub struct CreateApiToken<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateApiTokenRequest, String>,
    }
    impl<'a> CreateApiToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateApiTokenRequest>,
            <V as std::convert::TryInto<types::CreateApiTokenRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateApiTokenRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateApiTokenRequest,
                ) -> types::builder::CreateApiTokenRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/tokens`"]
        pub async fn send(self) -> Result<ResponseValue<types::CreateApiTokenResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateApiTokenRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/tokens", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_api_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::revoke_api_token`]\n\n[`ClientAuthExt::revoke_api_token`]: super::ClientAuthExt::revoke_api_token"]
    #[derive(Debug, Clone)]
    pub struct RevokeApiToken<'a> {
        client: &'a super::Client,
        token_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RevokeApiToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                token_id: Err("token_id was not initialized".to_string()),
            }
        }
        pub fn token_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.token_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for token_id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/auth/tokens/{token_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, token_id } = self;
            let token_id = token_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/auth/tokens/{}",
                client.baseurl,
                encode_path(&token_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "revoke_api_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::disable_totp`]\n\n[`ClientAuthExt::disable_totp`]: super::ClientAuthExt::disable_totp"]
    #[derive(Debug, Clone)]
    pub struct DisableTotp<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TotpDisableRequest, String>,
    }
    impl<'a> DisableTotp<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TotpDisableRequest>,
            <V as std::convert::TryInto<types::TotpDisableRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TotpDisableRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TotpDisableRequest,
                ) -> types::builder::TotpDisableRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/totp/disable`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TotpDisableRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/totp/disable", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disable_totp",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::enable_totp`]\n\n[`ClientAuthExt::enable_totp`]: super::ClientAuthExt::enable_totp"]
    #[derive(Debug, Clone)]
    pub struct EnableTotp<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TotpCodeRequest, String>,
    }
    impl<'a> EnableTotp<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TotpCodeRequest>,
            <V as std::convert::TryInto<types::TotpCodeRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TotpCodeRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::TotpCodeRequest) -> types::builder::TotpCodeRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/totp/enable`"]
        pub async fn send(self) -> Result<ResponseValue<types::TotpEnableResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TotpCodeRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/totp/enable", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "enable_totp",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::setup_totp`]\n\n[`ClientAuthExt::setup_totp`]: super::ClientAuthExt::setup_totp"]
    #[derive(Debug, Clone)]
    pub struct SetupTotp<'a> {
        client: &'a super::Client,
    }
    impl<'a> SetupTotp<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/totp/setup`"]
        pub async fn send(self) -> Result<ResponseValue<types::TotpSetupResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/auth/totp/setup", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "setup_totp",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::verify_totp`]\n\n[`ClientAuthExt::verify_totp`]: super::ClientAuthExt::verify_totp"]
    #[derive(Debug, Clone)]
    pub struct VerifyTotp<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TotpVerifyRequest, String>,
    }
    impl<'a> VerifyTotp<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TotpVerifyRequest>,
            <V as std::convert::TryInto<types::TotpVerifyRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TotpVerifyRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TotpVerifyRequest,
                ) -> types::builder::TotpVerifyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/auth/totp/verify`"]
        pub async fn send(self) -> Result<ResponseValue<types::LoginResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TotpVerifyRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/auth/totp/verify", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "verify_totp",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientBuildsExt::list_builds`]\n\n[`ClientBuildsExt::list_builds`]: super::ClientBuildsExt::list_builds"]
    #[derive(Debug, Clone)]
    pub struct ListBuilds<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        search: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<::std::string::String>, String>,
        sort_order: Result<Option<::std::string::String>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListBuilds<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                search: Ok(None),
                sort_by: Ok(None),
                sort_order: Ok(None),
                status: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn search<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.search = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for search failed".to_string()
            });
            self
        }
        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.sort_by = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for sort_by failed".to_string()
            });
            self
        }
        pub fn sort_order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.sort_order = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for sort_order failed".to_string()
            });
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/builds`"]
        pub async fn send(self) -> Result<ResponseValue<types::BuildListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                search,
                sort_by,
                sort_order,
                status,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let search = search.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let sort_order = sort_order.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/builds", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("search", &search))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new(
                    "sort_order",
                    &sort_order,
                ))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_builds",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientBuildsExt::create_build`]\n\n[`ClientBuildsExt::create_build`]: super::ClientBuildsExt::create_build"]
    #[derive(Debug, Clone)]
    pub struct CreateBuild<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateBuildRequest, String>,
    }
    impl<'a> CreateBuild<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateBuildRequest>,
            <V as std::convert::TryInto<types::CreateBuildRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateBuildRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateBuildRequest,
                ) -> types::builder::CreateBuildRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/builds`"]
        pub async fn send(self) -> Result<ResponseValue<types::BuildResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateBuildRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/builds", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_build",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientBuildsExt::get_build_diff`]\n\n[`ClientBuildsExt::get_build_diff`]: super::ClientBuildsExt::get_build_diff"]
    #[derive(Debug, Clone)]
    pub struct GetBuildDiff<'a> {
        client: &'a super::Client,
        build_a: Result<::uuid::Uuid, String>,
        build_b: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetBuildDiff<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                build_a: Err("build_a was not initialized".to_string()),
                build_b: Err("build_b was not initialized".to_string()),
            }
        }
        pub fn build_a<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.build_a = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for build_a failed".to_string());
            self
        }
        pub fn build_b<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.build_b = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for build_b failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/builds/diff`"]
        pub async fn send(self) -> Result<ResponseValue<types::BuildDiffResponse>, Error<()>> {
            let Self {
                client,
                build_a,
                build_b,
            } = self;
            let build_a = build_a.map_err(Error::InvalidRequest)?;
            let build_b = build_b.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/builds/diff", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("build_a", &build_a))
                .query(&progenitor_client::QueryParam::new("build_b", &build_b))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_build_diff",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientBuildsExt::get_build`]\n\n[`ClientBuildsExt::get_build`]: super::ClientBuildsExt::get_build"]
    #[derive(Debug, Clone)]
    pub struct GetBuild<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetBuild<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/builds/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::BuildResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/builds/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_build",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientBuildsExt::update_build`]\n\n[`ClientBuildsExt::update_build`]: super::ClientBuildsExt::update_build"]
    #[derive(Debug, Clone)]
    pub struct UpdateBuild<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateBuildRequest, String>,
    }
    impl<'a> UpdateBuild<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateBuildRequest>,
            <V as std::convert::TryInto<types::UpdateBuildRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateBuildRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateBuildRequest,
                ) -> types::builder::UpdateBuildRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/builds/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::BuildResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateBuildRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/builds/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_build",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientBuildsExt::add_build_artifacts`]\n\n[`ClientBuildsExt::add_build_artifacts`]: super::ClientBuildsExt::add_build_artifacts"]
    #[derive(Debug, Clone)]
    pub struct AddBuildArtifacts<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::AddBuildArtifactsRequest, String>,
    }
    impl<'a> AddBuildArtifacts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AddBuildArtifactsRequest>,
            <V as std::convert::TryInto<types::AddBuildArtifactsRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `AddBuildArtifactsRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AddBuildArtifactsRequest,
                ) -> types::builder::AddBuildArtifactsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/builds/{id}/artifacts`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AddBuildArtifactsResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::AddBuildArtifactsRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/builds/{}/artifacts",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "add_build_artifacts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::update_analysis`]\n\n[`ClientSecurityExt::update_analysis`]: super::ClientSecurityExt::update_analysis"]
    #[derive(Debug, Clone)]
    pub struct UpdateAnalysis<'a> {
        client: &'a super::Client,
        body: Result<types::builder::UpdateAnalysisBody, String>,
    }
    impl<'a> UpdateAnalysis<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateAnalysisBody>,
            <V as std::convert::TryInto<types::UpdateAnalysisBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateAnalysisBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateAnalysisBody,
                ) -> types::builder::UpdateAnalysisBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/dependency-track/analysis`"]
        pub async fn send(self) -> Result<ResponseValue<types::DtAnalysisResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::UpdateAnalysisBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/dependency-track/analysis", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_analysis",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_portfolio_metrics`]\n\n[`ClientSecurityExt::get_portfolio_metrics`]: super::ClientSecurityExt::get_portfolio_metrics"]
    #[derive(Debug, Clone)]
    pub struct GetPortfolioMetrics<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetPortfolioMetrics<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/metrics/portfolio`"]
        pub async fn send(self) -> Result<ResponseValue<types::DtPortfolioMetrics>, Error<()>> {
            let Self { client } = self;
            let url = format!(
                "{}/api/v1/dependency-track/metrics/portfolio",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_portfolio_metrics",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_dependency_track_policies`]\n\n[`ClientSecurityExt::list_dependency_track_policies`]: super::ClientSecurityExt::list_dependency_track_policies"]
    #[derive(Debug, Clone)]
    pub struct ListDependencyTrackPolicies<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListDependencyTrackPolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/policies`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtPolicyFull>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/dependency-track/policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_dependency_track_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_projects`]\n\n[`ClientSecurityExt::list_projects`]: super::ClientSecurityExt::list_projects"]
    #[derive(Debug, Clone)]
    pub struct ListProjects<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListProjects<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtProject>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/dependency-track/projects", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_projects",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_project`]\n\n[`ClientSecurityExt::get_project`]: super::ClientSecurityExt::get_project"]
    #[derive(Debug, Clone)]
    pub struct GetProject<'a> {
        client: &'a super::Client,
        project_uuid: Result<::std::string::String, String>,
    }
    impl<'a> GetProject<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project_uuid: Err("project_uuid was not initialized".to_string()),
            }
        }
        pub fn project_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.project_uuid = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for project_uuid failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtFinding>>, Error<()>> {
            let Self {
                client,
                project_uuid,
            } = self;
            let project_uuid = project_uuid.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/dependency-track/projects/{}",
                client.baseurl,
                encode_path(&project_uuid.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_project",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_project_components`]\n\n[`ClientSecurityExt::get_project_components`]: super::ClientSecurityExt::get_project_components"]
    #[derive(Debug, Clone)]
    pub struct GetProjectComponents<'a> {
        client: &'a super::Client,
        project_uuid: Result<::std::string::String, String>,
    }
    impl<'a> GetProjectComponents<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project_uuid: Err("project_uuid was not initialized".to_string()),
            }
        }
        pub fn project_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.project_uuid = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for project_uuid failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/components`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtComponentFull>>, Error<()>> {
            let Self {
                client,
                project_uuid,
            } = self;
            let project_uuid = project_uuid.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/dependency-track/projects/{}/components",
                client.baseurl,
                encode_path(&project_uuid.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_project_components",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_project_findings`]\n\n[`ClientSecurityExt::get_project_findings`]: super::ClientSecurityExt::get_project_findings"]
    #[derive(Debug, Clone)]
    pub struct GetProjectFindings<'a> {
        client: &'a super::Client,
        project_uuid: Result<::std::string::String, String>,
    }
    impl<'a> GetProjectFindings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project_uuid: Err("project_uuid was not initialized".to_string()),
            }
        }
        pub fn project_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.project_uuid = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for project_uuid failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/findings`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtFinding>>, Error<()>> {
            let Self {
                client,
                project_uuid,
            } = self;
            let project_uuid = project_uuid.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/dependency-track/projects/{}/findings",
                client.baseurl,
                encode_path(&project_uuid.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_project_findings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_project_metrics`]\n\n[`ClientSecurityExt::get_project_metrics`]: super::ClientSecurityExt::get_project_metrics"]
    #[derive(Debug, Clone)]
    pub struct GetProjectMetrics<'a> {
        client: &'a super::Client,
        project_uuid: Result<::std::string::String, String>,
    }
    impl<'a> GetProjectMetrics<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project_uuid: Err("project_uuid was not initialized".to_string()),
            }
        }
        pub fn project_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.project_uuid = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for project_uuid failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/metrics`"]
        pub async fn send(self) -> Result<ResponseValue<types::DtProjectMetrics>, Error<()>> {
            let Self {
                client,
                project_uuid,
            } = self;
            let project_uuid = project_uuid.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/dependency-track/projects/{}/metrics",
                client.baseurl,
                encode_path(&project_uuid.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_project_metrics",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_project_metrics_history`]\n\n[`ClientSecurityExt::get_project_metrics_history`]: super::ClientSecurityExt::get_project_metrics_history"]
    #[derive(Debug, Clone)]
    pub struct GetProjectMetricsHistory<'a> {
        client: &'a super::Client,
        project_uuid: Result<::std::string::String, String>,
        days: Result<Option<i32>, String>,
    }
    impl<'a> GetProjectMetricsHistory<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project_uuid: Err("project_uuid was not initialized".to_string()),
                days: Ok(None),
            }
        }
        pub fn project_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.project_uuid = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for project_uuid failed".to_string()
            });
            self
        }
        pub fn days<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.days = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for days failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/metrics/history`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtProjectMetrics>>, Error<()>> {
            let Self {
                client,
                project_uuid,
                days,
            } = self;
            let project_uuid = project_uuid.map_err(Error::InvalidRequest)?;
            let days = days.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/dependency-track/projects/{}/metrics/history",
                client.baseurl,
                encode_path(&project_uuid.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("days", &days))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_project_metrics_history",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_project_violations`]\n\n[`ClientSecurityExt::get_project_violations`]: super::ClientSecurityExt::get_project_violations"]
    #[derive(Debug, Clone)]
    pub struct GetProjectViolations<'a> {
        client: &'a super::Client,
        project_uuid: Result<::std::string::String, String>,
    }
    impl<'a> GetProjectViolations<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project_uuid: Err("project_uuid was not initialized".to_string()),
            }
        }
        pub fn project_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.project_uuid = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for project_uuid failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/projects/{project_uuid}/violations`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DtPolicyViolation>>, Error<()>> {
            let Self {
                client,
                project_uuid,
            } = self;
            let project_uuid = project_uuid.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/dependency-track/projects/{}/violations",
                client.baseurl,
                encode_path(&project_uuid.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_project_violations",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::dt_status`]\n\n[`ClientSecurityExt::dt_status`]: super::ClientSecurityExt::dt_status"]
    #[derive(Debug, Clone)]
    pub struct DtStatus<'a> {
        client: &'a super::Client,
    }
    impl<'a> DtStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/dependency-track/status`"]
        pub async fn send(self) -> Result<ResponseValue<types::DtStatusResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/dependency-track/status", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "dt_status",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::list_format_handlers`]\n\n[`ClientPluginsExt::list_format_handlers`]: super::ClientPluginsExt::list_format_handlers"]
    #[derive(Debug, Clone)]
    pub struct ListFormatHandlers<'a> {
        client: &'a super::Client,
        enabled: Result<Option<bool>, String>,
        type_: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListFormatHandlers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                enabled: Ok(None),
                type_: Ok(None),
            }
        }
        pub fn enabled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.enabled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for enabled failed".to_string());
            self
        }
        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.type_ = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for type_ failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/formats`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::FormatHandlerResponse>>, Error<()>>
        {
            let Self {
                client,
                enabled,
                type_,
            } = self;
            let enabled = enabled.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/formats", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("enabled", &enabled))
                .query(&progenitor_client::QueryParam::new("type", &type_))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_format_handlers",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::get_format_handler`]\n\n[`ClientPluginsExt::get_format_handler`]: super::ClientPluginsExt::get_format_handler"]
    #[derive(Debug, Clone)]
    pub struct GetFormatHandler<'a> {
        client: &'a super::Client,
        format_key: Result<::std::string::String, String>,
    }
    impl<'a> GetFormatHandler<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                format_key: Err("format_key was not initialized".to_string()),
            }
        }
        pub fn format_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for format_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/formats/{format_key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::FormatHandlerResponse>, Error<()>> {
            let Self { client, format_key } = self;
            let format_key = format_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/formats/{}",
                client.baseurl,
                encode_path(&format_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_format_handler",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::disable_format_handler`]\n\n[`ClientPluginsExt::disable_format_handler`]: super::ClientPluginsExt::disable_format_handler"]
    #[derive(Debug, Clone)]
    pub struct DisableFormatHandler<'a> {
        client: &'a super::Client,
        format_key: Result<::std::string::String, String>,
    }
    impl<'a> DisableFormatHandler<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                format_key: Err("format_key was not initialized".to_string()),
            }
        }
        pub fn format_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for format_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/formats/{format_key}/disable`"]
        pub async fn send(self) -> Result<ResponseValue<types::FormatHandlerResponse>, Error<()>> {
            let Self { client, format_key } = self;
            let format_key = format_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/formats/{}/disable",
                client.baseurl,
                encode_path(&format_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disable_format_handler",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::enable_format_handler`]\n\n[`ClientPluginsExt::enable_format_handler`]: super::ClientPluginsExt::enable_format_handler"]
    #[derive(Debug, Clone)]
    pub struct EnableFormatHandler<'a> {
        client: &'a super::Client,
        format_key: Result<::std::string::String, String>,
    }
    impl<'a> EnableFormatHandler<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                format_key: Err("format_key was not initialized".to_string()),
            }
        }
        pub fn format_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for format_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/formats/{format_key}/enable`"]
        pub async fn send(self) -> Result<ResponseValue<types::FormatHandlerResponse>, Error<()>> {
            let Self { client, format_key } = self;
            let format_key = format_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/formats/{}/enable",
                client.baseurl,
                encode_path(&format_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "enable_format_handler",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::test_format_handler`]\n\n[`ClientPluginsExt::test_format_handler`]: super::ClientPluginsExt::test_format_handler"]
    #[derive(Debug, Clone)]
    pub struct TestFormatHandler<'a> {
        client: &'a super::Client,
        format_key: Result<::std::string::String, String>,
        body: Result<types::builder::TestFormatRequest, String>,
    }
    impl<'a> TestFormatHandler<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                format_key: Err("format_key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn format_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for format_key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TestFormatRequest>,
            <V as std::convert::TryInto<types::TestFormatRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TestFormatRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TestFormatRequest,
                ) -> types::builder::TestFormatRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/formats/{format_key}/test`"]
        pub async fn send(self) -> Result<ResponseValue<types::TestFormatResponse>, Error<()>> {
            let Self {
                client,
                format_key,
                body,
            } = self;
            let format_key = format_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::TestFormatRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/formats/{}/test",
                client.baseurl,
                encode_path(&format_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "test_format_handler",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::list_groups`]\n\n[`ClientGroupsExt::list_groups`]: super::ClientGroupsExt::list_groups"]
    #[derive(Debug, Clone)]
    pub struct ListGroups<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        search: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListGroups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                search: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn search<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.search = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for search failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/groups`"]
        pub async fn send(self) -> Result<ResponseValue<types::GroupListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                search,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let search = search.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("search", &search))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_groups",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::create_group`]\n\n[`ClientGroupsExt::create_group`]: super::ClientGroupsExt::create_group"]
    #[derive(Debug, Clone)]
    pub struct CreateGroup<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateGroupRequest, String>,
    }
    impl<'a> CreateGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateGroupRequest>,
            <V as std::convert::TryInto<types::CreateGroupRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateGroupRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateGroupRequest,
                ) -> types::builder::CreateGroupRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/groups`"]
        pub async fn send(self) -> Result<ResponseValue<types::GroupResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateGroupRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_group",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::get_group`]\n\n[`ClientGroupsExt::get_group`]: super::ClientGroupsExt::get_group"]
    #[derive(Debug, Clone)]
    pub struct GetGroup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/groups/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GroupResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/groups/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_group",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::update_group`]\n\n[`ClientGroupsExt::update_group`]: super::ClientGroupsExt::update_group"]
    #[derive(Debug, Clone)]
    pub struct UpdateGroup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::CreateGroupRequest, String>,
    }
    impl<'a> UpdateGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateGroupRequest>,
            <V as std::convert::TryInto<types::CreateGroupRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateGroupRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateGroupRequest,
                ) -> types::builder::CreateGroupRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/groups/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GroupResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateGroupRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/groups/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_group",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::delete_group`]\n\n[`ClientGroupsExt::delete_group`]: super::ClientGroupsExt::delete_group"]
    #[derive(Debug, Clone)]
    pub struct DeleteGroup<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/groups/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/groups/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_group",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::add_members`]\n\n[`ClientGroupsExt::add_members`]: super::ClientGroupsExt::add_members"]
    #[derive(Debug, Clone)]
    pub struct AddMembers<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::MembersRequest, String>,
    }
    impl<'a> AddMembers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MembersRequest>,
            <V as std::convert::TryInto<types::MembersRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `MembersRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::MembersRequest) -> types::builder::MembersRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/groups/{id}/members`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::MembersRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/groups/{}/members",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "add_members",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientGroupsExt::remove_members`]\n\n[`ClientGroupsExt::remove_members`]: super::ClientGroupsExt::remove_members"]
    #[derive(Debug, Clone)]
    pub struct RemoveMembers<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::MembersRequest, String>,
    }
    impl<'a> RemoveMembers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MembersRequest>,
            <V as std::convert::TryInto<types::MembersRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `MembersRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::MembersRequest) -> types::builder::MembersRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/groups/{id}/members`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::MembersRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/groups/{}/members",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "remove_members",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::list_instances`]\n\n[`ClientAdminExt::list_instances`]: super::ClientAdminExt::list_instances"]
    #[derive(Debug, Clone)]
    pub struct ListInstances<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListInstances<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/instances`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::RemoteInstanceResponse>>, Error<()>>
        {
            let Self { client } = self;
            let url = format!("{}/api/v1/instances", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_instances",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::create_instance`]\n\n[`ClientAdminExt::create_instance`]: super::ClientAdminExt::create_instance"]
    #[derive(Debug, Clone)]
    pub struct CreateInstance<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateInstanceRequest, String>,
    }
    impl<'a> CreateInstance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateInstanceRequest>,
            <V as std::convert::TryInto<types::CreateInstanceRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateInstanceRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateInstanceRequest,
                ) -> types::builder::CreateInstanceRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/instances`"]
        pub async fn send(self) -> Result<ResponseValue<types::RemoteInstanceResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateInstanceRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/instances", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_instance",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::delete_instance`]\n\n[`ClientAdminExt::delete_instance`]: super::ClientAdminExt::delete_instance"]
    #[derive(Debug, Clone)]
    pub struct DeleteInstance<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteInstance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/instances/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/instances/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_instance",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::proxy_get`]\n\n[`ClientAdminExt::proxy_get`]: super::ClientAdminExt::proxy_get"]
    #[derive(Debug, Clone)]
    pub struct ProxyGet<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        path: Result<::std::string::String, String>,
    }
    impl<'a> ProxyGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/instances/{id}/proxy/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, path } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/instances/{}/proxy/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "proxy_get",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::proxy_put`]\n\n[`ClientAdminExt::proxy_put`]: super::ClientAdminExt::proxy_put"]
    #[derive(Debug)]
    pub struct ProxyPut<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        path: Result<::std::string::String, String>,
        body: Result<reqwest::Body, String>,
    }
    impl<'a> ProxyPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/instances/{id}/proxy/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                path,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/instances/{}/proxy/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::CONTENT_TYPE,
                    ::reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "proxy_put",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::proxy_post`]\n\n[`ClientAdminExt::proxy_post`]: super::ClientAdminExt::proxy_post"]
    #[derive(Debug)]
    pub struct ProxyPost<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        path: Result<::std::string::String, String>,
        body: Result<reqwest::Body, String>,
    }
    impl<'a> ProxyPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/instances/{id}/proxy/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                path,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/instances/{}/proxy/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::CONTENT_TYPE,
                    ::reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "proxy_post",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAdminExt::proxy_delete`]\n\n[`ClientAdminExt::proxy_delete`]: super::ClientAdminExt::proxy_delete"]
    #[derive(Debug, Clone)]
    pub struct ProxyDelete<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        path: Result<::std::string::String, String>,
    }
    impl<'a> ProxyDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/instances/{id}/proxy/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, path } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/instances/{}/proxy/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "proxy_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::list_migrations`]\n\n[`ClientMigrationExt::list_migrations`]: super::ClientMigrationExt::list_migrations"]
    #[derive(Debug, Clone)]
    pub struct ListMigrations<'a> {
        client: &'a super::Client,
        page: Result<Option<i64>, String>,
        per_page: Result<Option<i64>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListMigrations<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                status: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for per_page failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::MigrationJobResponse>>, Error<()>>
        {
            let Self {
                client,
                page,
                per_page,
                status,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/migrations", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_migrations",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::create_migration`]\n\n[`ClientMigrationExt::create_migration`]: super::ClientMigrationExt::create_migration"]
    #[derive(Debug, Clone)]
    pub struct CreateMigration<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateMigrationRequest, String>,
    }
    impl<'a> CreateMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateMigrationRequest>,
            <V as std::convert::TryInto<types::CreateMigrationRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateMigrationRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateMigrationRequest,
                ) -> types::builder::CreateMigrationRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateMigrationRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/migrations", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::list_connections`]\n\n[`ClientMigrationExt::list_connections`]: super::ClientMigrationExt::list_connections"]
    #[derive(Debug, Clone)]
    pub struct ListConnections<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListConnections<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/connections`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ConnectionResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/migrations/connections", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_connections",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::create_connection`]\n\n[`ClientMigrationExt::create_connection`]: super::ClientMigrationExt::create_connection"]
    #[derive(Debug, Clone)]
    pub struct CreateConnection<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateConnectionRequest, String>,
    }
    impl<'a> CreateConnection<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateConnectionRequest>,
            <V as std::convert::TryInto<types::CreateConnectionRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateConnectionRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateConnectionRequest,
                ) -> types::builder::CreateConnectionRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/connections`"]
        pub async fn send(self) -> Result<ResponseValue<types::ConnectionResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateConnectionRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/migrations/connections", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_connection",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::get_connection`]\n\n[`ClientMigrationExt::get_connection`]: super::ClientMigrationExt::get_connection"]
    #[derive(Debug, Clone)]
    pub struct GetConnection<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetConnection<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/connections/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ConnectionResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/connections/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_connection",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::delete_connection`]\n\n[`ClientMigrationExt::delete_connection`]: super::ClientMigrationExt::delete_connection"]
    #[derive(Debug, Clone)]
    pub struct DeleteConnection<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteConnection<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/migrations/connections/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/connections/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_connection",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::list_source_repositories`]\n\n[`ClientMigrationExt::list_source_repositories`]: super::ClientMigrationExt::list_source_repositories"]
    #[derive(Debug, Clone)]
    pub struct ListSourceRepositories<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ListSourceRepositories<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/connections/{id}/repositories`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SourceRepository>>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/connections/{}/repositories",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_source_repositories",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::test_connection`]\n\n[`ClientMigrationExt::test_connection`]: super::ClientMigrationExt::test_connection"]
    #[derive(Debug, Clone)]
    pub struct TestConnection<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> TestConnection<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/connections/{id}/test`"]
        pub async fn send(self) -> Result<ResponseValue<types::ConnectionTestResult>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/connections/{}/test",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "test_connection",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::get_migration`]\n\n[`ClientMigrationExt::get_migration`]: super::ClientMigrationExt::get_migration"]
    #[derive(Debug, Clone)]
    pub struct GetMigration<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::delete_migration`]\n\n[`ClientMigrationExt::delete_migration`]: super::ClientMigrationExt::delete_migration"]
    #[derive(Debug, Clone)]
    pub struct DeleteMigration<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/migrations/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::run_assessment`]\n\n[`ClientMigrationExt::run_assessment`]: super::ClientMigrationExt::run_assessment"]
    #[derive(Debug, Clone)]
    pub struct RunAssessment<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RunAssessment<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/{id}/assess`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/assess",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "run_assessment",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::get_assessment`]\n\n[`ClientMigrationExt::get_assessment`]: super::ClientMigrationExt::get_assessment"]
    #[derive(Debug, Clone)]
    pub struct GetAssessment<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetAssessment<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/{id}/assessment`"]
        pub async fn send(self) -> Result<ResponseValue<types::AssessmentResult>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/assessment",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_assessment",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::cancel_migration`]\n\n[`ClientMigrationExt::cancel_migration`]: super::ClientMigrationExt::cancel_migration"]
    #[derive(Debug, Clone)]
    pub struct CancelMigration<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> CancelMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/{id}/cancel`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/cancel",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "cancel_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::list_migration_items`]\n\n[`ClientMigrationExt::list_migration_items`]: super::ClientMigrationExt::list_migration_items"]
    #[derive(Debug, Clone)]
    pub struct ListMigrationItems<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        item_type: Result<Option<::std::string::String>, String>,
        page: Result<Option<i64>, String>,
        per_page: Result<Option<i64>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListMigrationItems<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                item_type: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                status: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn item_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.item_type = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for item_type failed".to_string()
            });
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for per_page failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/{id}/items`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::MigrationItemResponse>>, Error<()>>
        {
            let Self {
                client,
                id,
                item_type,
                page,
                per_page,
                status,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let item_type = item_type.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/items",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("item_type", &item_type))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_migration_items",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::pause_migration`]\n\n[`ClientMigrationExt::pause_migration`]: super::ClientMigrationExt::pause_migration"]
    #[derive(Debug, Clone)]
    pub struct PauseMigration<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> PauseMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/{id}/pause`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/pause",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "pause_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::get_migration_report`]\n\n[`ClientMigrationExt::get_migration_report`]: super::ClientMigrationExt::get_migration_report"]
    #[derive(Debug, Clone)]
    pub struct GetMigrationReport<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        format: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetMigrationReport<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                format: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for format failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/{id}/report`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MigrationReportResponse>, Error<()>> {
            let Self { client, id, format } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/report",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("format", &format))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_migration_report",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::resume_migration`]\n\n[`ClientMigrationExt::resume_migration`]: super::ClientMigrationExt::resume_migration"]
    #[derive(Debug, Clone)]
    pub struct ResumeMigration<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ResumeMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/{id}/resume`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/resume",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "resume_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::start_migration`]\n\n[`ClientMigrationExt::start_migration`]: super::ClientMigrationExt::start_migration"]
    #[derive(Debug, Clone)]
    pub struct StartMigration<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> StartMigration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/migrations/{id}/start`"]
        pub async fn send(self) -> Result<ResponseValue<types::MigrationJobResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/start",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "start_migration",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientMigrationExt::stream_migration_progress`]\n\n[`ClientMigrationExt::stream_migration_progress`]: super::ClientMigrationExt::stream_migration_progress"]
    #[derive(Debug, Clone)]
    pub struct StreamMigrationProgress<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> StreamMigrationProgress<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/migrations/{id}/stream`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/migrations/{}/stream",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "stream_migration_progress",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPackagesExt::list_packages`]\n\n[`ClientPackagesExt::list_packages`]: super::ClientPackagesExt::list_packages"]
    #[derive(Debug, Clone)]
    pub struct ListPackages<'a> {
        client: &'a super::Client,
        format: Result<Option<::std::string::String>, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        repository_key: Result<Option<::std::string::String>, String>,
        search: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListPackages<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                format: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                repository_key: Ok(None),
                search: Ok(None),
            }
        }
        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for format failed".to_string()
            });
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn repository_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.repository_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for repository_key failed".to_string()
            });
            self
        }
        pub fn search<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.search = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for search failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/packages`"]
        pub async fn send(self) -> Result<ResponseValue<types::PackageListResponse>, Error<()>> {
            let Self {
                client,
                format,
                page,
                per_page,
                repository_key,
                search,
            } = self;
            let format = format.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let repository_key = repository_key.map_err(Error::InvalidRequest)?;
            let search = search.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/packages", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("format", &format))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "repository_key",
                    &repository_key,
                ))
                .query(&progenitor_client::QueryParam::new("search", &search))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_packages",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPackagesExt::get_package`]\n\n[`ClientPackagesExt::get_package`]: super::ClientPackagesExt::get_package"]
    #[derive(Debug, Clone)]
    pub struct GetPackage<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPackage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/packages/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PackageResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/packages/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_package",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPackagesExt::get_package_versions`]\n\n[`ClientPackagesExt::get_package_versions`]: super::ClientPackagesExt::get_package_versions"]
    #[derive(Debug, Clone)]
    pub struct GetPackageVersions<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPackageVersions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/packages/{id}/versions`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PackageVersionsResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/packages/{}/versions",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_package_versions",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::list_peers`]\n\n[`ClientPeersExt::list_peers`]: super::ClientPeersExt::list_peers"]
    #[derive(Debug, Clone)]
    pub struct ListPeers<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        region: Result<Option<::std::string::String>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListPeers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                region: Ok(None),
                status: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn region<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.region = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for region failed".to_string()
            });
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PeerInstanceListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                region,
                status,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let region = region.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/peers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("region", &region))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_peers",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::register_peer`]\n\n[`ClientPeersExt::register_peer`]: super::ClientPeersExt::register_peer"]
    #[derive(Debug, Clone)]
    pub struct RegisterPeer<'a> {
        client: &'a super::Client,
        body: Result<types::builder::RegisterPeerRequest, String>,
    }
    impl<'a> RegisterPeer<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RegisterPeerRequest>,
            <V as std::convert::TryInto<types::RegisterPeerRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `RegisterPeerRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::RegisterPeerRequest,
                ) -> types::builder::RegisterPeerRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers`"]
        pub async fn send(self) -> Result<ResponseValue<types::PeerInstanceResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::RegisterPeerRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/peers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "register_peer",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::announce_peer`]\n\n[`ClientPeersExt::announce_peer`]: super::ClientPeersExt::announce_peer"]
    #[derive(Debug, Clone)]
    pub struct AnnouncePeer<'a> {
        client: &'a super::Client,
        body: Result<types::builder::AnnouncePeerRequest, String>,
    }
    impl<'a> AnnouncePeer<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AnnouncePeerRequest>,
            <V as std::convert::TryInto<types::AnnouncePeerRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AnnouncePeerRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AnnouncePeerRequest,
                ) -> types::builder::AnnouncePeerRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/announce`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::AnnouncePeerRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/peers/announce", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "announce_peer",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_identity`]\n\n[`ClientPeersExt::get_identity`]: super::ClientPeersExt::get_identity"]
    #[derive(Debug, Clone)]
    pub struct GetIdentity<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetIdentity<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/identity`"]
        pub async fn send(self) -> Result<ResponseValue<types::IdentityResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/peers/identity", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_identity",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_peer`]\n\n[`ClientPeersExt::get_peer`]: super::ClientPeersExt::get_peer"]
    #[derive(Debug, Clone)]
    pub struct GetPeer<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPeer<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PeerInstanceResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_peer",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::unregister_peer`]\n\n[`ClientPeersExt::unregister_peer`]: super::ClientPeersExt::unregister_peer"]
    #[derive(Debug, Clone)]
    pub struct UnregisterPeer<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> UnregisterPeer<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/peers/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "unregister_peer",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_chunk_availability`]\n\n[`ClientPeersExt::get_chunk_availability`]: super::ClientPeersExt::get_chunk_availability"]
    #[derive(Debug, Clone)]
    pub struct GetChunkAvailability<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        artifact_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetChunkAvailability<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                artifact_id: Err("artifact_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/chunks/{artifact_id}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ChunkAvailabilityResponse>, Error<()>> {
            let Self {
                client,
                id,
                artifact_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/chunks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_chunk_availability",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::update_chunk_availability`]\n\n[`ClientPeersExt::update_chunk_availability`]: super::ClientPeersExt::update_chunk_availability"]
    #[derive(Debug, Clone)]
    pub struct UpdateChunkAvailability<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        artifact_id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateChunkAvailabilityBody, String>,
    }
    impl<'a> UpdateChunkAvailability<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                artifact_id: Err("artifact_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateChunkAvailabilityBody>,
            <V as std::convert::TryInto<types::UpdateChunkAvailabilityBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateChunkAvailabilityBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateChunkAvailabilityBody,
                ) -> types::builder::UpdateChunkAvailabilityBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/peers/{id}/chunks/{artifact_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                artifact_id,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateChunkAvailabilityBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/chunks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_chunk_availability",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_peers_with_chunks`]\n\n[`ClientPeersExt::get_peers_with_chunks`]: super::ClientPeersExt::get_peers_with_chunks"]
    #[derive(Debug, Clone)]
    pub struct GetPeersWithChunks<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        artifact_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPeersWithChunks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                artifact_id: Err("artifact_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/chunks/{artifact_id}/peers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ChunkAvailabilityResponse>>, Error<()>>
        {
            let Self {
                client,
                id,
                artifact_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/chunks/{}/peers",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_peers_with_chunks",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_scored_peers`]\n\n[`ClientPeersExt::get_scored_peers`]: super::ClientPeersExt::get_scored_peers"]
    #[derive(Debug, Clone)]
    pub struct GetScoredPeers<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        artifact_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetScoredPeers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                artifact_id: Err("artifact_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/chunks/{artifact_id}/scored-peers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ScoredPeerResponse>>, Error<()>> {
            let Self {
                client,
                id,
                artifact_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/chunks/{}/scored-peers",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_scored_peers",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::list_peer_connections`]\n\n[`ClientPeersExt::list_peer_connections`]: super::ClientPeersExt::list_peer_connections"]
    #[derive(Debug, Clone)]
    pub struct ListPeerConnections<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListPeerConnections<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                status: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/connections`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::PeerResponse>>, Error<()>> {
            let Self { client, id, status } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/connections",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_peer_connections",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::discover_peers`]\n\n[`ClientPeersExt::discover_peers`]: super::ClientPeersExt::discover_peers"]
    #[derive(Debug, Clone)]
    pub struct DiscoverPeers<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DiscoverPeers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/connections/discover`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::DiscoverablePeerResponse>>, Error<()>>
        {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/connections/discover",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "discover_peers",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::probe_peer`]\n\n[`ClientPeersExt::probe_peer`]: super::ClientPeersExt::probe_peer"]
    #[derive(Debug, Clone)]
    pub struct ProbePeer<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ProbeBody, String>,
    }
    impl<'a> ProbePeer<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProbeBody>,
            <V as std::convert::TryInto<types::ProbeBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProbeBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProbeBody) -> types::builder::ProbeBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/connections/probe`"]
        pub async fn send(self) -> Result<ResponseValue<types::PeerResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProbeBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/connections/probe",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "probe_peer",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::mark_unreachable`]\n\n[`ClientPeersExt::mark_unreachable`]: super::ClientPeersExt::mark_unreachable"]
    #[derive(Debug, Clone)]
    pub struct MarkUnreachable<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        target_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> MarkUnreachable<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                target_id: Err("target_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn target_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.target_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for target_id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/connections/{target_id}/unreachable`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                target_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let target_id = target_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/connections/{}/unreachable",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&target_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "mark_unreachable",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::heartbeat`]\n\n[`ClientPeersExt::heartbeat`]: super::ClientPeersExt::heartbeat"]
    #[derive(Debug, Clone)]
    pub struct Heartbeat<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::HeartbeatRequest, String>,
    }
    impl<'a> Heartbeat<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::HeartbeatRequest>,
            <V as std::convert::TryInto<types::HeartbeatRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `HeartbeatRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::HeartbeatRequest,
                ) -> types::builder::HeartbeatRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/heartbeat`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::HeartbeatRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/heartbeat",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "heartbeat",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeerInstanceLabelsExt::list_labels`]\n\n[`ClientPeerInstanceLabelsExt::list_labels`]: super::ClientPeerInstanceLabelsExt::list_labels"]
    #[derive(Debug, Clone)]
    pub struct ListLabels<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ListLabels<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/labels`"]
        pub async fn send(self) -> Result<ResponseValue<types::PeerLabelsListResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/labels",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_labels",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeerInstanceLabelsExt::set_labels`]\n\n[`ClientPeerInstanceLabelsExt::set_labels`]: super::ClientPeerInstanceLabelsExt::set_labels"]
    #[derive(Debug, Clone)]
    pub struct SetLabels<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::SetPeerLabelsRequest, String>,
    }
    impl<'a> SetLabels<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SetPeerLabelsRequest>,
            <V as std::convert::TryInto<types::SetPeerLabelsRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SetPeerLabelsRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::SetPeerLabelsRequest,
                ) -> types::builder::SetPeerLabelsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/peers/{id}/labels`"]
        pub async fn send(self) -> Result<ResponseValue<types::PeerLabelsListResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SetPeerLabelsRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/labels",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "set_labels",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeerInstanceLabelsExt::add_label`]\n\n[`ClientPeerInstanceLabelsExt::add_label`]: super::ClientPeerInstanceLabelsExt::add_label"]
    #[derive(Debug, Clone)]
    pub struct AddLabel<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        label_key: Result<::std::string::String, String>,
        body: Result<types::builder::AddPeerLabelRequest, String>,
    }
    impl<'a> AddLabel<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                label_key: Err("label_key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn label_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.label_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for label_key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AddPeerLabelRequest>,
            <V as std::convert::TryInto<types::AddPeerLabelRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AddPeerLabelRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AddPeerLabelRequest,
                ) -> types::builder::AddPeerLabelRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/labels/{label_key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PeerLabelResponse>, Error<()>> {
            let Self {
                client,
                id,
                label_key,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let label_key = label_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AddPeerLabelRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/labels/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&label_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "add_label",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeerInstanceLabelsExt::delete_label`]\n\n[`ClientPeerInstanceLabelsExt::delete_label`]: super::ClientPeerInstanceLabelsExt::delete_label"]
    #[derive(Debug, Clone)]
    pub struct DeleteLabel<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        label_key: Result<::std::string::String, String>,
    }
    impl<'a> DeleteLabel<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                label_key: Err("label_key was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn label_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.label_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for label_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/peers/{id}/labels/{label_key}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                label_key,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let label_key = label_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/labels/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&label_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_label",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::update_network_profile`]\n\n[`ClientPeersExt::update_network_profile`]: super::ClientPeersExt::update_network_profile"]
    #[derive(Debug, Clone)]
    pub struct UpdateNetworkProfile<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::NetworkProfileBody, String>,
    }
    impl<'a> UpdateNetworkProfile<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkProfileBody>,
            <V as std::convert::TryInto<types::NetworkProfileBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `NetworkProfileBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::NetworkProfileBody,
                ) -> types::builder::NetworkProfileBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/peers/{id}/network-profile`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::NetworkProfileBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/network-profile",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_network_profile",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_assigned_repos`]\n\n[`ClientPeersExt::get_assigned_repos`]: super::ClientPeersExt::get_assigned_repos"]
    #[derive(Debug, Clone)]
    pub struct GetAssignedRepos<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetAssignedRepos<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/repositories`"]
        pub async fn send(self) -> Result<ResponseValue<::std::vec::Vec<::uuid::Uuid>>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/repositories",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_assigned_repos",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::assign_repo`]\n\n[`ClientPeersExt::assign_repo`]: super::ClientPeersExt::assign_repo"]
    #[derive(Debug, Clone)]
    pub struct AssignRepo<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::AssignRepoRequest, String>,
    }
    impl<'a> AssignRepo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AssignRepoRequest>,
            <V as std::convert::TryInto<types::AssignRepoRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AssignRepoRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AssignRepoRequest,
                ) -> types::builder::AssignRepoRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/repositories`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AssignRepoRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/repositories",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "assign_repo",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::unassign_repo`]\n\n[`ClientPeersExt::unassign_repo`]: super::ClientPeersExt::unassign_repo"]
    #[derive(Debug, Clone)]
    pub struct UnassignRepo<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        repo_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> UnassignRepo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                repo_id: Err("repo_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn repo_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repo_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for repo_id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/peers/{id}/repositories/{repo_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                repo_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let repo_id = repo_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/repositories/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&repo_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "unassign_repo",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::trigger_sync`]\n\n[`ClientPeersExt::trigger_sync`]: super::ClientPeersExt::trigger_sync"]
    #[derive(Debug, Clone)]
    pub struct TriggerSync<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> TriggerSync<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/sync`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/sync",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "trigger_sync",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_sync_tasks`]\n\n[`ClientPeersExt::get_sync_tasks`]: super::ClientPeersExt::get_sync_tasks"]
    #[derive(Debug, Clone)]
    pub struct GetSyncTasks<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        region: Result<Option<::std::string::String>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetSyncTasks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                page: Ok(None),
                per_page: Ok(None),
                region: Ok(None),
                status: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn region<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.region = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for region failed".to_string()
            });
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/sync/tasks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SyncTaskResponse>>, Error<()>> {
            let Self {
                client,
                id,
                page,
                per_page,
                region,
                status,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let region = region.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/sync/tasks",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("region", &region))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_sync_tasks",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::init_transfer`]\n\n[`ClientPeersExt::init_transfer`]: super::ClientPeersExt::init_transfer"]
    #[derive(Debug, Clone)]
    pub struct InitTransfer<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::InitTransferBody, String>,
    }
    impl<'a> InitTransfer<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InitTransferBody>,
            <V as std::convert::TryInto<types::InitTransferBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InitTransferBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::InitTransferBody,
                ) -> types::builder::InitTransferBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/transfer/init`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TransferSessionResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InitTransferBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/init",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "init_transfer",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_session`]\n\n[`ClientPeersExt::get_session`]: super::ClientPeersExt::get_session"]
    #[derive(Debug, Clone)]
    pub struct GetSession<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetSession<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/transfer/{session_id}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TransferSessionResponse>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_session",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::complete_chunk`]\n\n[`ClientPeersExt::complete_chunk`]: super::ClientPeersExt::complete_chunk"]
    #[derive(Debug, Clone)]
    pub struct CompleteChunk<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
        chunk_index: Result<i32, String>,
        body: Result<types::builder::CompleteChunkBody, String>,
    }
    impl<'a> CompleteChunk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
                chunk_index: Err("chunk_index was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        pub fn chunk_index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.chunk_index = value
                .try_into()
                .map_err(|_| "conversion to `i32` for chunk_index failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CompleteChunkBody>,
            <V as std::convert::TryInto<types::CompleteChunkBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CompleteChunkBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CompleteChunkBody,
                ) -> types::builder::CompleteChunkBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/chunk/{chunk_index}/complete`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
                chunk_index,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let chunk_index = chunk_index.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CompleteChunkBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}/chunk/{}/complete",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
                encode_path(&chunk_index.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "complete_chunk",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::fail_chunk`]\n\n[`ClientPeersExt::fail_chunk`]: super::ClientPeersExt::fail_chunk"]
    #[derive(Debug, Clone)]
    pub struct FailChunk<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
        chunk_index: Result<i32, String>,
        body: Result<types::builder::FailBody, String>,
    }
    impl<'a> FailChunk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
                chunk_index: Err("chunk_index was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        pub fn chunk_index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.chunk_index = value
                .try_into()
                .map_err(|_| "conversion to `i32` for chunk_index failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FailBody>,
            <V as std::convert::TryInto<types::FailBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FailBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::FailBody) -> types::builder::FailBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/chunk/{chunk_index}/fail`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
                chunk_index,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let chunk_index = chunk_index.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::FailBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}/chunk/{}/fail",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
                encode_path(&chunk_index.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "fail_chunk",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::retry_chunk`]\n\n[`ClientPeersExt::retry_chunk`]: super::ClientPeersExt::retry_chunk"]
    #[derive(Debug, Clone)]
    pub struct RetryChunk<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
        chunk_index: Result<i32, String>,
    }
    impl<'a> RetryChunk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
                chunk_index: Err("chunk_index was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        pub fn chunk_index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.chunk_index = value
                .try_into()
                .map_err(|_| "conversion to `i32` for chunk_index failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/chunk/{chunk_index}/retry`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
                chunk_index,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let chunk_index = chunk_index.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}/chunk/{}/retry",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
                encode_path(&chunk_index.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "retry_chunk",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_chunk_manifest`]\n\n[`ClientPeersExt::get_chunk_manifest`]: super::ClientPeersExt::get_chunk_manifest"]
    #[derive(Debug, Clone)]
    pub struct GetChunkManifest<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetChunkManifest<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/peers/{id}/transfer/{session_id}/chunks`"]
        pub async fn send(self) -> Result<ResponseValue<types::ChunkManifestResponse>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}/chunks",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_chunk_manifest",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::complete_session`]\n\n[`ClientPeersExt::complete_session`]: super::ClientPeersExt::complete_session"]
    #[derive(Debug, Clone)]
    pub struct CompleteSession<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> CompleteSession<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/complete`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}/complete",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "complete_session",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::fail_session`]\n\n[`ClientPeersExt::fail_session`]: super::ClientPeersExt::fail_session"]
    #[derive(Debug, Clone)]
    pub struct FailSession<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        session_id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::FailBody, String>,
    }
    impl<'a> FailSession<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                session_id: Err("session_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn session_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.session_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for session_id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FailBody>,
            <V as std::convert::TryInto<types::FailBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FailBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::FailBody) -> types::builder::FailBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/peers/{id}/transfer/{session_id}/fail`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                session_id,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let session_id = session_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::FailBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/peers/{}/transfer/{}/fail",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&session_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "fail_session",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPermissionsExt::list_permissions`]\n\n[`ClientPermissionsExt::list_permissions`]: super::ClientPermissionsExt::list_permissions"]
    #[derive(Debug, Clone)]
    pub struct ListPermissions<'a> {
        client: &'a super::Client,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        principal_id: Result<Option<::uuid::Uuid>, String>,
        principal_type: Result<Option<::std::string::String>, String>,
        target_id: Result<Option<::uuid::Uuid>, String>,
        target_type: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListPermissions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page: Ok(None),
                per_page: Ok(None),
                principal_id: Ok(None),
                principal_type: Ok(None),
                target_id: Ok(None),
                target_type: Ok(None),
            }
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn principal_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.principal_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for principal_id failed".to_string());
            self
        }
        pub fn principal_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.principal_type = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for principal_type failed".to_string()
            });
            self
        }
        pub fn target_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.target_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for target_id failed".to_string());
            self
        }
        pub fn target_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.target_type = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for target_type failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/permissions`"]
        pub async fn send(self) -> Result<ResponseValue<types::PermissionListResponse>, Error<()>> {
            let Self {
                client,
                page,
                per_page,
                principal_id,
                principal_type,
                target_id,
                target_type,
            } = self;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let principal_id = principal_id.map_err(Error::InvalidRequest)?;
            let principal_type = principal_type.map_err(Error::InvalidRequest)?;
            let target_id = target_id.map_err(Error::InvalidRequest)?;
            let target_type = target_type.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/permissions", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "principal_id",
                    &principal_id,
                ))
                .query(&progenitor_client::QueryParam::new(
                    "principal_type",
                    &principal_type,
                ))
                .query(&progenitor_client::QueryParam::new("target_id", &target_id))
                .query(&progenitor_client::QueryParam::new(
                    "target_type",
                    &target_type,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_permissions",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPermissionsExt::create_permission`]\n\n[`ClientPermissionsExt::create_permission`]: super::ClientPermissionsExt::create_permission"]
    #[derive(Debug, Clone)]
    pub struct CreatePermission<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreatePermissionRequest, String>,
    }
    impl<'a> CreatePermission<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePermissionRequest>,
            <V as std::convert::TryInto<types::CreatePermissionRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreatePermissionRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreatePermissionRequest,
                ) -> types::builder::CreatePermissionRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/permissions`"]
        pub async fn send(self) -> Result<ResponseValue<types::PermissionResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreatePermissionRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/permissions", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_permission",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPermissionsExt::get_permission`]\n\n[`ClientPermissionsExt::get_permission`]: super::ClientPermissionsExt::get_permission"]
    #[derive(Debug, Clone)]
    pub struct GetPermission<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPermission<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/permissions/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PermissionResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/permissions/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_permission",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPermissionsExt::update_permission`]\n\n[`ClientPermissionsExt::update_permission`]: super::ClientPermissionsExt::update_permission"]
    #[derive(Debug, Clone)]
    pub struct UpdatePermission<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::CreatePermissionRequest, String>,
    }
    impl<'a> UpdatePermission<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePermissionRequest>,
            <V as std::convert::TryInto<types::CreatePermissionRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreatePermissionRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreatePermissionRequest,
                ) -> types::builder::CreatePermissionRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/permissions/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PermissionResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::CreatePermissionRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/permissions/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_permission",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPermissionsExt::delete_permission`]\n\n[`ClientPermissionsExt::delete_permission`]: super::ClientPermissionsExt::delete_permission"]
    #[derive(Debug, Clone)]
    pub struct DeletePermission<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeletePermission<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/permissions/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/permissions/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_permission",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::list_plugins`]\n\n[`ClientPluginsExt::list_plugins`]: super::ClientPluginsExt::list_plugins"]
    #[derive(Debug, Clone)]
    pub struct ListPlugins<'a> {
        client: &'a super::Client,
        status: Result<Option<::std::string::String>, String>,
        type_: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListPlugins<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                status: Ok(None),
                type_: Ok(None),
            }
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.type_ = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for type_ failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/plugins`"]
        pub async fn send(self) -> Result<ResponseValue<types::PluginListResponse>, Error<()>> {
            let Self {
                client,
                status,
                type_,
            } = self;
            let status = status.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/plugins", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("status", &status))
                .query(&progenitor_client::QueryParam::new("type", &type_))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_plugins",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::install_from_git`]\n\n[`ClientPluginsExt::install_from_git`]: super::ClientPluginsExt::install_from_git"]
    #[derive(Debug, Clone)]
    pub struct InstallFromGit<'a> {
        client: &'a super::Client,
        body: Result<types::builder::InstallFromGitRequest, String>,
    }
    impl<'a> InstallFromGit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstallFromGitRequest>,
            <V as std::convert::TryInto<types::InstallFromGitRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InstallFromGitRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::InstallFromGitRequest,
                ) -> types::builder::InstallFromGitRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/plugins/install/git`"]
        pub async fn send(self) -> Result<ResponseValue<types::PluginInstallResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::InstallFromGitRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/plugins/install/git", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "install_from_git",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::install_from_local`]\n\n[`ClientPluginsExt::install_from_local`]: super::ClientPluginsExt::install_from_local"]
    #[derive(Debug, Clone)]
    pub struct InstallFromLocal<'a> {
        client: &'a super::Client,
        body: Result<types::builder::InstallFromLocalRequest, String>,
    }
    impl<'a> InstallFromLocal<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstallFromLocalRequest>,
            <V as std::convert::TryInto<types::InstallFromLocalRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InstallFromLocalRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::InstallFromLocalRequest,
                ) -> types::builder::InstallFromLocalRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/plugins/install/local`"]
        pub async fn send(self) -> Result<ResponseValue<types::PluginInstallResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::InstallFromLocalRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/plugins/install/local", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "install_from_local",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::get_plugin`]\n\n[`ClientPluginsExt::get_plugin`]: super::ClientPluginsExt::get_plugin"]
    #[derive(Debug, Clone)]
    pub struct GetPlugin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPlugin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/plugins/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PluginResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_plugin",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::uninstall_plugin`]\n\n[`ClientPluginsExt::uninstall_plugin`]: super::ClientPluginsExt::uninstall_plugin"]
    #[derive(Debug, Clone)]
    pub struct UninstallPlugin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> UninstallPlugin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/plugins/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "uninstall_plugin",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::get_plugin_config`]\n\n[`ClientPluginsExt::get_plugin_config`]: super::ClientPluginsExt::get_plugin_config"]
    #[derive(Debug, Clone)]
    pub struct GetPluginConfig<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPluginConfig<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/plugins/{id}/config`"]
        pub async fn send(self) -> Result<ResponseValue<types::PluginConfigResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}/config",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_plugin_config",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::update_plugin_config`]\n\n[`ClientPluginsExt::update_plugin_config`]: super::ClientPluginsExt::update_plugin_config"]
    #[derive(Debug, Clone)]
    pub struct UpdatePluginConfig<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdatePluginConfigRequest, String>,
    }
    impl<'a> UpdatePluginConfig<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdatePluginConfigRequest>,
            <V as std::convert::TryInto<types::UpdatePluginConfigRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdatePluginConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdatePluginConfigRequest,
                ) -> types::builder::UpdatePluginConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/plugins/{id}/config`"]
        pub async fn send(self) -> Result<ResponseValue<types::PluginConfigResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdatePluginConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}/config",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_plugin_config",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::disable_plugin`]\n\n[`ClientPluginsExt::disable_plugin`]: super::ClientPluginsExt::disable_plugin"]
    #[derive(Debug, Clone)]
    pub struct DisablePlugin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DisablePlugin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/plugins/{id}/disable`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}/disable",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "disable_plugin",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::enable_plugin`]\n\n[`ClientPluginsExt::enable_plugin`]: super::ClientPluginsExt::enable_plugin"]
    #[derive(Debug, Clone)]
    pub struct EnablePlugin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> EnablePlugin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/plugins/{id}/enable`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}/enable",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "enable_plugin",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::get_plugin_events`]\n\n[`ClientPluginsExt::get_plugin_events`]: super::ClientPluginsExt::get_plugin_events"]
    #[derive(Debug, Clone)]
    pub struct GetPluginEvents<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        limit: Result<Option<i64>, String>,
    }
    impl<'a> GetPluginEvents<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                limit: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/plugins/{id}/events`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<::serde_json::Value>>, Error<()>> {
            let Self { client, id, limit } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}/events",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_plugin_events",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPluginsExt::reload_plugin`]\n\n[`ClientPluginsExt::reload_plugin`]: super::ClientPluginsExt::reload_plugin"]
    #[derive(Debug, Clone)]
    pub struct ReloadPlugin<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ReloadPlugin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/plugins/{id}/reload`"]
        pub async fn send(self) -> Result<ResponseValue<types::WasmPluginResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/plugins/{}/reload",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "reload_plugin",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::list_rules`]\n\n[`ClientPromotionExt::list_rules`]: super::ClientPromotionExt::list_rules"]
    #[derive(Debug, Clone)]
    pub struct ListRules<'a> {
        client: &'a super::Client,
        source_repo_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> ListRules<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                source_repo_id: Ok(None),
            }
        }
        pub fn source_repo_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.source_repo_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for source_repo_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/promotion-rules`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PromotionRuleListResponse>, Error<()>> {
            let Self {
                client,
                source_repo_id,
            } = self;
            let source_repo_id = source_repo_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/promotion-rules", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "source_repo_id",
                    &source_repo_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_rules",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::create_rule`]\n\n[`ClientPromotionExt::create_rule`]: super::ClientPromotionExt::create_rule"]
    #[derive(Debug, Clone)]
    pub struct CreateRule<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateRuleRequest, String>,
    }
    impl<'a> CreateRule<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateRuleRequest>,
            <V as std::convert::TryInto<types::CreateRuleRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateRuleRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateRuleRequest,
                ) -> types::builder::CreateRuleRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/promotion-rules`"]
        pub async fn send(self) -> Result<ResponseValue<types::PromotionRuleResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateRuleRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/promotion-rules", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_rule",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::get_rule`]\n\n[`ClientPromotionExt::get_rule`]: super::ClientPromotionExt::get_rule"]
    #[derive(Debug, Clone)]
    pub struct GetRule<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetRule<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/promotion-rules/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PromotionRuleResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion-rules/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_rule",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::update_rule`]\n\n[`ClientPromotionExt::update_rule`]: super::ClientPromotionExt::update_rule"]
    #[derive(Debug, Clone)]
    pub struct UpdateRule<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateRuleRequest, String>,
    }
    impl<'a> UpdateRule<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateRuleRequest>,
            <V as std::convert::TryInto<types::UpdateRuleRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateRuleRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateRuleRequest,
                ) -> types::builder::UpdateRuleRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/promotion-rules/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PromotionRuleResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateRuleRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion-rules/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_rule",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::delete_rule`]\n\n[`ClientPromotionExt::delete_rule`]: super::ClientPromotionExt::delete_rule"]
    #[derive(Debug, Clone)]
    pub struct DeleteRule<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteRule<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/promotion-rules/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion-rules/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_rule",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::evaluate_rule`]\n\n[`ClientPromotionExt::evaluate_rule`]: super::ClientPromotionExt::evaluate_rule"]
    #[derive(Debug, Clone)]
    pub struct EvaluateRule<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> EvaluateRule<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/promotion-rules/{id}/evaluate`"]
        pub async fn send(self) -> Result<ResponseValue<types::BulkEvaluationResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion-rules/{}/evaluate",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "evaluate_rule",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::promote_artifact`]\n\n[`ClientPromotionExt::promote_artifact`]: super::ClientPromotionExt::promote_artifact"]
    #[derive(Debug, Clone)]
    pub struct PromoteArtifact<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        artifact_id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::PromoteArtifactRequest, String>,
    }
    impl<'a> PromoteArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                artifact_id: Err("artifact_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PromoteArtifactRequest>,
            <V as std::convert::TryInto<types::PromoteArtifactRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `PromoteArtifactRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::PromoteArtifactRequest,
                ) -> types::builder::PromoteArtifactRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/promotion/repositories/{key}/artifacts/{artifact_id}/promote`"]
        pub async fn send(self) -> Result<ResponseValue<types::PromotionResponse>, Error<()>> {
            let Self {
                client,
                key,
                artifact_id,
                body,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::PromoteArtifactRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion/repositories/{}/artifacts/{}/promote",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "promote_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::reject_artifact`]\n\n[`ClientPromotionExt::reject_artifact`]: super::ClientPromotionExt::reject_artifact"]
    #[derive(Debug, Clone)]
    pub struct RejectArtifact<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        artifact_id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::RejectArtifactRequest, String>,
    }
    impl<'a> RejectArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                artifact_id: Err("artifact_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RejectArtifactRequest>,
            <V as std::convert::TryInto<types::RejectArtifactRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `RejectArtifactRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::RejectArtifactRequest,
                ) -> types::builder::RejectArtifactRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/promotion/repositories/{key}/artifacts/{artifact_id}/reject`"]
        pub async fn send(self) -> Result<ResponseValue<types::RejectionResponse>, Error<()>> {
            let Self {
                client,
                key,
                artifact_id,
                body,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::RejectArtifactRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion/repositories/{}/artifacts/{}/reject",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "reject_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::promote_artifacts_bulk`]\n\n[`ClientPromotionExt::promote_artifacts_bulk`]: super::ClientPromotionExt::promote_artifacts_bulk"]
    #[derive(Debug, Clone)]
    pub struct PromoteArtifactsBulk<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        body: Result<types::builder::BulkPromoteRequest, String>,
    }
    impl<'a> PromoteArtifactsBulk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPromoteRequest>,
            <V as std::convert::TryInto<types::BulkPromoteRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `BulkPromoteRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::BulkPromoteRequest,
                ) -> types::builder::BulkPromoteRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/promotion/repositories/{key}/promote`"]
        pub async fn send(self) -> Result<ResponseValue<types::BulkPromotionResponse>, Error<()>> {
            let Self { client, key, body } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::BulkPromoteRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion/repositories/{}/promote",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "promote_artifacts_bulk",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPromotionExt::promotion_history`]\n\n[`ClientPromotionExt::promotion_history`]: super::ClientPromotionExt::promotion_history"]
    #[derive(Debug, Clone)]
    pub struct PromotionHistory<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        artifact_id: Result<Option<::uuid::Uuid>, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> PromotionHistory<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                artifact_id: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                status: Ok(None),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/promotion/repositories/{key}/promotion-history`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PromotionHistoryResponse>, Error<()>> {
            let Self {
                client,
                key,
                artifact_id,
                page,
                per_page,
                status,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/promotion/repositories/{}/promotion-history",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "artifact_id",
                    &artifact_id,
                ))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "promotion_history",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::list_checks`]\n\n[`ClientQualityExt::list_checks`]: super::ClientQualityExt::list_checks"]
    #[derive(Debug, Clone)]
    pub struct ListChecks<'a> {
        client: &'a super::Client,
        artifact_id: Result<Option<::uuid::Uuid>, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> ListChecks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Ok(None),
                repository_id: Ok(None),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/checks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::CheckResponse>>, Error<()>> {
            let Self {
                client,
                artifact_id,
                repository_id,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/quality/checks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "artifact_id",
                    &artifact_id,
                ))
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_checks",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::trigger_checks`]\n\n[`ClientQualityExt::trigger_checks`]: super::ClientQualityExt::trigger_checks"]
    #[derive(Debug, Clone)]
    pub struct TriggerChecks<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TriggerChecksRequest, String>,
    }
    impl<'a> TriggerChecks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TriggerChecksRequest>,
            <V as std::convert::TryInto<types::TriggerChecksRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `TriggerChecksRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TriggerChecksRequest,
                ) -> types::builder::TriggerChecksRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/quality/checks/trigger`"]
        pub async fn send(self) -> Result<ResponseValue<types::TriggerChecksResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TriggerChecksRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/quality/checks/trigger", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "trigger_checks",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::get_check`]\n\n[`ClientQualityExt::get_check`]: super::ClientQualityExt::get_check"]
    #[derive(Debug, Clone)]
    pub struct GetCheck<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetCheck<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/checks/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::CheckResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/checks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_check",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::list_check_issues`]\n\n[`ClientQualityExt::list_check_issues`]: super::ClientQualityExt::list_check_issues"]
    #[derive(Debug, Clone)]
    pub struct ListCheckIssues<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ListCheckIssues<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/checks/{id}/issues`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::IssueResponse>>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/checks/{}/issues",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_check_issues",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::list_gates`]\n\n[`ClientQualityExt::list_gates`]: super::ClientQualityExt::list_gates"]
    #[derive(Debug, Clone)]
    pub struct ListGates<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListGates<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/gates`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::GateResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/quality/gates", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_gates",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::create_gate`]\n\n[`ClientQualityExt::create_gate`]: super::ClientQualityExt::create_gate"]
    #[derive(Debug, Clone)]
    pub struct CreateGate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateGateRequest, String>,
    }
    impl<'a> CreateGate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateGateRequest>,
            <V as std::convert::TryInto<types::CreateGateRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateGateRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateGateRequest,
                ) -> types::builder::CreateGateRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/quality/gates`"]
        pub async fn send(self) -> Result<ResponseValue<types::GateResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateGateRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/quality/gates", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_gate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::evaluate_gate`]\n\n[`ClientQualityExt::evaluate_gate`]: super::ClientQualityExt::evaluate_gate"]
    #[derive(Debug, Clone)]
    pub struct EvaluateGate<'a> {
        client: &'a super::Client,
        artifact_id: Result<::uuid::Uuid, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> EvaluateGate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Err("artifact_id was not initialized".to_string()),
                repository_id: Ok(None),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/quality/gates/evaluate/{artifact_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GateEvaluationResponse>, Error<()>> {
            let Self {
                client,
                artifact_id,
                repository_id,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/gates/evaluate/{}",
                client.baseurl,
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "evaluate_gate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::get_gate`]\n\n[`ClientQualityExt::get_gate`]: super::ClientQualityExt::get_gate"]
    #[derive(Debug, Clone)]
    pub struct GetGate<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetGate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/gates/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GateResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/gates/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_gate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::update_gate`]\n\n[`ClientQualityExt::update_gate`]: super::ClientQualityExt::update_gate"]
    #[derive(Debug, Clone)]
    pub struct UpdateGate<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateGateRequest, String>,
    }
    impl<'a> UpdateGate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateGateRequest>,
            <V as std::convert::TryInto<types::UpdateGateRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateGateRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateGateRequest,
                ) -> types::builder::UpdateGateRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/quality/gates/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GateResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateGateRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/gates/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_gate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::delete_gate`]\n\n[`ClientQualityExt::delete_gate`]: super::ClientQualityExt::delete_gate"]
    #[derive(Debug, Clone)]
    pub struct DeleteGate<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteGate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/quality/gates/{id}`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/gates/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_gate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::get_artifact_health`]\n\n[`ClientQualityExt::get_artifact_health`]: super::ClientQualityExt::get_artifact_health"]
    #[derive(Debug, Clone)]
    pub struct GetArtifactHealth<'a> {
        client: &'a super::Client,
        artifact_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetArtifactHealth<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Err("artifact_id was not initialized".to_string()),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/health/artifacts/{artifact_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ArtifactHealthResponse>, Error<()>> {
            let Self {
                client,
                artifact_id,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/health/artifacts/{}",
                client.baseurl,
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_artifact_health",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::get_health_dashboard`]\n\n[`ClientQualityExt::get_health_dashboard`]: super::ClientQualityExt::get_health_dashboard"]
    #[derive(Debug, Clone)]
    pub struct GetHealthDashboard<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetHealthDashboard<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/health/dashboard`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::HealthDashboardResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/quality/health/dashboard", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_health_dashboard",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::get_repo_health`]\n\n[`ClientQualityExt::get_repo_health`]: super::ClientQualityExt::get_repo_health"]
    #[derive(Debug, Clone)]
    pub struct GetRepoHealth<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
    }
    impl<'a> GetRepoHealth<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/quality/health/repositories/{key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RepoHealthResponse>, Error<()>> {
            let Self { client, key } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/health/repositories/{}",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_repo_health",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::suppress_issue`]\n\n[`ClientQualityExt::suppress_issue`]: super::ClientQualityExt::suppress_issue"]
    #[derive(Debug, Clone)]
    pub struct SuppressIssue<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::SuppressIssueRequest, String>,
    }
    impl<'a> SuppressIssue<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SuppressIssueRequest>,
            <V as std::convert::TryInto<types::SuppressIssueRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SuppressIssueRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::SuppressIssueRequest,
                ) -> types::builder::SuppressIssueRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/quality/issues/{id}/suppress`"]
        pub async fn send(self) -> Result<ResponseValue<types::IssueResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SuppressIssueRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/issues/{}/suppress",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "suppress_issue",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientQualityExt::unsuppress_issue`]\n\n[`ClientQualityExt::unsuppress_issue`]: super::ClientQualityExt::unsuppress_issue"]
    #[derive(Debug, Clone)]
    pub struct UnsuppressIssue<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> UnsuppressIssue<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/quality/issues/{id}/suppress`"]
        pub async fn send(self) -> Result<ResponseValue<types::IssueResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/quality/issues/{}/suppress",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "unsuppress_issue",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::list_repositories`]\n\n[`ClientRepositoriesExt::list_repositories`]: super::ClientRepositoriesExt::list_repositories"]
    #[derive(Debug, Clone)]
    pub struct ListRepositories<'a> {
        client: &'a super::Client,
        format: Result<Option<::std::string::String>, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        q: Result<Option<::std::string::String>, String>,
        type_: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListRepositories<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                format: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                q: Ok(None),
                type_: Ok(None),
            }
        }
        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for format failed".to_string()
            });
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: std :: string :: String` for q failed".to_string());
            self
        }
        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.type_ = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for type_ failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories`"]
        pub async fn send(self) -> Result<ResponseValue<types::RepositoryListResponse>, Error<()>> {
            let Self {
                client,
                format,
                page,
                per_page,
                q,
                type_,
            } = self;
            let format = format.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/repositories", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("format", &format))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("q", &q))
                .query(&progenitor_client::QueryParam::new("type", &type_))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_repositories",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::create_repository`]\n\n[`ClientRepositoriesExt::create_repository`]: super::ClientRepositoriesExt::create_repository"]
    #[derive(Debug, Clone)]
    pub struct CreateRepository<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateRepositoryRequest, String>,
    }
    impl<'a> CreateRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateRepositoryRequest>,
            <V as std::convert::TryInto<types::CreateRepositoryRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateRepositoryRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateRepositoryRequest,
                ) -> types::builder::CreateRepositoryRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/repositories`"]
        pub async fn send(self) -> Result<ResponseValue<types::RepositoryResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateRepositoryRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/repositories", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_repository",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::get_repository`]\n\n[`ClientRepositoriesExt::get_repository`]: super::ClientRepositoriesExt::get_repository"]
    #[derive(Debug, Clone)]
    pub struct GetRepository<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
    }
    impl<'a> GetRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RepositoryResponse>, Error<()>> {
            let Self { client, key } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_repository",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::delete_repository`]\n\n[`ClientRepositoriesExt::delete_repository`]: super::ClientRepositoriesExt::delete_repository"]
    #[derive(Debug, Clone)]
    pub struct DeleteRepository<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
    }
    impl<'a> DeleteRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/repositories/{key}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, key } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_repository",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::update_repository`]\n\n[`ClientRepositoriesExt::update_repository`]: super::ClientRepositoriesExt::update_repository"]
    #[derive(Debug, Clone)]
    pub struct UpdateRepository<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        body: Result<types::builder::UpdateRepositoryRequest, String>,
    }
    impl<'a> UpdateRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateRepositoryRequest>,
            <V as std::convert::TryInto<types::UpdateRepositoryRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateRepositoryRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateRepositoryRequest,
                ) -> types::builder::UpdateRepositoryRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/api/v1/repositories/{key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RepositoryResponse>, Error<()>> {
            let Self { client, key, body } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateRepositoryRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_repository",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::list_artifacts`]\n\n[`ClientRepositoriesExt::list_artifacts`]: super::ClientRepositoriesExt::list_artifacts"]
    #[derive(Debug, Clone)]
    pub struct ListArtifacts<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        page: Result<Option<i32>, String>,
        path_prefix: Result<Option<::std::string::String>, String>,
        per_page: Result<Option<i32>, String>,
        q: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListArtifacts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                page: Ok(None),
                path_prefix: Ok(None),
                per_page: Ok(None),
                q: Ok(None),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn path_prefix<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path_prefix = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for path_prefix failed".to_string()
            });
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: std :: string :: String` for q failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/artifacts`"]
        pub async fn send(self) -> Result<ResponseValue<types::ArtifactListResponse>, Error<()>> {
            let Self {
                client,
                key,
                page,
                path_prefix,
                per_page,
                q,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let path_prefix = path_prefix.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/artifacts",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new(
                    "path_prefix",
                    &path_prefix,
                ))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("q", &q))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_artifacts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::get_repository_artifact_metadata`]\n\n[`ClientRepositoriesExt::get_repository_artifact_metadata`]: super::ClientRepositoriesExt::get_repository_artifact_metadata"]
    #[derive(Debug, Clone)]
    pub struct GetRepositoryArtifactMetadata<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        path: Result<::std::string::String, String>,
    }
    impl<'a> GetRepositoryArtifactMetadata<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/artifacts/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ArtifactResponse>, Error<()>> {
            let Self { client, key, path } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/artifacts/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_repository_artifact_metadata",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::upload_artifact`]\n\n[`ClientRepositoriesExt::upload_artifact`]: super::ClientRepositoriesExt::upload_artifact"]
    #[derive(Debug)]
    pub struct UploadArtifact<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        path: Result<::std::string::String, String>,
        body: Result<reqwest::Body, String>,
    }
    impl<'a> UploadArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/repositories/{key}/artifacts/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ArtifactResponse>, Error<()>> {
            let Self {
                client,
                key,
                path,
                body,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/artifacts/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .header(
                    ::reqwest::header::CONTENT_TYPE,
                    ::reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "upload_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::delete_artifact`]\n\n[`ClientRepositoriesExt::delete_artifact`]: super::ClientRepositoriesExt::delete_artifact"]
    #[derive(Debug, Clone)]
    pub struct DeleteArtifact<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        path: Result<::std::string::String, String>,
    }
    impl<'a> DeleteArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/repositories/{key}/artifacts/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, key, path } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/artifacts/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::download_artifact`]\n\n[`ClientRepositoriesExt::download_artifact`]: super::ClientRepositoriesExt::download_artifact"]
    #[derive(Debug, Clone)]
    pub struct DownloadArtifact<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        path: Result<::std::string::String, String>,
    }
    impl<'a> DownloadArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                path: Err("path was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/download/{path}`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client, key, path } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/download/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&path.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "download_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::stream(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoryLabelsExt::list_repo_labels`]\n\n[`ClientRepositoryLabelsExt::list_repo_labels`]: super::ClientRepositoryLabelsExt::list_repo_labels"]
    #[derive(Debug, Clone)]
    pub struct ListRepoLabels<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
    }
    impl<'a> ListRepoLabels<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/labels`"]
        pub async fn send(self) -> Result<ResponseValue<types::LabelsListResponse>, Error<()>> {
            let Self { client, key } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/labels",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_repo_labels",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoryLabelsExt::set_repo_labels`]\n\n[`ClientRepositoryLabelsExt::set_repo_labels`]: super::ClientRepositoryLabelsExt::set_repo_labels"]
    #[derive(Debug, Clone)]
    pub struct SetRepoLabels<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        body: Result<types::builder::SetLabelsRequest, String>,
    }
    impl<'a> SetRepoLabels<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SetLabelsRequest>,
            <V as std::convert::TryInto<types::SetLabelsRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SetLabelsRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::SetLabelsRequest,
                ) -> types::builder::SetLabelsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/repositories/{key}/labels`"]
        pub async fn send(self) -> Result<ResponseValue<types::LabelsListResponse>, Error<()>> {
            let Self { client, key, body } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SetLabelsRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/labels",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "set_repo_labels",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoryLabelsExt::add_repo_label`]\n\n[`ClientRepositoryLabelsExt::add_repo_label`]: super::ClientRepositoryLabelsExt::add_repo_label"]
    #[derive(Debug, Clone)]
    pub struct AddRepoLabel<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        label_key: Result<::std::string::String, String>,
        body: Result<types::builder::AddLabelRequest, String>,
    }
    impl<'a> AddRepoLabel<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                label_key: Err("label_key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn label_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.label_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for label_key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AddLabelRequest>,
            <V as std::convert::TryInto<types::AddLabelRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AddLabelRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::AddLabelRequest) -> types::builder::AddLabelRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/repositories/{key}/labels/{label_key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::LabelResponse>, Error<()>> {
            let Self {
                client,
                key,
                label_key,
                body,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let label_key = label_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AddLabelRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/labels/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&label_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "add_repo_label",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoryLabelsExt::delete_repo_label`]\n\n[`ClientRepositoryLabelsExt::delete_repo_label`]: super::ClientRepositoryLabelsExt::delete_repo_label"]
    #[derive(Debug, Clone)]
    pub struct DeleteRepoLabel<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        label_key: Result<::std::string::String, String>,
    }
    impl<'a> DeleteRepoLabel<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                label_key: Err("label_key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn label_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.label_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for label_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/repositories/{key}/labels/{label_key}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                key,
                label_key,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let label_key = label_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/labels/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&label_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_repo_label",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::list_virtual_members`]\n\n[`ClientRepositoriesExt::list_virtual_members`]: super::ClientRepositoriesExt::list_virtual_members"]
    #[derive(Debug, Clone)]
    pub struct ListVirtualMembers<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
    }
    impl<'a> ListVirtualMembers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/members`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VirtualMembersListResponse>, Error<()>> {
            let Self { client, key } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/members",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_virtual_members",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::update_virtual_members`]\n\n[`ClientRepositoriesExt::update_virtual_members`]: super::ClientRepositoriesExt::update_virtual_members"]
    #[derive(Debug, Clone)]
    pub struct UpdateVirtualMembers<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        body: Result<types::builder::UpdateVirtualMembersRequest, String>,
    }
    impl<'a> UpdateVirtualMembers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateVirtualMembersRequest>,
            <V as std::convert::TryInto<types::UpdateVirtualMembersRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateVirtualMembersRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateVirtualMembersRequest,
                ) -> types::builder::UpdateVirtualMembersRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/repositories/{key}/members`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VirtualMembersListResponse>, Error<()>> {
            let Self { client, key, body } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateVirtualMembersRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/members",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_virtual_members",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::add_virtual_member`]\n\n[`ClientRepositoriesExt::add_virtual_member`]: super::ClientRepositoriesExt::add_virtual_member"]
    #[derive(Debug, Clone)]
    pub struct AddVirtualMember<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        body: Result<types::builder::AddVirtualMemberRequest, String>,
    }
    impl<'a> AddVirtualMember<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AddVirtualMemberRequest>,
            <V as std::convert::TryInto<types::AddVirtualMemberRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `AddVirtualMemberRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AddVirtualMemberRequest,
                ) -> types::builder::AddVirtualMemberRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/repositories/{key}/members`"]
        pub async fn send(self) -> Result<ResponseValue<types::VirtualMemberResponse>, Error<()>> {
            let Self { client, key, body } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::AddVirtualMemberRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/members",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "add_virtual_member",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::remove_virtual_member`]\n\n[`ClientRepositoriesExt::remove_virtual_member`]: super::ClientRepositoriesExt::remove_virtual_member"]
    #[derive(Debug, Clone)]
    pub struct RemoveVirtualMember<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        member_key: Result<::std::string::String, String>,
    }
    impl<'a> RemoveVirtualMember<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                member_key: Err("member_key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn member_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.member_key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for member_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/repositories/{key}/members/{member_key}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                key,
                member_key,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let member_key = member_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/members/{}",
                client.baseurl,
                encode_path(&key.to_string()),
                encode_path(&member_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "remove_virtual_member",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_repo_security`]\n\n[`ClientSecurityExt::get_repo_security`]: super::ClientSecurityExt::get_repo_security"]
    #[derive(Debug, Clone)]
    pub struct GetRepoSecurity<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
    }
    impl<'a> GetRepoSecurity<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/security`"]
        pub async fn send(self) -> Result<ResponseValue<types::RepoSecurityResponse>, Error<()>> {
            let Self { client, key } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/security",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_repo_security",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::update_repo_security`]\n\n[`ClientSecurityExt::update_repo_security`]: super::ClientSecurityExt::update_repo_security"]
    #[derive(Debug, Clone)]
    pub struct UpdateRepoSecurity<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        body: Result<types::builder::UpsertScanConfigRequest, String>,
    }
    impl<'a> UpdateRepoSecurity<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpsertScanConfigRequest>,
            <V as std::convert::TryInto<types::UpsertScanConfigRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpsertScanConfigRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpsertScanConfigRequest,
                ) -> types::builder::UpsertScanConfigRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/repositories/{key}/security`"]
        pub async fn send(self) -> Result<ResponseValue<types::ScanConfigResponse>, Error<()>> {
            let Self { client, key, body } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpsertScanConfigRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/security",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_repo_security",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_repo_scans`]\n\n[`ClientSecurityExt::list_repo_scans`]: super::ClientSecurityExt::list_repo_scans"]
    #[derive(Debug, Clone)]
    pub struct ListRepoScans<'a> {
        client: &'a super::Client,
        key: Result<::std::string::String, String>,
        artifact_id: Result<Option<::uuid::Uuid>, String>,
        page: Result<Option<i64>, String>,
        per_page: Result<Option<i64>, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListRepoScans<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key: Err("key was not initialized".to_string()),
                artifact_id: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                repository_id: Ok(None),
                status: Ok(None),
            }
        }
        pub fn key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key failed".to_string()
            });
            self
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for per_page failed".to_string());
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/repositories/{key}/security/scans`"]
        pub async fn send(self) -> Result<ResponseValue<types::ScanListResponse>, Error<()>> {
            let Self {
                client,
                key,
                artifact_id,
                page,
                per_page,
                repository_id,
                status,
            } = self;
            let key = key.map_err(Error::InvalidRequest)?;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/repositories/{}/security/scans",
                client.baseurl,
                encode_path(&key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "artifact_id",
                    &artifact_id,
                ))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_repo_scans",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::list_sboms`]\n\n[`ClientSbomExt::list_sboms`]: super::ClientSbomExt::list_sboms"]
    #[derive(Debug, Clone)]
    pub struct ListSboms<'a> {
        client: &'a super::Client,
        artifact_id: Result<Option<::uuid::Uuid>, String>,
        format: Result<Option<::std::string::String>, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> ListSboms<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Ok(None),
                format: Ok(None),
                repository_id: Ok(None),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for format failed".to_string()
            });
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SbomResponse>>, Error<()>> {
            let Self {
                client,
                artifact_id,
                format,
                repository_id,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sbom", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "artifact_id",
                    &artifact_id,
                ))
                .query(&progenitor_client::QueryParam::new("format", &format))
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_sboms",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::generate_sbom`]\n\n[`ClientSbomExt::generate_sbom`]: super::ClientSbomExt::generate_sbom"]
    #[derive(Debug, Clone)]
    pub struct GenerateSbom<'a> {
        client: &'a super::Client,
        body: Result<types::builder::GenerateSbomRequest, String>,
    }
    impl<'a> GenerateSbom<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GenerateSbomRequest>,
            <V as std::convert::TryInto<types::GenerateSbomRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `GenerateSbomRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::GenerateSbomRequest,
                ) -> types::builder::GenerateSbomRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sbom`"]
        pub async fn send(self) -> Result<ResponseValue<types::SbomResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::GenerateSbomRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sbom", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "generate_sbom",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::get_sbom_by_artifact`]\n\n[`ClientSbomExt::get_sbom_by_artifact`]: super::ClientSbomExt::get_sbom_by_artifact"]
    #[derive(Debug, Clone)]
    pub struct GetSbomByArtifact<'a> {
        client: &'a super::Client,
        artifact_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetSbomByArtifact<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Err("artifact_id was not initialized".to_string()),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/by-artifact/{artifact_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SbomContentResponse>, Error<()>> {
            let Self {
                client,
                artifact_id,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/by-artifact/{}",
                client.baseurl,
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_sbom_by_artifact",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::check_license_compliance`]\n\n[`ClientSbomExt::check_license_compliance`]: super::ClientSbomExt::check_license_compliance"]
    #[derive(Debug, Clone)]
    pub struct CheckLicenseCompliance<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CheckLicenseComplianceRequest, String>,
    }
    impl<'a> CheckLicenseCompliance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CheckLicenseComplianceRequest>,
            <V as std::convert::TryInto<types::CheckLicenseComplianceRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CheckLicenseComplianceRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CheckLicenseComplianceRequest,
                ) -> types::builder::CheckLicenseComplianceRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sbom/check-compliance`"]
        pub async fn send(self) -> Result<ResponseValue<types::LicenseCheckResult>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CheckLicenseComplianceRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sbom/check-compliance", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "check_license_compliance",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::get_cve_history`]\n\n[`ClientSbomExt::get_cve_history`]: super::ClientSbomExt::get_cve_history"]
    #[derive(Debug, Clone)]
    pub struct GetCveHistory<'a> {
        client: &'a super::Client,
        artifact_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetCveHistory<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Err("artifact_id was not initialized".to_string()),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/cve/history/{artifact_id}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::CveHistoryEntry>>, Error<()>> {
            let Self {
                client,
                artifact_id,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/cve/history/{}",
                client.baseurl,
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_cve_history",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::update_cve_status`]\n\n[`ClientSbomExt::update_cve_status`]: super::ClientSbomExt::update_cve_status"]
    #[derive(Debug, Clone)]
    pub struct UpdateCveStatus<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateCveStatusRequest, String>,
    }
    impl<'a> UpdateCveStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateCveStatusRequest>,
            <V as std::convert::TryInto<types::UpdateCveStatusRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateCveStatusRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateCveStatusRequest,
                ) -> types::builder::UpdateCveStatusRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sbom/cve/status/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::CveHistoryEntry>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateCveStatusRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/cve/status/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_cve_status",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::get_cve_trends`]\n\n[`ClientSbomExt::get_cve_trends`]: super::ClientSbomExt::get_cve_trends"]
    #[derive(Debug, Clone)]
    pub struct GetCveTrends<'a> {
        client: &'a super::Client,
        days: Result<Option<i32>, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> GetCveTrends<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                days: Ok(None),
                repository_id: Ok(None),
            }
        }
        pub fn days<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.days = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for days failed".to_string());
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/cve/trends`"]
        pub async fn send(self) -> Result<ResponseValue<types::CveTrends>, Error<()>> {
            let Self {
                client,
                days,
                repository_id,
            } = self;
            let days = days.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sbom/cve/trends", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("days", &days))
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_cve_trends",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::list_license_policies`]\n\n[`ClientSbomExt::list_license_policies`]: super::ClientSbomExt::list_license_policies"]
    #[derive(Debug, Clone)]
    pub struct ListLicensePolicies<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListLicensePolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/license-policies`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::LicensePolicyResponse>>, Error<()>>
        {
            let Self { client } = self;
            let url = format!("{}/api/v1/sbom/license-policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_license_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::upsert_license_policy`]\n\n[`ClientSbomExt::upsert_license_policy`]: super::ClientSbomExt::upsert_license_policy"]
    #[derive(Debug, Clone)]
    pub struct UpsertLicensePolicy<'a> {
        client: &'a super::Client,
        body: Result<types::builder::UpsertLicensePolicyRequest, String>,
    }
    impl<'a> UpsertLicensePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpsertLicensePolicyRequest>,
            <V as std::convert::TryInto<types::UpsertLicensePolicyRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpsertLicensePolicyRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpsertLicensePolicyRequest,
                ) -> types::builder::UpsertLicensePolicyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sbom/license-policies`"]
        pub async fn send(self) -> Result<ResponseValue<types::LicensePolicyResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::UpsertLicensePolicyRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sbom/license-policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "upsert_license_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::get_license_policy`]\n\n[`ClientSbomExt::get_license_policy`]: super::ClientSbomExt::get_license_policy"]
    #[derive(Debug, Clone)]
    pub struct GetLicensePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetLicensePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/license-policies/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::LicensePolicyResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/license-policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_license_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::delete_license_policy`]\n\n[`ClientSbomExt::delete_license_policy`]: super::ClientSbomExt::delete_license_policy"]
    #[derive(Debug, Clone)]
    pub struct DeleteLicensePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteLicensePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/sbom/license-policies/{id}`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/license-policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_license_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::get_sbom`]\n\n[`ClientSbomExt::get_sbom`]: super::ClientSbomExt::get_sbom"]
    #[derive(Debug, Clone)]
    pub struct GetSbom<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetSbom<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SbomContentResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_sbom",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::delete_sbom`]\n\n[`ClientSbomExt::delete_sbom`]: super::ClientSbomExt::delete_sbom"]
    #[derive(Debug, Clone)]
    pub struct DeleteSbom<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteSbom<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/sbom/{id}`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_sbom",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::get_sbom_components`]\n\n[`ClientSbomExt::get_sbom_components`]: super::ClientSbomExt::get_sbom_components"]
    #[derive(Debug, Clone)]
    pub struct GetSbomComponents<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetSbomComponents<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sbom/{id}/components`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ComponentResponse>>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/{}/components",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_sbom_components",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSbomExt::convert_sbom`]\n\n[`ClientSbomExt::convert_sbom`]: super::ClientSbomExt::convert_sbom"]
    #[derive(Debug, Clone)]
    pub struct ConvertSbom<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ConvertSbomRequest, String>,
    }
    impl<'a> ConvertSbom<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ConvertSbomRequest>,
            <V as std::convert::TryInto<types::ConvertSbomRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ConvertSbomRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::ConvertSbomRequest,
                ) -> types::builder::ConvertSbomRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sbom/{id}/convert`"]
        pub async fn send(self) -> Result<ResponseValue<types::SbomResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ConvertSbomRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sbom/{}/convert",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "convert_sbom",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSearchExt::advanced_search`]\n\n[`ClientSearchExt::advanced_search`]: super::ClientSearchExt::advanced_search"]
    #[derive(Debug, Clone)]
    pub struct AdvancedSearch<'a> {
        client: &'a super::Client,
        created_after: Result<Option<::std::string::String>, String>,
        created_before: Result<Option<::std::string::String>, String>,
        format: Result<Option<::std::string::String>, String>,
        max_size: Result<Option<i64>, String>,
        min_size: Result<Option<i64>, String>,
        name: Result<Option<::std::string::String>, String>,
        page: Result<Option<i32>, String>,
        path: Result<Option<::std::string::String>, String>,
        per_page: Result<Option<i32>, String>,
        query: Result<Option<::std::string::String>, String>,
        repository_key: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<::std::string::String>, String>,
        sort_order: Result<Option<::std::string::String>, String>,
        version: Result<Option<::std::string::String>, String>,
    }
    impl<'a> AdvancedSearch<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                created_after: Ok(None),
                created_before: Ok(None),
                format: Ok(None),
                max_size: Ok(None),
                min_size: Ok(None),
                name: Ok(None),
                page: Ok(None),
                path: Ok(None),
                per_page: Ok(None),
                query: Ok(None),
                repository_key: Ok(None),
                sort_by: Ok(None),
                sort_order: Ok(None),
                version: Ok(None),
            }
        }
        pub fn created_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.created_after = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for created_after failed".to_string()
            });
            self
        }
        pub fn created_before<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.created_before = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for created_before failed".to_string()
            });
            self
        }
        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.format = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for format failed".to_string()
            });
            self
        }
        pub fn max_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.max_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for max_size failed".to_string());
            self
        }
        pub fn min_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.min_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for min_size failed".to_string());
            self
        }
        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.name = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for name failed".to_string()
            });
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn query<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.query = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for query failed".to_string()
            });
            self
        }
        pub fn repository_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.repository_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for repository_key failed".to_string()
            });
            self
        }
        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.sort_by = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for sort_by failed".to_string()
            });
            self
        }
        pub fn sort_order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.sort_order = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for sort_order failed".to_string()
            });
            self
        }
        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.version = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for version failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/search/advanced`"]
        pub async fn send(self) -> Result<ResponseValue<types::AdvancedSearchResponse>, Error<()>> {
            let Self {
                client,
                created_after,
                created_before,
                format,
                max_size,
                min_size,
                name,
                page,
                path,
                per_page,
                query,
                repository_key,
                sort_by,
                sort_order,
                version,
            } = self;
            let created_after = created_after.map_err(Error::InvalidRequest)?;
            let created_before = created_before.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let max_size = max_size.map_err(Error::InvalidRequest)?;
            let min_size = min_size.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let query = query.map_err(Error::InvalidRequest)?;
            let repository_key = repository_key.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let sort_order = sort_order.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/search/advanced", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "created_after",
                    &created_after,
                ))
                .query(&progenitor_client::QueryParam::new(
                    "created_before",
                    &created_before,
                ))
                .query(&progenitor_client::QueryParam::new("format", &format))
                .query(&progenitor_client::QueryParam::new("max_size", &max_size))
                .query(&progenitor_client::QueryParam::new("min_size", &min_size))
                .query(&progenitor_client::QueryParam::new("name", &name))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("path", &path))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("query", &query))
                .query(&progenitor_client::QueryParam::new(
                    "repository_key",
                    &repository_key,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new(
                    "sort_order",
                    &sort_order,
                ))
                .query(&progenitor_client::QueryParam::new("version", &version))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "advanced_search",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSearchExt::checksum_search`]\n\n[`ClientSearchExt::checksum_search`]: super::ClientSearchExt::checksum_search"]
    #[derive(Debug, Clone)]
    pub struct ChecksumSearch<'a> {
        client: &'a super::Client,
        algorithm: Result<Option<::std::string::String>, String>,
        checksum: Result<::std::string::String, String>,
    }
    impl<'a> ChecksumSearch<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                algorithm: Ok(None),
                checksum: Err("checksum was not initialized".to_string()),
            }
        }
        pub fn algorithm<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.algorithm = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for algorithm failed".to_string()
            });
            self
        }
        pub fn checksum<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.checksum = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for checksum failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/search/checksum`"]
        pub async fn send(self) -> Result<ResponseValue<types::ChecksumSearchResponse>, Error<()>> {
            let Self {
                client,
                algorithm,
                checksum,
            } = self;
            let algorithm = algorithm.map_err(Error::InvalidRequest)?;
            let checksum = checksum.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/search/checksum", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("algorithm", &algorithm))
                .query(&progenitor_client::QueryParam::new("checksum", &checksum))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "checksum_search",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSearchExt::quick_search`]\n\n[`ClientSearchExt::quick_search`]: super::ClientSearchExt::quick_search"]
    #[derive(Debug, Clone)]
    pub struct QuickSearch<'a> {
        client: &'a super::Client,
        limit: Result<Option<i64>, String>,
        q: Result<Option<::std::string::String>, String>,
        types: Result<Option<::std::string::String>, String>,
    }
    impl<'a> QuickSearch<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                q: Ok(None),
                types: Ok(None),
            }
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: std :: string :: String` for q failed".to_string());
            self
        }
        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.types = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for types failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/search/quick`"]
        pub async fn send(self) -> Result<ResponseValue<types::QuickSearchResponse>, Error<()>> {
            let Self {
                client,
                limit,
                q,
                types,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/search/quick", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("q", &q))
                .query(&progenitor_client::QueryParam::new("types", &types))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "quick_search",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSearchExt::recent`]\n\n[`ClientSearchExt::recent`]: super::ClientSearchExt::recent"]
    #[derive(Debug, Clone)]
    pub struct Recent<'a> {
        client: &'a super::Client,
        limit: Result<Option<i64>, String>,
    }
    impl<'a> Recent<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
            }
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/search/recent`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SearchResultItem>>, Error<()>> {
            let Self { client, limit } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/search/recent", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "recent",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSearchExt::suggest`]\n\n[`ClientSearchExt::suggest`]: super::ClientSearchExt::suggest"]
    #[derive(Debug, Clone)]
    pub struct Suggest<'a> {
        client: &'a super::Client,
        limit: Result<Option<i64>, String>,
        prefix: Result<::std::string::String, String>,
    }
    impl<'a> Suggest<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                prefix: Err("prefix was not initialized".to_string()),
            }
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        pub fn prefix<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.prefix = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for prefix failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/search/suggest`"]
        pub async fn send(self) -> Result<ResponseValue<types::SuggestResponse>, Error<()>> {
            let Self {
                client,
                limit,
                prefix,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let prefix = prefix.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/search/suggest", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("prefix", &prefix))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "suggest",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSearchExt::trending`]\n\n[`ClientSearchExt::trending`]: super::ClientSearchExt::trending"]
    #[derive(Debug, Clone)]
    pub struct Trending<'a> {
        client: &'a super::Client,
        days: Result<Option<i32>, String>,
        limit: Result<Option<i64>, String>,
    }
    impl<'a> Trending<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                days: Ok(None),
                limit: Ok(None),
            }
        }
        pub fn days<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.days = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for days failed".to_string());
            self
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for limit failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/search/trending`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::SearchResultItem>>, Error<()>> {
            let Self {
                client,
                days,
                limit,
            } = self;
            let days = days.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/search/trending", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("days", &days))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "trending",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_artifact_scans`]\n\n[`ClientSecurityExt::list_artifact_scans`]: super::ClientSecurityExt::list_artifact_scans"]
    #[derive(Debug, Clone)]
    pub struct ListArtifactScans<'a> {
        client: &'a super::Client,
        artifact_id: Result<::uuid::Uuid, String>,
        page: Result<Option<i64>, String>,
        per_page: Result<Option<i64>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListArtifactScans<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Err("artifact_id was not initialized".to_string()),
                page: Ok(None),
                per_page: Ok(None),
                status: Ok(None),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for per_page failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/artifacts/{artifact_id}/scans`"]
        pub async fn send(self) -> Result<ResponseValue<types::ScanListResponse>, Error<()>> {
            let Self {
                client,
                artifact_id,
                page,
                per_page,
                status,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/artifacts/{}/scans",
                client.baseurl,
                encode_path(&artifact_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_artifact_scans",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_scan_configs`]\n\n[`ClientSecurityExt::list_scan_configs`]: super::ClientSecurityExt::list_scan_configs"]
    #[derive(Debug, Clone)]
    pub struct ListScanConfigs<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListScanConfigs<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/configs`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ScanConfigResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/security/configs", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_scan_configs",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_dashboard`]\n\n[`ClientSecurityExt::get_dashboard`]: super::ClientSecurityExt::get_dashboard"]
    #[derive(Debug, Clone)]
    pub struct GetDashboard<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetDashboard<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/dashboard`"]
        pub async fn send(self) -> Result<ResponseValue<types::DashboardResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/security/dashboard", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_dashboard",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::acknowledge_finding`]\n\n[`ClientSecurityExt::acknowledge_finding`]: super::ClientSecurityExt::acknowledge_finding"]
    #[derive(Debug, Clone)]
    pub struct AcknowledgeFinding<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::AcknowledgeRequest, String>,
    }
    impl<'a> AcknowledgeFinding<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AcknowledgeRequest>,
            <V as std::convert::TryInto<types::AcknowledgeRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AcknowledgeRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AcknowledgeRequest,
                ) -> types::builder::AcknowledgeRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/security/findings/{id}/acknowledge`"]
        pub async fn send(self) -> Result<ResponseValue<types::FindingResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AcknowledgeRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/findings/{}/acknowledge",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "acknowledge_finding",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::revoke_acknowledgment`]\n\n[`ClientSecurityExt::revoke_acknowledgment`]: super::ClientSecurityExt::revoke_acknowledgment"]
    #[derive(Debug, Clone)]
    pub struct RevokeAcknowledgment<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RevokeAcknowledgment<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/security/findings/{id}/acknowledge`"]
        pub async fn send(self) -> Result<ResponseValue<types::FindingResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/findings/{}/acknowledge",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "revoke_acknowledgment",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_policies`]\n\n[`ClientSecurityExt::list_policies`]: super::ClientSecurityExt::list_policies"]
    #[derive(Debug, Clone)]
    pub struct ListPolicies<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListPolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/policies`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::PolicyResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/security/policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::create_policy`]\n\n[`ClientSecurityExt::create_policy`]: super::ClientSecurityExt::create_policy"]
    #[derive(Debug, Clone)]
    pub struct CreatePolicy<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreatePolicyRequest, String>,
    }
    impl<'a> CreatePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePolicyRequest>,
            <V as std::convert::TryInto<types::CreatePolicyRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreatePolicyRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreatePolicyRequest,
                ) -> types::builder::CreatePolicyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/security/policies`"]
        pub async fn send(self) -> Result<ResponseValue<types::PolicyResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreatePolicyRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/security/policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_policy`]\n\n[`ClientSecurityExt::get_policy`]: super::ClientSecurityExt::get_policy"]
    #[derive(Debug, Clone)]
    pub struct GetPolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/policies/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PolicyResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::update_policy`]\n\n[`ClientSecurityExt::update_policy`]: super::ClientSecurityExt::update_policy"]
    #[derive(Debug, Clone)]
    pub struct UpdatePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdatePolicyRequest, String>,
    }
    impl<'a> UpdatePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdatePolicyRequest>,
            <V as std::convert::TryInto<types::UpdatePolicyRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdatePolicyRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdatePolicyRequest,
                ) -> types::builder::UpdatePolicyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/security/policies/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::PolicyResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdatePolicyRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::delete_policy`]\n\n[`ClientSecurityExt::delete_policy`]: super::ClientSecurityExt::delete_policy"]
    #[derive(Debug, Clone)]
    pub struct DeletePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeletePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/security/policies/{id}`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::trigger_scan`]\n\n[`ClientSecurityExt::trigger_scan`]: super::ClientSecurityExt::trigger_scan"]
    #[derive(Debug, Clone)]
    pub struct TriggerScan<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TriggerScanRequest, String>,
    }
    impl<'a> TriggerScan<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TriggerScanRequest>,
            <V as std::convert::TryInto<types::TriggerScanRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TriggerScanRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TriggerScanRequest,
                ) -> types::builder::TriggerScanRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/security/scan`"]
        pub async fn send(self) -> Result<ResponseValue<types::TriggerScanResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TriggerScanRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/security/scan", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "trigger_scan",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_scans`]\n\n[`ClientSecurityExt::list_scans`]: super::ClientSecurityExt::list_scans"]
    #[derive(Debug, Clone)]
    pub struct ListScans<'a> {
        client: &'a super::Client,
        artifact_id: Result<Option<::uuid::Uuid>, String>,
        page: Result<Option<i64>, String>,
        per_page: Result<Option<i64>, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListScans<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                artifact_id: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                repository_id: Ok(None),
                status: Ok(None),
            }
        }
        pub fn artifact_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.artifact_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for artifact_id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for per_page failed".to_string());
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/scans`"]
        pub async fn send(self) -> Result<ResponseValue<types::ScanListResponse>, Error<()>> {
            let Self {
                client,
                artifact_id,
                page,
                per_page,
                repository_id,
                status,
            } = self;
            let artifact_id = artifact_id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/security/scans", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "artifact_id",
                    &artifact_id,
                ))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_scans",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_scan`]\n\n[`ClientSecurityExt::get_scan`]: super::ClientSecurityExt::get_scan"]
    #[derive(Debug, Clone)]
    pub struct GetScan<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetScan<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/scans/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::ScanResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/scans/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_scan",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::list_findings`]\n\n[`ClientSecurityExt::list_findings`]: super::ClientSecurityExt::list_findings"]
    #[derive(Debug, Clone)]
    pub struct ListFindings<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        page: Result<Option<i64>, String>,
        per_page: Result<Option<i64>, String>,
    }
    impl<'a> ListFindings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                page: Ok(None),
                per_page: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for per_page failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/scans/{id}/findings`"]
        pub async fn send(self) -> Result<ResponseValue<types::FindingListResponse>, Error<()>> {
            let Self {
                client,
                id,
                page,
                per_page,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/security/scans/{}/findings",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_findings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSecurityExt::get_all_scores`]\n\n[`ClientSecurityExt::get_all_scores`]: super::ClientSecurityExt::get_all_scores"]
    #[derive(Debug, Clone)]
    pub struct GetAllScores<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetAllScores<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/security/scores`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::ScoreResponse>>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/security/scores", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_all_scores",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientAuthExt::setup_status`]\n\n[`ClientAuthExt::setup_status`]: super::ClientAuthExt::setup_status"]
    #[derive(Debug, Clone)]
    pub struct SetupStatus<'a> {
        client: &'a super::Client,
    }
    impl<'a> SetupStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/setup/status`"]
        pub async fn send(self) -> Result<ResponseValue<types::SetupStatusResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/setup/status", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "setup_status",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::list_keys`]\n\n[`ClientSigningExt::list_keys`]: super::ClientSigningExt::list_keys"]
    #[derive(Debug, Clone)]
    pub struct ListKeys<'a> {
        client: &'a super::Client,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> ListKeys<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                repository_id: Ok(None),
            }
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/signing/keys`"]
        pub async fn send(self) -> Result<ResponseValue<types::KeyListResponse>, Error<()>> {
            let Self {
                client,
                repository_id,
            } = self;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/signing/keys", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_keys",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::create_key`]\n\n[`ClientSigningExt::create_key`]: super::ClientSigningExt::create_key"]
    #[derive(Debug, Clone)]
    pub struct CreateKey<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateKeyPayload, String>,
    }
    impl<'a> CreateKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateKeyPayload>,
            <V as std::convert::TryInto<types::CreateKeyPayload>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateKeyPayload` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateKeyPayload,
                ) -> types::builder::CreateKeyPayload,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/signing/keys`"]
        pub async fn send(self) -> Result<ResponseValue<types::SigningKeyPublic>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateKeyPayload::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/signing/keys", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::get_key`]\n\n[`ClientSigningExt::get_key`]: super::ClientSigningExt::get_key"]
    #[derive(Debug, Clone)]
    pub struct GetKey<'a> {
        client: &'a super::Client,
        key_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key_id: Err("key_id was not initialized".to_string()),
            }
        }
        pub fn key_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.key_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for key_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/signing/keys/{key_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SigningKeyPublic>, Error<()>> {
            let Self { client, key_id } = self;
            let key_id = key_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/keys/{}",
                client.baseurl,
                encode_path(&key_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::delete_key`]\n\n[`ClientSigningExt::delete_key`]: super::ClientSigningExt::delete_key"]
    #[derive(Debug, Clone)]
    pub struct DeleteKey<'a> {
        client: &'a super::Client,
        key_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key_id: Err("key_id was not initialized".to_string()),
            }
        }
        pub fn key_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.key_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for key_id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/signing/keys/{key_id}`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, key_id } = self;
            let key_id = key_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/keys/{}",
                client.baseurl,
                encode_path(&key_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::get_public_key`]\n\n[`ClientSigningExt::get_public_key`]: super::ClientSigningExt::get_public_key"]
    #[derive(Debug, Clone)]
    pub struct GetPublicKey<'a> {
        client: &'a super::Client,
        key_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetPublicKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key_id: Err("key_id was not initialized".to_string()),
            }
        }
        pub fn key_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.key_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for key_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/signing/keys/{key_id}/public`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client, key_id } = self;
            let key_id = key_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/keys/{}/public",
                client.baseurl,
                encode_path(&key_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "get_public_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::stream(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::revoke_key`]\n\n[`ClientSigningExt::revoke_key`]: super::ClientSigningExt::revoke_key"]
    #[derive(Debug, Clone)]
    pub struct RevokeKey<'a> {
        client: &'a super::Client,
        key_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RevokeKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key_id: Err("key_id was not initialized".to_string()),
            }
        }
        pub fn key_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.key_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for key_id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/signing/keys/{key_id}/revoke`"]
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
            Error<()>,
        > {
            let Self { client, key_id } = self;
            let key_id = key_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/keys/{}/revoke",
                client.baseurl,
                encode_path(&key_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "revoke_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::rotate_key`]\n\n[`ClientSigningExt::rotate_key`]: super::ClientSigningExt::rotate_key"]
    #[derive(Debug, Clone)]
    pub struct RotateKey<'a> {
        client: &'a super::Client,
        key_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RotateKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                key_id: Err("key_id was not initialized".to_string()),
            }
        }
        pub fn key_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.key_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for key_id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/signing/keys/{key_id}/rotate`"]
        pub async fn send(self) -> Result<ResponseValue<types::SigningKeyPublic>, Error<()>> {
            let Self { client, key_id } = self;
            let key_id = key_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/keys/{}/rotate",
                client.baseurl,
                encode_path(&key_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "rotate_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::get_repo_signing_config`]\n\n[`ClientSigningExt::get_repo_signing_config`]: super::ClientSigningExt::get_repo_signing_config"]
    #[derive(Debug, Clone)]
    pub struct GetRepoSigningConfig<'a> {
        client: &'a super::Client,
        repo_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetRepoSigningConfig<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                repo_id: Err("repo_id was not initialized".to_string()),
            }
        }
        pub fn repo_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repo_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for repo_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/signing/repositories/{repo_id}/config`"]
        pub async fn send(self) -> Result<ResponseValue<types::SigningConfigResponse>, Error<()>> {
            let Self { client, repo_id } = self;
            let repo_id = repo_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/repositories/{}/config",
                client.baseurl,
                encode_path(&repo_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_repo_signing_config",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::update_repo_signing_config`]\n\n[`ClientSigningExt::update_repo_signing_config`]: super::ClientSigningExt::update_repo_signing_config"]
    #[derive(Debug, Clone)]
    pub struct UpdateRepoSigningConfig<'a> {
        client: &'a super::Client,
        repo_id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateSigningConfigPayload, String>,
    }
    impl<'a> UpdateRepoSigningConfig<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                repo_id: Err("repo_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn repo_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repo_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for repo_id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateSigningConfigPayload>,
            <V as std::convert::TryInto<types::UpdateSigningConfigPayload>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateSigningConfigPayload` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateSigningConfigPayload,
                ) -> types::builder::UpdateSigningConfigPayload,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/signing/repositories/{repo_id}/config`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RepositorySigningConfig>, Error<()>> {
            let Self {
                client,
                repo_id,
                body,
            } = self;
            let repo_id = repo_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateSigningConfigPayload::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/repositories/{}/config",
                client.baseurl,
                encode_path(&repo_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_repo_signing_config",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientSigningExt::get_repo_public_key`]\n\n[`ClientSigningExt::get_repo_public_key`]: super::ClientSigningExt::get_repo_public_key"]
    #[derive(Debug, Clone)]
    pub struct GetRepoPublicKey<'a> {
        client: &'a super::Client,
        repo_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetRepoPublicKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                repo_id: Err("repo_id was not initialized".to_string()),
            }
        }
        pub fn repo_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repo_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for repo_id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/signing/repositories/{repo_id}/public-key`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<()>> {
            let Self { client, repo_id } = self;
            let repo_id = repo_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/signing/repositories/{}/public-key",
                client.baseurl,
                encode_path(&repo_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "get_repo_public_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::stream(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::list_sync_policies`]\n\n[`ClientPeersExt::list_sync_policies`]: super::ClientPeersExt::list_sync_policies"]
    #[derive(Debug, Clone)]
    pub struct ListSyncPolicies<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListSyncPolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/api/v1/sync-policies`"]
        pub async fn send(self) -> Result<ResponseValue<types::SyncPolicyListResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/sync-policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_sync_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::create_sync_policy`]\n\n[`ClientPeersExt::create_sync_policy`]: super::ClientPeersExt::create_sync_policy"]
    #[derive(Debug, Clone)]
    pub struct CreateSyncPolicy<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateSyncPolicyPayload, String>,
    }
    impl<'a> CreateSyncPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSyncPolicyPayload>,
            <V as std::convert::TryInto<types::CreateSyncPolicyPayload>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateSyncPolicyPayload` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateSyncPolicyPayload,
                ) -> types::builder::CreateSyncPolicyPayload,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sync-policies`"]
        pub async fn send(self) -> Result<ResponseValue<types::SyncPolicyResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateSyncPolicyPayload::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sync-policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_sync_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::evaluate_policies`]\n\n[`ClientPeersExt::evaluate_policies`]: super::ClientPeersExt::evaluate_policies"]
    #[derive(Debug, Clone)]
    pub struct EvaluatePolicies<'a> {
        client: &'a super::Client,
    }
    impl<'a> EvaluatePolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `POST` request to `/api/v1/sync-policies/evaluate`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvaluationResultResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/api/v1/sync-policies/evaluate", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "evaluate_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::preview_sync_policy`]\n\n[`ClientPeersExt::preview_sync_policy`]: super::ClientPeersExt::preview_sync_policy"]
    #[derive(Debug, Clone)]
    pub struct PreviewSyncPolicy<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PreviewPolicyPayload, String>,
    }
    impl<'a> PreviewSyncPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PreviewPolicyPayload>,
            <V as std::convert::TryInto<types::PreviewPolicyPayload>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `PreviewPolicyPayload` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::PreviewPolicyPayload,
                ) -> types::builder::PreviewPolicyPayload,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sync-policies/preview`"]
        pub async fn send(self) -> Result<ResponseValue<types::PreviewResultResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::PreviewPolicyPayload::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/sync-policies/preview", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "preview_sync_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::get_sync_policy`]\n\n[`ClientPeersExt::get_sync_policy`]: super::ClientPeersExt::get_sync_policy"]
    #[derive(Debug, Clone)]
    pub struct GetSyncPolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetSyncPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/sync-policies/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SyncPolicyResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sync-policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_sync_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::update_sync_policy`]\n\n[`ClientPeersExt::update_sync_policy`]: super::ClientPeersExt::update_sync_policy"]
    #[derive(Debug, Clone)]
    pub struct UpdateSyncPolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateSyncPolicyPayload, String>,
    }
    impl<'a> UpdateSyncPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateSyncPolicyPayload>,
            <V as std::convert::TryInto<types::UpdateSyncPolicyPayload>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateSyncPolicyPayload` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateSyncPolicyPayload,
                ) -> types::builder::UpdateSyncPolicyPayload,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PUT` request to `/api/v1/sync-policies/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SyncPolicyResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateSyncPolicyPayload::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sync-policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_sync_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::delete_sync_policy`]\n\n[`ClientPeersExt::delete_sync_policy`]: super::ClientPeersExt::delete_sync_policy"]
    #[derive(Debug, Clone)]
    pub struct DeleteSyncPolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteSyncPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/sync-policies/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sync-policies/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_sync_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientPeersExt::toggle_policy`]\n\n[`ClientPeersExt::toggle_policy`]: super::ClientPeersExt::toggle_policy"]
    #[derive(Debug, Clone)]
    pub struct TogglePolicy<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::TogglePolicyPayload, String>,
    }
    impl<'a> TogglePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TogglePolicyPayload>,
            <V as std::convert::TryInto<types::TogglePolicyPayload>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TogglePolicyPayload` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::TogglePolicyPayload,
                ) -> types::builder::TogglePolicyPayload,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/sync-policies/{id}/toggle`"]
        pub async fn send(self) -> Result<ResponseValue<types::SyncPolicyResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::TogglePolicyPayload::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/sync-policies/{}/toggle",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "toggle_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientRepositoriesExt::get_tree`]\n\n[`ClientRepositoriesExt::get_tree`]: super::ClientRepositoriesExt::get_tree"]
    #[derive(Debug, Clone)]
    pub struct GetTree<'a> {
        client: &'a super::Client,
        include_metadata: Result<Option<bool>, String>,
        path: Result<Option<::std::string::String>, String>,
        repository_key: Result<Option<::std::string::String>, String>,
    }
    impl<'a> GetTree<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                include_metadata: Ok(None),
                path: Ok(None),
                repository_key: Ok(None),
            }
        }
        pub fn include_metadata<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_metadata = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_metadata failed".to_string());
            self
        }
        pub fn path<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.path = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for path failed".to_string()
            });
            self
        }
        pub fn repository_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.repository_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for repository_key failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/tree`"]
        pub async fn send(self) -> Result<ResponseValue<types::TreeResponse>, Error<()>> {
            let Self {
                client,
                include_metadata,
                path,
                repository_key,
            } = self;
            let include_metadata = include_metadata.map_err(Error::InvalidRequest)?;
            let path = path.map_err(Error::InvalidRequest)?;
            let repository_key = repository_key.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/tree", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "include_metadata",
                    &include_metadata,
                ))
                .query(&progenitor_client::QueryParam::new("path", &path))
                .query(&progenitor_client::QueryParam::new(
                    "repository_key",
                    &repository_key,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_tree",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::list_users`]\n\n[`ClientUsersExt::list_users`]: super::ClientUsersExt::list_users"]
    #[derive(Debug, Clone)]
    pub struct ListUsers<'a> {
        client: &'a super::Client,
        is_active: Result<Option<bool>, String>,
        is_admin: Result<Option<bool>, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        search: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListUsers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                is_active: Ok(None),
                is_admin: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                search: Ok(None),
            }
        }
        pub fn is_active<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.is_active = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for is_active failed".to_string());
            self
        }
        pub fn is_admin<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.is_admin = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for is_admin failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn search<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.search = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for search failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/users`"]
        pub async fn send(self) -> Result<ResponseValue<types::UserListResponse>, Error<()>> {
            let Self {
                client,
                is_active,
                is_admin,
                page,
                per_page,
                search,
            } = self;
            let is_active = is_active.map_err(Error::InvalidRequest)?;
            let is_admin = is_admin.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let search = search.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("is_active", &is_active))
                .query(&progenitor_client::QueryParam::new("is_admin", &is_admin))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("search", &search))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_users",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::create_user`]\n\n[`ClientUsersExt::create_user`]: super::ClientUsersExt::create_user"]
    #[derive(Debug, Clone)]
    pub struct CreateUser<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateUserRequest, String>,
    }
    impl<'a> CreateUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateUserRequest>,
            <V as std::convert::TryInto<types::CreateUserRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateUserRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateUserRequest,
                ) -> types::builder::CreateUserRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/users`"]
        pub async fn send(self) -> Result<ResponseValue<types::CreateUserResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateUserRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                409u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::get_user`]\n\n[`ClientUsersExt::get_user`]: super::ClientUsersExt::get_user"]
    #[derive(Debug, Clone)]
    pub struct GetUser<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/users/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::AdminUserResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::delete_user`]\n\n[`ClientUsersExt::delete_user`]: super::ClientUsersExt::delete_user"]
    #[derive(Debug, Clone)]
    pub struct DeleteUser<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/users/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::update_user`]\n\n[`ClientUsersExt::update_user`]: super::ClientUsersExt::update_user"]
    #[derive(Debug, Clone)]
    pub struct UpdateUser<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::UpdateUserRequest, String>,
    }
    impl<'a> UpdateUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateUserRequest>,
            <V as std::convert::TryInto<types::UpdateUserRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateUserRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateUserRequest,
                ) -> types::builder::UpdateUserRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/api/v1/users/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::AdminUserResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateUserRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::change_password`]\n\n[`ClientUsersExt::change_password`]: super::ClientUsersExt::change_password"]
    #[derive(Debug, Clone)]
    pub struct ChangePassword<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::ChangePasswordRequest, String>,
    }
    impl<'a> ChangePassword<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ChangePasswordRequest>,
            <V as std::convert::TryInto<types::ChangePasswordRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ChangePasswordRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::ChangePasswordRequest,
                ) -> types::builder::ChangePasswordRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/users/{id}/password`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ChangePasswordRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/password",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "change_password",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::reset_password`]\n\n[`ClientUsersExt::reset_password`]: super::ClientUsersExt::reset_password"]
    #[derive(Debug, Clone)]
    pub struct ResetPassword<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ResetPassword<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/users/{id}/password/reset`"]
        pub async fn send(self) -> Result<ResponseValue<types::ResetPasswordResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/password/reset",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "reset_password",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::get_user_roles`]\n\n[`ClientUsersExt::get_user_roles`]: super::ClientUsersExt::get_user_roles"]
    #[derive(Debug, Clone)]
    pub struct GetUserRoles<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetUserRoles<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/users/{id}/roles`"]
        pub async fn send(self) -> Result<ResponseValue<types::RoleListResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/roles",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_user_roles",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::assign_role`]\n\n[`ClientUsersExt::assign_role`]: super::ClientUsersExt::assign_role"]
    #[derive(Debug, Clone)]
    pub struct AssignRole<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::AssignRoleRequest, String>,
    }
    impl<'a> AssignRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AssignRoleRequest>,
            <V as std::convert::TryInto<types::AssignRoleRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AssignRoleRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::AssignRoleRequest,
                ) -> types::builder::AssignRoleRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/users/{id}/roles`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AssignRoleRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/roles",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "assign_role",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::revoke_role`]\n\n[`ClientUsersExt::revoke_role`]: super::ClientUsersExt::revoke_role"]
    #[derive(Debug, Clone)]
    pub struct RevokeRole<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        role_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RevokeRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                role_id: Err("role_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn role_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.role_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for role_id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/users/{id}/roles/{role_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                role_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let role_id = role_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/roles/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&role_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "revoke_role",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::list_user_tokens`]\n\n[`ClientUsersExt::list_user_tokens`]: super::ClientUsersExt::list_user_tokens"]
    #[derive(Debug, Clone)]
    pub struct ListUserTokens<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> ListUserTokens<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/users/{id}/tokens`"]
        pub async fn send(self) -> Result<ResponseValue<types::ApiTokenListResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/tokens",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_user_tokens",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::create_user_api_token`]\n\n[`ClientUsersExt::create_user_api_token`]: super::ClientUsersExt::create_user_api_token"]
    #[derive(Debug, Clone)]
    pub struct CreateUserApiToken<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::CreateApiTokenRequest, String>,
    }
    impl<'a> CreateUserApiToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateApiTokenRequest>,
            <V as std::convert::TryInto<types::CreateApiTokenRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateApiTokenRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateApiTokenRequest,
                ) -> types::builder::CreateApiTokenRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/users/{id}/tokens`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ApiTokenCreatedResponse>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateApiTokenRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/tokens",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_user_api_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientUsersExt::revoke_user_api_token`]\n\n[`ClientUsersExt::revoke_user_api_token`]: super::ClientUsersExt::revoke_user_api_token"]
    #[derive(Debug, Clone)]
    pub struct RevokeUserApiToken<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        token_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> RevokeUserApiToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                token_id: Err("token_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn token_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.token_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for token_id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/users/{id}/tokens/{token_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                token_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let token_id = token_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/users/{}/tokens/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&token_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "revoke_user_api_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                403u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::list_webhooks`]\n\n[`ClientWebhooksExt::list_webhooks`]: super::ClientWebhooksExt::list_webhooks"]
    #[derive(Debug, Clone)]
    pub struct ListWebhooks<'a> {
        client: &'a super::Client,
        enabled: Result<Option<bool>, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        repository_id: Result<Option<::uuid::Uuid>, String>,
    }
    impl<'a> ListWebhooks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                enabled: Ok(None),
                page: Ok(None),
                per_page: Ok(None),
                repository_id: Ok(None),
            }
        }
        pub fn enabled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.enabled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for enabled failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn repository_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.repository_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for repository_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/webhooks`"]
        pub async fn send(self) -> Result<ResponseValue<types::WebhookListResponse>, Error<()>> {
            let Self {
                client,
                enabled,
                page,
                per_page,
                repository_id,
            } = self;
            let enabled = enabled.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let repository_id = repository_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/webhooks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("enabled", &enabled))
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new(
                    "repository_id",
                    &repository_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_webhooks",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::create_webhook`]\n\n[`ClientWebhooksExt::create_webhook`]: super::ClientWebhooksExt::create_webhook"]
    #[derive(Debug, Clone)]
    pub struct CreateWebhook<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateWebhookRequest, String>,
    }
    impl<'a> CreateWebhook<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateWebhookRequest>,
            <V as std::convert::TryInto<types::CreateWebhookRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateWebhookRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateWebhookRequest,
                ) -> types::builder::CreateWebhookRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/webhooks`"]
        pub async fn send(self) -> Result<ResponseValue<types::WebhookResponse>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateWebhookRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/api/v1/webhooks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_webhook",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                422u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::get_webhook`]\n\n[`ClientWebhooksExt::get_webhook`]: super::ClientWebhooksExt::get_webhook"]
    #[derive(Debug, Clone)]
    pub struct GetWebhook<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetWebhook<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/webhooks/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::WebhookResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_webhook",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::delete_webhook`]\n\n[`ClientWebhooksExt::delete_webhook`]: super::ClientWebhooksExt::delete_webhook"]
    #[derive(Debug, Clone)]
    pub struct DeleteWebhook<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteWebhook<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `DELETE` request to `/api/v1/webhooks/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_webhook",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::list_deliveries`]\n\n[`ClientWebhooksExt::list_deliveries`]: super::ClientWebhooksExt::list_deliveries"]
    #[derive(Debug, Clone)]
    pub struct ListDeliveries<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        page: Result<Option<i32>, String>,
        per_page: Result<Option<i32>, String>,
        status: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListDeliveries<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                page: Ok(None),
                per_page: Ok(None),
                status: Ok(None),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for page failed".to_string());
            self
        }
        pub fn per_page<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.per_page = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for per_page failed".to_string());
            self
        }
        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.status = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for status failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/api/v1/webhooks/{id}/deliveries`"]
        pub async fn send(self) -> Result<ResponseValue<types::DeliveryListResponse>, Error<()>> {
            let Self {
                client,
                id,
                page,
                per_page,
                status,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let page = page.map_err(Error::InvalidRequest)?;
            let per_page = per_page.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}/deliveries",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("page", &page))
                .query(&progenitor_client::QueryParam::new("per_page", &per_page))
                .query(&progenitor_client::QueryParam::new("status", &status))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_deliveries",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::redeliver`]\n\n[`ClientWebhooksExt::redeliver`]: super::ClientWebhooksExt::redeliver"]
    #[derive(Debug, Clone)]
    pub struct Redeliver<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
        delivery_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> Redeliver<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
                delivery_id: Err("delivery_id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        pub fn delivery_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.delivery_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for delivery_id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/webhooks/{id}/deliveries/{delivery_id}/redeliver`"]
        pub async fn send(self) -> Result<ResponseValue<types::DeliveryResponse>, Error<()>> {
            let Self {
                client,
                id,
                delivery_id,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let delivery_id = delivery_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}/deliveries/{}/redeliver",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&delivery_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "redeliver",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::disable_webhook`]\n\n[`ClientWebhooksExt::disable_webhook`]: super::ClientWebhooksExt::disable_webhook"]
    #[derive(Debug, Clone)]
    pub struct DisableWebhook<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DisableWebhook<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/webhooks/{id}/disable`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}/disable",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "disable_webhook",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::enable_webhook`]\n\n[`ClientWebhooksExt::enable_webhook`]: super::ClientWebhooksExt::enable_webhook"]
    #[derive(Debug, Clone)]
    pub struct EnableWebhook<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> EnableWebhook<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/webhooks/{id}/enable`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}/enable",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "enable_webhook",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientWebhooksExt::test_webhook`]\n\n[`ClientWebhooksExt::test_webhook`]: super::ClientWebhooksExt::test_webhook"]
    #[derive(Debug, Clone)]
    pub struct TestWebhook<'a> {
        client: &'a super::Client,
        id: Result<::uuid::Uuid, String>,
    }
    impl<'a> TestWebhook<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }
        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for id failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/api/v1/webhooks/{id}/test`"]
        pub async fn send(self) -> Result<ResponseValue<types::TestWebhookResponse>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/api/v1/webhooks/{}/test",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "test_webhook",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientHealthExt::health_check`]\n\n[`ClientHealthExt::health_check`]: super::ClientHealthExt::health_check"]
    #[derive(Debug, Clone)]
    pub struct HealthCheck<'a> {
        client: &'a super::Client,
    }
    impl<'a> HealthCheck<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/health`"]
        pub async fn send(self) -> Result<ResponseValue<types::HealthResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/health", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "health_check",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                503u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientHealthExt::liveness_check`]\n\n[`ClientHealthExt::liveness_check`]: super::ClientHealthExt::liveness_check"]
    #[derive(Debug, Clone)]
    pub struct LivenessCheck<'a> {
        client: &'a super::Client,
    }
    impl<'a> LivenessCheck<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/livez`"]
        pub async fn send(self) -> Result<ResponseValue<types::LivezResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/livez", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "liveness_check",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`ClientHealthExt::readiness_check`]\n\n[`ClientHealthExt::readiness_check`]: super::ClientHealthExt::readiness_check"]
    #[derive(Debug, Clone)]
    pub struct ReadinessCheck<'a> {
        client: &'a super::Client,
    }
    impl<'a> ReadinessCheck<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        #[doc = "Sends a `GET` request to `/readyz`"]
        pub async fn send(self) -> Result<ResponseValue<types::ReadyzResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/readyz", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "readiness_check",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                503u16 => Err(Error::ErrorResponse(ResponseValue::empty(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
#[doc = r" Items consumers will typically use such as the Client and"]
#[doc = r" extension traits."]
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
    pub use super::ClientAdminExt;
    pub use super::ClientAnalyticsExt;
    pub use super::ClientApprovalExt;
    pub use super::ClientArtifactsExt;
    pub use super::ClientAuthExt;
    pub use super::ClientBuildsExt;
    pub use super::ClientGroupsExt;
    pub use super::ClientHealthExt;
    pub use super::ClientLifecycleExt;
    pub use super::ClientMigrationExt;
    pub use super::ClientMonitoringExt;
    pub use super::ClientPackagesExt;
    pub use super::ClientPeerInstanceLabelsExt;
    pub use super::ClientPeersExt;
    pub use super::ClientPermissionsExt;
    pub use super::ClientPluginsExt;
    pub use super::ClientPromotionExt;
    pub use super::ClientQualityExt;
    pub use super::ClientRepositoriesExt;
    pub use super::ClientRepositoryLabelsExt;
    pub use super::ClientSbomExt;
    pub use super::ClientSearchExt;
    pub use super::ClientSecurityExt;
    pub use super::ClientSigningExt;
    pub use super::ClientSsoExt;
    pub use super::ClientTelemetryExt;
    pub use super::ClientUsersExt;
    pub use super::ClientWebhooksExt;
}
